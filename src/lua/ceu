#!/usr/bin/env lua5.3
--[[
-- This file is automatically generated.
-- Check the github repository for a readable version:
-- http://github.com/fsantanna/ceu
--
-- Céu is distributed under the MIT License:
--

Copyright (C) 2012-2016 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--
--]]

PAK = {
    lua_exe = 'lua5.3',
    ceu_ver = '0.20',
    ceu_git = '7f3a29f0ef155fbd86a7004399007f3d317dba6f',
    files = {
        ceu_c =
            [====[
#include <stdlib.h>     /* NULL */
#include <string.h>     /* memcpy */

typedef struct {
    usize max;
    usize len;
    usize unit;
    u8    is_dyn:     1;
    u8    is_freezed: 1;
    byte* buf;
} tceu_vector;

#define ceu_vector_buf_len(vec)           ((vec)->len * (vec)->unit)
#define ceu_vector_buf_get(vec,idx)       (&(vec)->buf[(idx)*(vec)->unit])
#define ceu_vector_buf_set(vec,idx,buf,n) memcpy(ceu_vector_buf_get((vec),(idx)),(buf),(n))

#define ceu_vector_setlen(a,b,c) ceu_vector_setlen_ex(a,b,c,__FILE__,__LINE__)
#define ceu_vector_geti(a,b)     ceu_vector_geti_ex(a,b,__FILE__,__LINE__)

void  ceu_vector_init         (tceu_vector* vector, usize max, bool is_dyn,
                               usize unit, byte* buf);
byte* ceu_vector_setmax       (tceu_vector* vector, usize len, bool freeze);
int   ceu_vector_setlen_could (tceu_vector* vector, usize len, bool grow);
void  ceu_vector_setlen_ex    (tceu_vector* vector, usize len, bool grow,
                               char* file, int line);
byte* ceu_vector_geti_ex      (tceu_vector* vector, usize idx,
                               char* file, int line);

#if 0
char* ceu_vector_tochar (tceu_vector* vector);
#endif

void ceu_vector_init (tceu_vector* vector, usize max, bool is_dyn, usize unit, byte* buf) {
    vector->len        = 0;
    vector->max        = max;
    vector->unit       = unit;
    vector->is_dyn     = is_dyn;
    vector->is_freezed = 0;
    vector->buf        = buf;

    /* [STRING] */
    if (vector->buf != NULL) {
        vector->buf[0] = '\0';
    }
}

byte* ceu_vector_setmax (tceu_vector* vector, usize len, bool freeze) {
    ceu_dbg_assert(vector->is_dyn);

    if (len == 0) {
        /* free */
        if (vector->buf != NULL) {
            vector->max = 0;
            ceu_callback_ptr_num(CEU_CALLBACK_REALLOC, vector->buf, 0);
            vector->buf = NULL;
        }
    } else {
        vector->max = len;
        vector->buf = (byte*) ceu_callback_ptr_size(
                                CEU_CALLBACK_REALLOC,
                                vector->buf,
                                len*vector->unit + 1    /* [STRING] +1 */
                              ).value.ptr;
    }

    if (freeze) {
        vector->is_freezed = 1;
    }

    return vector->buf;
}

int ceu_vector_setlen_could (tceu_vector* vector, usize len, bool grow)
{
    /* must fit w/o growing */
    if (!grow) {
        if (len > vector->len) {
            return 0;
        }
    }

    /* fixed size */
    if (!vector->is_dyn || vector->is_freezed) {
        if (len > vector->max) {
            return 0;
        }

    /* variable size */
    } else {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
        } else {
            /* grow vector */
            if (ceu_vector_setmax(vector,len,0) == NULL) {
                if (len != 0) {
                    return 0;
                }
            }
        }
    }

    return 1;
}

void ceu_vector_setlen_ex (tceu_vector* vector, usize len, bool grow,
                           char* file, int line)
{
    /* must fit w/o growing */
    if (!grow) {
        ceu_callback_assert_msg_ex(len <= vector->len, "access out of bounds",
                             file, line);
    }

    /* fixed size */
    if (!vector->is_dyn || vector->is_freezed) {
        ceu_callback_assert_msg_ex(len <= vector->max, "access out of bounds",
                             file, line);

    /* variable size */
    } else {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
/* TODO: shrink memory */
        } else {
            /* grow vector */
            if (ceu_vector_setmax(vector,len,0) == NULL) {
                ceu_callback_assert_msg_ex(len==0, "access out of bounds",
                                     file, line);
            }
        }
    }

    /* [STRING] */
    if (vector->buf != NULL) {
        vector->buf[len*vector->unit] = '\0';
    }
    vector->len = len;
}

byte* ceu_vector_geti_ex (tceu_vector* vector, usize idx, char* file, int line) {
    ceu_callback_assert_msg_ex(idx < vector->len, "access out of bounds", file, line);
    return ceu_vector_buf_get(vector, idx);
}

#if 0
char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->buf == NULL) {
        return "";
    } else {
        return (char*)vector->buf;
    }
}
#endif
]====]..
            [====[
#include <stdlib.h>     /* NULL */

typedef struct {
    usize   len;
    usize   free;
    usize   index;
    usize   unit;
    byte*   buf;
    byte**  queue; /* NULL on dynamic pools */
} tceu_pool;

void ceu_pool_init (tceu_pool* pool, usize len, usize unit, byte** queue, byte* buf)
{
    usize i;
    pool->len   = len;
    pool->free  = len;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->buf   = buf;
    for (i=0; i<len; i++) {
        queue[i] = &buf[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->len) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    usize empty = pool->index + pool->free;
    if (empty >= pool->len) {
        empty -= pool->len;
    }
    pool->queue[empty] = val;
    pool->free++;
}
]====]..
            [====[
=== FEATURES ===        /* CEU_FEATURES */

#include <stdlib.h>     /* NULL */
#include <string.h>     /* memset, strlen */
#ifdef CEU_TESTS
#include <stdio.h>
#endif

#ifdef CEU_FEATURES_LUA
#include <lua5.3/lua.h>
#include <lua5.3/lauxlib.h>
#include <lua5.3/lualib.h>
#endif

#define S8_MIN   -127
#define S8_MAX    127
#define U8_MAX    255

#define S16_MIN  -32767
#define S16_MAX   32767
#define U16_MAX   65535

#define S32_MIN  -2147483647
#define S32_MAX   2147483647
#define U32_MAX   4294967295

#define S64_MIN  -9223372036854775807
#define S64_MAX   9223372036854775807
#define U64_MAX   18446744073709551615

#define CEU_SEQ_MAX (U16_MAX/2)
/* TODO */

typedef u16 tceu_nevt;   /* TODO */
typedef u16 tceu_nseq;   /* TODO */
typedef === TCEU_NTRL === tceu_ntrl;
typedef === TCEU_NLBL === tceu_nlbl;

#define CEU_API
CEU_API void ceu_start (void);
CEU_API void ceu_stop  (void);
CEU_API void ceu_input (tceu_nevt evt_id, void* evt_params);
CEU_API int  ceu_loop  (void);

struct tceu_stk;
struct tceu_code_mem;
struct tceu_code_mem_dyn;
struct tceu_evt_occ;

typedef struct tceu_evt {
    tceu_nevt id;
    union {
        void* mem;                              /* CEU_INPUT__CODE, CEU_EVENT__MIN */
        struct tceu_code_mem_dyn* pool_first;   /* CEU_INPUT__CODE_POOL */
    };
} tceu_evt;

typedef struct tceu_evt_range {
    struct tceu_code_mem* mem;
    tceu_ntrl             trl0;
    tceu_ntrl             trlF;
} tceu_evt_range;

typedef struct tceu_evt_occ {
    tceu_evt       evt;
    tceu_nseq      seq;
    void*          params;
    tceu_evt_range range;
} tceu_evt_occ;

typedef struct tceu_trl {
    struct {
        tceu_evt evt;
        union {
            /* NORMAL, CEU_EVENT__MIN */
            struct {
                tceu_nlbl lbl;
                union {
                    tceu_nseq seq;              /* NORMAL */
                    tceu_evt_range clr_range;   /* CEU_INPUT__CLEAR */
                };
            };

            /* CEU_INPUT__PAUSE_BLOCK */
            struct {
                tceu_evt  pse_evt;
                tceu_ntrl pse_skip;
                u8        pse_paused;
            };
        };
    };
} tceu_trl;

struct tceu_pool_pak;
typedef struct tceu_code_mem {
    struct tceu_pool_pak* pak;
    struct tceu_code_mem* up_mem;
    tceu_ntrl  up_trl;
#ifdef CEU_FEATURES_LUA
    lua_State* lua;
#endif
    tceu_ntrl  trails_n;
    tceu_trl   trails[0];
} tceu_code_mem;

typedef enum tceu_code_mem_dyn_state {
    CEU_CODE_MEM_DYN_STATE_NONE,
    CEU_CODE_MEM_DYN_STATE_TRAVERSING,
    CEU_CODE_MEM_DYN_STATE_DELETE,
} tceu_code_mem_dyn_state;

typedef struct tceu_code_mem_dyn {
    struct tceu_code_mem_dyn* prv;
    struct tceu_code_mem_dyn* nxt;
    u8 state;
    tceu_code_mem mem[0];   /* actual tceu_code_mem is in sequence */
} tceu_code_mem_dyn;

typedef struct tceu_pool_pak {
    tceu_pool         pool;
    tceu_code_mem_dyn first;
    tceu_code_mem*    up_mem;
    tceu_ntrl         up_trl;
} tceu_pool_pak;

typedef struct tceu_opt_alias {
    void*          alias;
    tceu_evt       evt;     /* TODO: alias points to copied evt (extra space) */
    tceu_evt_range range;
} tceu_opt_alias;

static tceu_evt* CEU_OPTION_EVT (tceu_evt* alias, char* file, int line) {
    ceu_callback_assert_msg_ex(alias != NULL, "value is not set", file, line);
    return alias;
}

#ifdef CEU_FEATURES_THREAD
typedef struct tceu_threads_data {
    CEU_THREADS_T id;
    u8 has_started:    1;
    u8 has_terminated: 1;
    u8 has_aborted:    1;
    u8 has_notified:   1;
    struct tceu_threads_data* nxt;
} tceu_threads_data;

typedef struct {
    tceu_code_mem*     mem;
    tceu_threads_data* thread;
} tceu_threads_param;
#endif

/*****************************************************************************/

/* NATIVE_PRE */
=== NATIVE_PRE ===

/* EVENTS_ENUM */

enum {
    /* non-emitable */
    CEU_INPUT__NONE = 0,
    CEU_INPUT__FINALIZE,
    CEU_INPUT__PAUSE_BLOCK,
    CEU_INPUT__CODE,
    CEU_INPUT__CODE_POOL,

    /* emitable */
    CEU_INPUT__CLEAR,           /* 5 */
    CEU_INPUT__PAUSE,
    CEU_INPUT__RESUME,
CEU_INPUT__SEQ,
    CEU_INPUT__ASYNC,
    CEU_INPUT__THREAD,
    CEU_INPUT__WCLOCK,
    === EXTS_ENUM_INPUT ===

CEU_EVENT__MIN,
    === EVTS_ENUM ===
};

enum {
    CEU_OUTPUT__NONE = 0,
    === EXTS_ENUM_OUTPUT ===
};

/* EVENTS_DEFINES */

=== EXTS_DEFINES_INPUT_OUTPUT ===

/* DATAS_HIERS */

typedef s16 tceu_ndata;  /* TODO */

=== DATAS_HIERS ===

static int ceu_data_is (tceu_ndata* supers, tceu_ndata me, tceu_ndata cmp) {
    return (me==cmp || (me!=0 && ceu_data_is(supers,supers[me],cmp)));
}

static void* ceu_data_as (tceu_ndata* supers, tceu_ndata* me, tceu_ndata cmp,
                          char* file, int line) {
    ceu_callback_assert_msg_ex(ceu_data_is(supers, *me, cmp),
                               "invalid cast `as´", file, line);
    return me;
}

/* DATAS_MEMS */

=== DATAS_MEMS ===

/*****************************************************************************/

=== CODES_MEMS ===
=== CODES_ARGS ===

=== EXTS_TYPES ===
=== EVTS_TYPES ===

enum {
    CEU_LABEL_NONE = 0,
    === LABELS ===
};

typedef struct tceu_app {
    tceu_nseq seq;
    tceu_nseq seq_base;

    /* WCLOCK */
    s32 wclk_late;
    s32 wclk_min_set;
    s32 wclk_min_cmp;

#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_T threads_mutex;
    tceu_threads_data*  threads_head;   /* linked list of threads alive */
#endif

    tceu_code_mem_ROOT root;
} tceu_app;

static tceu_app CEU_APP;

/*****************************************************************************/

typedef struct tceu_stk {
    u8               is_alive : 1;
    struct tceu_stk* down;
    tceu_evt_range   range;
} tceu_stk;

static int ceu_mem_is_child (tceu_code_mem* me, tceu_code_mem* par_mem,
                             tceu_ntrl par_trl1, tceu_ntrl par_trl2)
{
    if (me == par_mem) {
        return (par_trl1==0 && par_trl2==me->trails_n-1);
    }

    tceu_code_mem* cur_mem;
    for (cur_mem=me; cur_mem!=NULL; cur_mem=cur_mem->up_mem) {
        if (cur_mem->up_mem == par_mem) {
            if (cur_mem->up_trl>=par_trl1 && cur_mem->up_trl<=par_trl2) {
                return 1;
            }
        }
    }
    return 0;
}

static void ceu_stack_clear (tceu_stk* stk, tceu_code_mem* mem,
                             tceu_ntrl trl0, tceu_ntrl trlF) {
    for (; stk!=NULL; stk=stk->down) {
        if (!stk->is_alive) {
            continue;
        }
        if (stk->range.mem != mem) {
            /* check if "stk->range.mem" is child of "mem" in between "[trl0,trlF]" */
            if (ceu_mem_is_child(stk->range.mem, mem, trl0, trlF)) {
                stk->is_alive = 0;
            }
        } else if (trl0<=stk->range.trl0 && stk->range.trlF<=trlF) {  /* [trl0,trlF] */
            stk->is_alive = 0;
        }
    }
}

#if 0
static void ceu_stack_dump (tceu_stk* stk) {
    for (; stk!=&CEU_STK_BASE; stk=stk->down) {
        printf("stk=%p mem=%p\n", stk, stk->mem);
    }
}
#endif

/*****************************************************************************/

#define CEU_WCLOCK_INACTIVE INT32_MAX

static int ceu_wclock (s32 dt, s32* set, s32* sub)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "sub") */

    /* SET */
    if (set != NULL) {
        t = dt - CEU_APP.wclk_late;
        *set = t;

    /* SUB */
    } else {
        t = *sub;
        if ((t > CEU_APP.wclk_min_cmp) || (t > dt)) {
            *sub -= dt;    /* don't expire yet */
            t = *sub;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (CEU_APP.wclk_min_set > t) ) {
        CEU_APP.wclk_min_set = t;
        ceu_callback_num_ptr(CEU_CALLBACK_WCLOCK_MIN, t, NULL);
    }

    return ret;
}

/*****************************************************************************/

void ceu_code_mem_dyn_free (tceu_pool* pool, tceu_code_mem_dyn* cur) {
    cur->nxt->prv = cur->prv;
    cur->prv->nxt = cur->nxt;

    if (pool->queue == NULL) {
        /* dynamic pool */
        ceu_callback_ptr_num(CEU_CALLBACK_REALLOC, cur, 0);
    } else {
        /* static pool */
        ceu_pool_free(pool, (byte*)cur);
    }
}

/*****************************************************************************/

#ifdef CEU_FEATURES_LUA
int ceu_lua_atpanic (lua_State* lua) {
    const char* msg = lua_tostring(lua,-1);
    ceu_dbg_assert(msg != NULL);
    ceu_callback_assert_msg(0, msg);
    return 0;
}
#endif

/*****************************************************************************/

static void ceu_bcast (tceu_evt_occ* occ, tceu_stk* stk);
static void ceu_lbl (tceu_evt_occ* _ceu_occ, tceu_stk* _ceu_stk,
                     tceu_code_mem* _ceu_mem, tceu_ntrl _ceu_trlK, tceu_nlbl _ceu_lbl);

=== NATIVE_POS ===

=== THREADS ===

=== CODES_WRAPPERS ===

/*****************************************************************************/

#ifdef CEU_FEATURES_THREAD
int ceu_threads_gc (int force_join) {
    int n_alive = 0;
    tceu_threads_data** head_ = &CEU_APP.threads_head;
    tceu_threads_data*  head  = *head_;
    while (head != NULL) {
        tceu_threads_data** nxt_ = &head->nxt;
        if (head->has_terminated || head->has_aborted)
        {
            if (!head->has_notified) {
                ceu_input(CEU_INPUT__THREAD, &head->id);
                head->has_notified = 1;
            }

            /* remove from list if rejoined */
            {
                int has_joined;
                if (force_join || head->has_terminated) {
                    CEU_THREADS_JOIN(head->id);
                    has_joined = 1;
                } else {
                    /* possible with "CANCEL" which prevents setting "has_terminated" */
                    has_joined = CEU_THREADS_JOIN_TRY(head->id);
                }
                if (has_joined) {
                    *head_ = head->nxt;
                    nxt_ = head_;
                    ceu_callback_ptr_num(CEU_CALLBACK_REALLOC, head, 0);
                }
            }
        }
        else
        {
            n_alive++;
        }
        head_ = nxt_;
        head  = *head_;
    }
    return n_alive;
}
#endif

/*****************************************************************************/

static void ceu_lbl (tceu_evt_occ* _ceu_occ, tceu_stk* _ceu_stk,
                     tceu_code_mem* _ceu_mem, tceu_ntrl _ceu_trlK, tceu_nlbl _ceu_lbl)
{
    switch (_ceu_lbl) {
        CEU_LABEL_NONE:
            break;
        === CODES ===
    }
}

#if defined(_CEU_DEBUG)
#define _CEU_DEBUG
static int xxx = 0;
#endif

static void ceu_bcast (tceu_evt_occ* occ, tceu_stk* stk)
{
    tceu_ntrl trlK;
    tceu_trl* trl;
    tceu_evt_range range = occ->range;

    ceu_callback_assert_msg(CEU_APP.seq-CEU_APP.seq_base < CEU_SEQ_MAX,
                            "too many internal reactions");
    CEU_APP.seq++;

    tceu_stk _stk = { 1, stk, range }; /* maybe nested bcast aborts it */

    /* MARK TRAILS TO EXECUTE */

#ifdef _CEU_DEBUG
for (int i=0; i<xxx; i++) {
    fprintf(stderr, " ");
}
fprintf(stderr, ">>> %d/%p [%p] %d->%d\n", occ->evt.id, occ->evt.mem,
                                           range.mem, range.trl0, range.trlF);
xxx += 4;
#endif

    /* CLEAR: inverse execution order */
    tceu_ntrl trl0 = range.trl0;
    tceu_ntrl trlF = range.trlF;
    if (occ->evt.id == CEU_INPUT__CLEAR) {
        tceu_ntrl tmp = trl0;
        trl0 = trlF;
        trlF = tmp;
    }

    for (trlK=trl0, trl=&range.mem->trails[trlK]; ;)
    {
#ifdef CEU_TESTS
        _ceu_tests_trails_visited_++;
#endif

#ifdef _CEU_DEBUG
for (int i=0; i<xxx; i++) {
    fprintf(stderr, " ");
}
fprintf(stderr, "??? trlK=%d, evt=%d\n", trlK, trl->evt.id);
#endif

        /* special trails: propagate, skip paused */

        switch (trl->evt.id)
        {
            /* propagate "occ" to nested "code/pool" */
            case CEU_INPUT__CODE: {
                tceu_evt_range _range = { (tceu_code_mem*)trl->evt.mem,
                                          0, (tceu_ntrl)(((tceu_code_mem*)trl->evt.mem)->trails_n-1) };
                occ->range = _range;
                ceu_bcast(occ, &_stk);
                if (!_stk.is_alive) {
                    goto _CEU_BREAK_;
                }
                break;
            }
            case CEU_INPUT__CODE_POOL: {
                tceu_code_mem_dyn* cur = trl->evt.pool_first->nxt;
#if 0
printf(">>> BCAST[%p]:\n", trl->pool_first);
printf(">>> BCAST[%p]: %p / %p\n", trl->pool_first, cur, &cur->mem[0]);
#endif
                while (cur != trl->evt.pool_first) {
                    tceu_code_mem_dyn* nxt = cur->nxt;
                    tceu_evt_range _range = { &cur->mem[0],
                                              0, (tceu_ntrl)((&cur->mem[0])->trails_n-1) };
                    occ->range = _range;
                    ceu_bcast(occ, &_stk);
                    if (!_stk.is_alive) {
                        goto _CEU_BREAK_;
                    }
                    cur = nxt;
                }
                break;
            }

            /* skip "paused" blocks || set "paused" block */
            case CEU_INPUT__PAUSE_BLOCK: {
                u8 was_paused = trl->pse_paused;
                if (occ->evt.id==trl->pse_evt.id &&
                    (occ->evt.id<CEU_EVENT__MIN || occ->evt.mem==trl->pse_evt.mem))
                {
                    if (*((u8*)occ->params) != trl->pse_paused) {
                        trl->pse_paused = *((u8*)occ->params);

                        if (trl->pse_paused) {
                            tceu_evt_occ occ2 = { {CEU_INPUT__PAUSE,{NULL}}, CEU_APP.seq, occ->params,
                                                  {range.mem,
                                                   trlK+1, trlK+trl->pse_skip}
                                                };
                            ceu_bcast(&occ2, &_stk);
                        } else {
                            tceu_evt_occ occ2 = { {CEU_INPUT__RESUME,{NULL}}, CEU_APP.seq, occ->params,
                                                  {range.mem,
                                                   trlK+1, trlK+trl->pse_skip}
                                                };
                            ceu_bcast(&occ2, &_stk);
                        }
                        if (!_stk.is_alive) {
                            goto _CEU_BREAK_;
                        }
                    }
                }
                /* don't skip if pausing now */
                if (was_paused && occ->evt.id!=CEU_INPUT__CLEAR) {
                                  /* also don't skip on CLEAR (going reverse) */
                    trlK += trl->pse_skip;
                    trl  += trl->pse_skip;
                    goto _CEU_AWAKE_NO_;
                }
                break;
            }
        }

        /* normal trails: check if awakes */

        if (occ->evt.id == CEU_INPUT__CLEAR) {
            tceu_evt_range* clr_range = (tceu_evt_range*) occ->params;

            int matches_clear_vs_trail = (clr_range->mem  == range.mem  &&
                                          clr_range->trl0 <= trlK       &&
                                          clr_range->trlF >= trlK)
                                            || ceu_mem_is_child(range.mem,
                                                    clr_range->mem,
                                                    clr_range->trl0,
                                                    clr_range->trlF);

            /* clearing this trail? */
            if (matches_clear_vs_trail) {
                if (trl->evt.id == CEU_INPUT__FINALIZE) {
                    /* FINALIZE awakes now on "mark" */
                    ceu_lbl(occ, NULL, range.mem, trlK, trl->lbl);
                }
                trl->evt.id = CEU_INPUT__NONE;

            /* clear matches CLEAR? */
            } else if (trl->evt.id == CEU_INPUT__CLEAR) {
                int matches_clear_vs_clear =
                        (clr_range->mem  == trl->clr_range.mem  &&
                         clr_range->trl0 <= trl->clr_range.trl0 &&
                         clr_range->trlF >= trl->clr_range.trlF);
                if (matches_clear_vs_clear) {
                    goto _CEU_AWAKE_YES_;
                }

            /* clear matches CODE? */
            } else if (trl->evt.id == CEU_INPUT__CODE) {
                if (ceu_mem_is_child((tceu_code_mem*)trl->evt.mem,
                                     clr_range->mem,
                                     clr_range->trl0, clr_range->trlF))
                {
                    goto _CEU_AWAKE_YES_;
                }
            }
        } else if (trl->evt.id == occ->evt.id) {
            if (occ->evt.id==CEU_INPUT__PAUSE || occ->evt.id==CEU_INPUT__RESUME) {
                goto _CEU_AWAKE_YES_;
            }
            if (trl->seq-CEU_APP.seq_base > occ->seq-CEU_APP.seq_base) {
                goto _CEU_AWAKE_NO_;
            }
            if (trl->evt.id > CEU_EVENT__MIN) {
                if (trl->evt.mem == occ->evt.mem) {
                    goto _CEU_AWAKE_YES_;   /* internal event matches "mem" */
                }
            } else {
                goto _CEU_AWAKE_YES_;       /* external event matches */
            }
        }

        goto _CEU_AWAKE_NO_;

_CEU_AWAKE_YES_:
#ifdef _CEU_DEBUG
for (int i=0; i<xxx+4; i++) {
    fprintf(stderr, " ");
}
fprintf(stderr, "+++ %d\n", trl->lbl);
#endif

        trl->evt.id = CEU_INPUT__NONE;
        ceu_lbl(occ, &_stk, range.mem, trlK, trl->lbl);
        if (!_stk.is_alive) {
#ifdef _CEU_DEBUG
fprintf(stderr, "break\n");
#endif
            goto _CEU_BREAK_;
        }

_CEU_AWAKE_NO_:
        if ((trl->evt.id > CEU_INPUT__SEQ) && (trl->seq > CEU_APP.seq_base+CEU_SEQ_MAX)) {
            trl->seq = CEU_APP.seq_base;
        }

        if (trlK == trlF) {
            break;
        } else if (occ->evt.id == CEU_INPUT__CLEAR) {
            trlK--; trl--;
        } else {
            trlK++; trl++;
        }
    }
_CEU_BREAK_:

    occ->range = range;

#ifdef _CEU_DEBUG
xxx -= 4;
for (int i=0; i<xxx; i++) {
    fprintf(stderr, " ");
}
fprintf(stderr, "<<< %d [%p] %d->%d\n", occ->evt.id, range.mem, range.trl0, range.trlF);
#endif
}

CEU_API void ceu_input (tceu_nevt evt_id, void* evt_params)
{
    CEU_APP.seq_base = CEU_APP.seq;

    tceu_evt_occ occ = { {evt_id,{NULL}}, CEU_APP.seq+1, evt_params,
                         {(tceu_code_mem*)&CEU_APP.root,
                          0, (tceu_ntrl)(CEU_APP.root.mem.trails_n-1)}
                       };
    switch (evt_id)
    {
        case CEU_INPUT__WCLOCK: {
            CEU_APP.wclk_min_cmp = CEU_APP.wclk_min_set;      /* swap "cmp" to last "set" */
            CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;    /* new "set" resets to inactive */
            if (CEU_APP.wclk_min_cmp <= *((s32*)evt_params)) {
                CEU_APP.wclk_late = *((s32*)evt_params) - CEU_APP.wclk_min_cmp;
            }
            break;
        }
    }

    tceu_stk stk = { 1, NULL,
                     { (tceu_code_mem*)&CEU_APP.root,
                       0, (tceu_ntrl)(CEU_APP.root.mem.trails_n-1) } };
    ceu_bcast(&occ, &stk);
}

CEU_API void ceu_start (void) {
    CEU_APP.seq      = 0;
    CEU_APP.seq_base = 0;

    CEU_APP.wclk_late = 0;
    CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;
    CEU_APP.wclk_min_cmp = CEU_WCLOCK_INACTIVE;

#ifdef CEU_FEATURES_THREAD
    pthread_mutex_init(&CEU_APP.threads_mutex, NULL);
    CEU_APP.threads_head = NULL;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
#endif

    tceu_stk stk = { 1, NULL,
                     { (tceu_code_mem*)&CEU_APP.root,
                       0, (tceu_ntrl)(CEU_APP.root.mem.trails_n-1) } };
    ceu_lbl(NULL, &stk, (tceu_code_mem*)&CEU_APP.root, 0, CEU_LABEL_ROOT);
}

CEU_API void ceu_stop (void) {
#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
    ceu_dbg_assert(ceu_threads_gc(1) == 0); /* wait all terminate/free */
#endif
}

/*****************************************************************************/

static int ceu_cb_terminating     = 0;
static int ceu_cb_terminating_ret = 0;
static int ceu_cb_pending_async   = 0;

static tceu_callback_ret ceu_callback_go_all (int cmd, tceu_callback_arg p1, tceu_callback_arg p2) {
    tceu_callback_ret ret = { .is_handled=1 };
    switch (cmd) {
        case CEU_CALLBACK_TERMINATING:
            ceu_cb_terminating = 1;
            ceu_cb_terminating_ret = p1.num;
            break;
        case CEU_CALLBACK_ASYNC_PENDING:
            ceu_cb_pending_async = 1;
            break;
        default:
            ret.is_handled = 0;
    }
    return ret;
}

CEU_API int ceu_loop (void)
{
    ceu_callback_void_void(CEU_CALLBACK_START);
    ceu_start();

    while (!ceu_cb_terminating) {
        ceu_callback_void_void(CEU_CALLBACK_STEP);
#ifdef CEU_FEATURES_THREAD
        if (CEU_APP.threads_head != NULL) {
            CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
/* TODO: remove this!!! */
            CEU_THREADS_SLEEP(100); /* allow threads to do "atomic" and "terminate" */
            CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
            ceu_threads_gc(0);
        }
#endif
        if (ceu_cb_pending_async) {
            ceu_cb_pending_async = 0;
            ceu_input(CEU_INPUT__ASYNC, NULL);
        }
    }

    ceu_stop();
    ceu_callback_void_void(CEU_CALLBACK_STOP);

#ifdef CEU_TESTS
    printf("_ceu_tests_trails_visited_ = %d\n", _ceu_tests_trails_visited_);
#endif

    return ceu_cb_terminating_ret;
}
]====],
    }
}
optparse = 
(function()
--[[--
 Parse and process command line options.

 In the common case, you can write the long-form help output typical of
 a modern-command line program, and let this module generate a custom
 parser that collects and diagnoses the options it describes.

 The parser is an object instance which can then be tweaked for
 the uncommon case, by hand, or by using the @{on} method to tie your
 custom handlers to options that are not handled quite the way you'd
 like.

 @module optparse
]]


local _ENV		= _ENV
local assert		= assert
local error		= error
local getmetatable	= getmetatable
local ipairs		= ipairs
local pairs		= pairs
local print		= print
local require		= require
local setmetatable	= setmetatable
local tostring		= tostring
local type		= type

local io_open		= io.open
local io_stderr		= io.stderr
local os_exit		= os.exit
local string_len	= string.len
local table_insert	= table.insert



--[[ ================== ]]--
--[[ Initialize _DEBUG. ]]--
--[[ ================== ]]--


local _DEBUG		= _DEBUG
do
  -- Make sure none of these symbols leak out into the rest of the
  -- module, in case we can enable 'strict' mode at the end of the block.

  local ok, debug_init	= pcall (require, "std.debug_init")
  if ok then
    _DEBUG		= debug_init._DEBUG
  else
    local function choose (t)
      for k, v in pairs (t) do
        if _DEBUG == false then
          t[k] = v.fast
	elseif _DEBUG == nil then
          t[k] = v.default
        elseif type (_DEBUG) ~= "table" then
          t[k] = v.safe
        elseif _DEBUG[k] ~= nil then
          t[k] = _DEBUG[k]
        else
          t[k] = v.default
        end
      end
      return t
    end

    _DEBUG = choose {
      strict    = {default = true,  safe = true,  fast = false},
    }
  end

  -- Unless strict was disabled (`_DEBUG = false`), or that module is not
  -- available, check for use of undeclared variables in this module.
  if _DEBUG.strict then
    local ok, strict	= pcall (require, "std.strict")
    if ok then
      _ENV = strict {}
    else
      _DEBUG.strict = false
    end
  end
end



--[[ ================= ]]--
--[[ Helper Functions. ]]--
--[[ ================= ]]--


local function getmetamethod (x, n)
  local m = (getmetatable (x) or {})[n]
  if type (m) == "function" then return m end
  return (getmetatable (m) or {}).__call
end


local function len (x)
  local m = getmetamethod (x, "__len")
  if m then return m (x) end
  if type (x) ~= "table" then return #x end

  local n = #x
  for i = 1, n do
    if x[i] == nil then return i -1 end
  end
  return n
end


local function last (t)
  return t[len (t)]
end


local optional, required


--- Normalise an argument list.
-- Separate short options, remove `=` separators from
-- `--long-option=optarg` etc.
-- @local
-- @function normalise
-- @tparam table arglist list of arguments to normalise
-- @treturn table normalised argument list
local function normalise (self, arglist)
  local normal = {}
  local i = 0
  while i < len (arglist) do
    i = i + 1
    local opt = arglist[i]

    -- Split '--long-option=option-argument'.
    if opt:sub (1, 2) == "--" then
      local x = opt:find ("=", 3, true)
      if x then
        local optname = opt:sub (1, x -1)

	-- Only split recognised long options.
	if self[optname] then
          table_insert (normal, optname)
          table_insert (normal, opt:sub (x + 1))
	else
	  x = nil
	end
      end

      if x == nil then
	-- No '=', or substring before '=' is not a known option name.
        table_insert (normal, opt)
      end

    elseif opt:sub (1, 1) == "-" and string_len (opt) > 2 then
      local orig, split, rest = opt, {}
      repeat
        opt, rest = opt:sub (1, 2), opt:sub (3)

        split[#split + 1] = opt

	-- If there's no handler, the option was a typo, or not supposed
	-- to be an option at all.
	if self[opt] == nil then
	  opt, split = nil, { orig }

        -- Split '-xyz' into '-x -yz', and reiterate for '-yz'
        elseif self[opt].handler ~= optional and
          self[opt].handler ~= required then
	  if string_len (rest) > 0 then
            opt = "-" .. rest
	  else
	    opt = nil
	  end

        -- Split '-xshortargument' into '-x shortargument'.
        else
          split[#split + 1] = rest
          opt = nil
        end
      until opt == nil

      -- Append split options to normalised list
      for _, v in ipairs (split) do table_insert (normal, v) end
    else
      table_insert (normal, opt)
    end
  end

  normal[-1], normal[0]  = arglist[-1], arglist[0]
  return normal
end


--- Store `value` with `opt`.
-- @local
-- @function set
-- @string opt option name
-- @param value option argument value
local function set (self, opt, value)
  local key = self[opt].key
  local opts = self.opts[key]

  if type (opts) == "table" then
    table_insert (opts, value)
  elseif opts ~= nil then
    self.opts[key] = { opts, value }
  else
    self.opts[key] = value
  end
end



--[[ ============= ]]--
--[[ Option Types. ]]--
--[[ ============= ]]--


--- Option at `arglist[i]` can take an argument.
-- Argument is accepted only if there is a following entry that does not
-- begin with a '-'.
--
-- This is the handler automatically assigned to options that have
-- `--opt=[ARG]` style specifications in the @{OptionParser} spec
-- argument.  You can also pass it as the `handler` argument to @{on} for
-- options you want to add manually without putting them in the
-- @{OptionParser} spec.
--
-- Like @{required}, this handler will store multiple occurrences of a
-- command-line option.
-- @static
-- @tparam table arglist list of arguments
-- @int i index of last processed element of *arglist*
-- @param[opt=true] value either a function to process the option
--   argument, or a default value if encountered without an optarg
-- @treturn int index of next element of *arglist* to process
-- @usage
-- parser:on ("--enable-nls", parser.option, parser.boolean)
function optional (self, arglist, i, value)
  if i + 1 <= len (arglist) and arglist[i + 1]:sub (1, 1) ~= "-" then
    return self:required (arglist, i, value)
  end

  if type (value) == "function" then
    value = value (self, arglist[i], nil)
  elseif value == nil then
    value = true
  end

  set (self, arglist[i], value)
  return i + 1
end


--- Option at `arglist[i]` requires an argument.
--
-- This is the handler automatically assigned to options that have
-- `--opt=ARG` style specifications in the @{OptionParser} spec argument.
-- You can also pass it as the `handler` argument to @{on} for options
-- you want to add manually without putting them in the @{OptionParser}
-- spec.
--
-- Normally the value stored in the `opt` table by this handler will be
-- the string given as the argument to that option on the command line.
-- However, if the option is given on the command-line multiple times,
-- `opt["name"]` will end up with all those arguments stored in the
-- array part of a table:
--
--     $ cat ./prog
--     ...
--     parser:on ({"-e", "-exec"}, required)
--     _G.arg, _G.opt = parser:parse (_G.arg)
--     print (tostring (_G.opt.exec))
--     ...
--     $ ./prog -e '(foo bar)' -e '(foo baz)' -- qux
--     {1=(foo bar),2=(foo baz)}
-- @static
-- @tparam table arglist list of arguments
-- @int i index of last processed element of *arglist*
-- @param[opt] value either a function to process the option argument,
--   or a forced value to replace the user's option argument.
-- @treturn int index of next element of *arglist* to process
-- @usage
-- parser:on ({"-o", "--output"}, parser.required)
function required (self, arglist, i, value)
  local opt = arglist[i]
  if i + 1 > len (arglist) then
    self:opterr ("option '" .. opt .. "' requires an argument")
    return i + 1
  end

  if type (value) == "function" then
    value = value (self, opt, arglist[i + 1])
  elseif value == nil then
    value = arglist[i + 1]
  end

  set (self, opt, value)
  return i + 2
end


--- Finish option processing
--
-- This is the handler automatically assigned to the option written as
-- `--` in the @{OptionParser} spec argument.  You can also pass it as
-- the `handler` argument to @{on} if you want to manually add an end
-- of options marker without writing it in the @{OptionParser} spec.
--
-- This handler tells the parser to stop processing arguments, so that
-- anything after it will be an argument even if it otherwise looks
-- like an option.
-- @static
-- @tparam table arglist list of arguments
-- @int i index of last processed element of `arglist`
-- @treturn int index of next element of `arglist` to process
-- @usage
-- parser:on ("--", parser.finished)
local function finished (self, arglist, i)
  for opt = i + 1, len (arglist) do
    table_insert (self.unrecognised, arglist[opt])
  end
  return 1 + len (arglist)
end


--- Option at `arglist[i]` is a boolean switch.
--
-- This is the handler automatically assigned to options that have
-- `--long-opt` or `-x` style specifications in the @{OptionParser} spec
-- argument. You can also pass it as the `handler` argument to @{on} for
-- options you want to add manually without putting them in the
-- @{OptionParser} spec.
--
-- Beware that, _unlike_ @{required}, this handler will store multiple
-- occurrences of a command-line option as a table **only** when given a
-- `value` function.  Automatically assigned handlers do not do this, so
-- the option will simply be `true` if the option was given one or more
-- times on the command-line.
-- @static
-- @tparam table arglist list of arguments
-- @int i index of last processed element of *arglist*
-- @param[opt] value either a function to process the option argument,
--   or a value to store when this flag is encountered
-- @treturn int index of next element of *arglist* to process
-- @usage
-- parser:on ({"--long-opt", "-x"}, parser.flag)
local function flag (self, arglist, i, value)
  local opt = arglist[i]
  if type (value) == "function" then
    set (self, opt, value (self, opt, true))
  elseif value == nil then
    local key = self[opt].key
    self.opts[key] = true
  end

  return i + 1
end


--- Option should display help text, then exit.
--
-- This is the handler automatically assigned tooptions that have
-- `--help` in the specification, e.g. `-h, -?, --help`.
-- @static
-- @function help
-- @usage
-- parser:on ("-?", parser.version)
local function help (self)
  print (self.helptext)
  os_exit (0)
end


--- Option should display version text, then exit.
--
-- This is the handler automatically assigned tooptions that have
-- `--version` in the specification, e.g. `-V, --version`.
-- @static
-- @function version
-- @usage
-- parser:on ("-V", parser.version)
local function version (self)
  print (self.versiontext)
  os_exit (0)
end



--[[ =============== ]]--
--[[ Argument Types. ]]--
--[[ =============== ]]--


--- Map various option strings to equivalent Lua boolean values.
-- @table boolvals
-- @field false false
-- @field 0 false
-- @field no false
-- @field n false
-- @field true true
-- @field 1 true
-- @field yes true
-- @field y true
local boolvals = {
  ["false"] = false, ["true"]  = true,
  ["0"]     = false, ["1"]     = true,
  no        = false, yes       = true,
  n         = false, y         = true,
}


--- Return a Lua boolean equivalent of various *optarg* strings.
-- Report an option parse error if *optarg* is not recognised.
--
-- Pass this as the `value` function to @{on} when you want various
-- "truthy" or "falsey" option arguments to be coerced to a Lua `true`
-- or `false` respectively in the options table.
-- @static
-- @string opt option name
-- @string[opt="1"] optarg option argument, must be a key in @{boolvals}
-- @treturn bool `true` or `false`
-- @usage
-- parser:on ("--enable-nls", parser.optional, parser.boolean)
local function boolean (self, opt, optarg)
  if optarg == nil then optarg = "1" end -- default to truthy
  local b = boolvals[tostring (optarg):lower ()]
  if b == nil then
    return self:opterr (optarg .. ": Not a valid argument to " ..opt[1] .. ".")
  end
  return b
end


--- Report an option parse error unless *optarg* names an
-- existing file.
--
-- Pass this as the `value` function to @{on} when you want to accept
-- only option arguments that name an existing file.
-- @fixme this only checks whether the file has read permissions
-- @static
-- @string opt option name
-- @string optarg option argument, must be an existing file
-- @treturn string *optarg*
-- @usage
-- parser:on ("--config-file", parser.required, parser.file)
local function file (self, opt, optarg)
  local h, errmsg = io_open (optarg, "r")
  if h == nil then
    return self:opterr (optarg .. ": " .. errmsg)
  end
  h:close ()
  return optarg
end



--[[ =============== ]]--
--[[ Option Parsing. ]]--
--[[ =============== ]]--


--- Report an option parse error, then exit with status 2.
--
-- Use this in your custom option handlers for consistency with the
-- error output from built-in @{optparse} error messages.
-- @static
-- @string msg error message
local function opterr (self, msg)
  local prog = self.program
  -- Ensure final period.
  if msg:match ("%.$") == nil then msg = msg .. "." end
  io_stderr:write (prog .. ": error: " .. msg .. "\n")
  io_stderr:write (prog .. ": Try '" .. prog .. " --help' for help.\n")
  os_exit (2)
end


------
-- Function signature of an option handler for @{on}.
-- @function on_handler
-- @tparam table arglist list of arguments
-- @int i index of last processed element of *arglist*
-- @param[opt=nil] value additional `value` registered with @{on}
-- @treturn int index of next element of *arglist* to process


--- Add an option handler.
--
-- When the automatically assigned option handlers don't do everything
-- you require, or when you don't want to put an option into the
-- @{OptionParser} `spec` argument, use this function to specify custom
-- behaviour.  If you write the option into the `spec` argument anyway,
-- calling this function will replace the automatically assigned handler
-- with your own.
--
-- When writing your own handlers for @{optparse:on}, you only need
-- to deal with normalised arguments, because combined short arguments
-- (`-xyz`), equals separators to long options (`--long=ARG`) are fully
-- expanded before any handler is called.
-- @function on
-- @tparam[string|table] opts name of the option, or list of option names
-- @tparam on_handler handler function to call when any of *opts* is
--   encountered
-- @param value additional value passed to @{on_handler}
-- @usage
-- -- Don't process any arguments after `--`
-- parser:on ('--', parser.finished)
local function on (self, opts, handler, value)
  if type (opts) == "string" then opts = { opts } end
  handler = handler or flag -- unspecified options behave as flags

  local normal = {}
  for _, optspec in ipairs (opts) do
    optspec:gsub ("(%S+)",
                  function (opt)
                    -- 'x' => '-x'
                    if string_len (opt) == 1 then
                      opt = "-" .. opt

                    -- 'option-name' => '--option-name'
                    elseif opt:match ("^[^%-]") ~= nil then
                      opt = "--" .. opt
                    end

                    if opt:match ("^%-[^%-]+") ~= nil then
                      -- '-xyz' => '-x -y -z'
                      for i = 2, string_len (opt) do
                        table_insert (normal, "-" .. opt:sub (i, i))
                      end
                    else
                      table_insert (normal, opt)
                    end
                  end)
  end

  -- strip leading '-', and convert non-alphanums to '_'
  local key = last (normal):match ("^%-*(.*)$"):gsub ("%W", "_")

  for _, opt in ipairs (normal) do
    self[opt] = { key = key, handler = handler, value = value }
  end
end


------
-- Parsed options table, with a key for each encountered option, each
-- with value set by that option's @{on_handler}.  Where an option
-- has one or more long-options specified, the key will be the first
-- one of those with leading hyphens stripped and non-alphanumeric
-- characters replaced with underscores.  For options that can only be
-- specified by a short option, the key will be the letter of the first
-- of the specified short options:
--
--     {"-e", "--eval-file"} => opts.eval_file
--     {"-n", "--dryrun", "--dry-run"} => opts.dryrun
--     {"-t", "-T"} => opts.t
--
-- Generally there will be one key for each previously specified
-- option (either automatically assigned by @{OptionParser} or
-- added manually with @{on}) containing the value(s) assigned by the
-- associated @{on_handler}.  For automatically assigned handlers,
-- that means `true` for straight-forward flags and
-- optional-argument options for which no argument was given; or else
-- the string value of the argument passed with an option given only
-- once; or a table of string values of the same for arguments given
-- multiple times.
--
--     ./prog -x -n -x => opts = { x = true, dryrun = true }
--     ./prog -e '(foo bar)' -e '(foo baz)'
--         => opts = {eval_file = {"(foo bar)", "(foo baz)"} }
--
-- If you write your own handlers, or otherwise specify custom
-- handling of options with @{on}, then whatever value those handlers
-- return will be assigned to the respective keys in `opts`.
-- @table opts


--- Parse an argument list.
-- @tparam table arglist list of arguments
-- @tparam[opt] table defaults table of default option values
-- @treturn table a list of unrecognised *arglist* elements
-- @treturn opts parsing results
local function parse (self, arglist, defaults)
  self.unrecognised, self.opts = {}, {}

  arglist = normalise (self, arglist)

  local i = 1
  while i > 0 and i <= len (arglist) do
    local opt = arglist[i]

    if self[opt] == nil then
      table_insert (self.unrecognised, opt)
      i = i + 1

      -- Following non-'-' prefixed argument is an optarg.
      if i <= len (arglist) and arglist[i]:match "^[^%-]" then
        table_insert (self.unrecognised, arglist[i])
        i = i + 1
      end

    -- Run option handler functions.
    else
      assert (type (self[opt].handler) == "function")

      i = self[opt].handler (self, arglist, i, self[opt].value)
    end
  end

  -- Merge defaults into user options.
  for k, v in pairs (defaults or {}) do
    if self.opts[k] == nil then self.opts[k] = v end
  end

  -- metatable allows `io.warn` to find `parser.program` when assigned
  -- back to _G.opts.
  return self.unrecognised, setmetatable (self.opts, {__index = self})
end


--- Take care not to register duplicate handlers.
-- @param current current handler value
-- @param new new handler value
-- @return `new` if `current` is nil
local function set_handler (current, new)
  assert (current == nil, "only one handler per option")
  return new
end


local function _init (self, spec)
  local parser = {}

  parser.versiontext, parser.version, parser.helptext, parser.program =
    spec:match ("^([^\n]-(%S+)\n.-)%s*([Uu]sage: (%S+).-)%s*$")

  if parser.versiontext == nil then
    error ("OptionParser spec argument must match '<version>\\n" ..
           "...Usage: <program>...'")
  end

  -- Collect helptext lines that begin with two or more spaces followed
  -- by a '-'.
  local specs = {}
  parser.helptext:gsub ("\n  %s*(%-[^\n]+)",
                        function (spec) table_insert (specs, spec) end)

  -- Register option handlers according to the help text.
  for _, spec in ipairs (specs) do
    local options, handler = {}

    -- Loop around each '-' prefixed option on this line.
    while spec:sub (1, 1) == "-" do

      -- Capture end of options processing marker.
      if spec:match "^%-%-,?%s" then
        handler = set_handler (handler, finished)

      -- Capture optional argument in the option string.
      elseif spec:match "^%-[%-%w]+=%[.+%],?%s" then
        handler = set_handler (handler, optional)

      -- Capture required argument in the option string.
      elseif spec:match "^%-[%-%w]+=%S+,?%s" then
        handler = set_handler (handler, required)

      -- Capture any specially handled arguments.
      elseif spec:match "^%-%-help,?%s" then
        handler = set_handler (handler, help)

      elseif spec:match "^%-%-version,?%s" then
        handler = set_handler (handler, version)
      end

      -- Consume argument spec, now that it was processed above.
      spec = spec:gsub ("^(%-[%-%w]+)=%S+%s", "%1 ")

      -- Consume short option.
      local _, c = spec:gsub ("^%-([-%w]),?%s+(.*)$",
                              function (opt, rest)
                                if opt == "-" then opt = "--" end
                                table_insert (options, opt)
                                spec = rest
                              end)

      -- Be careful not to consume more than one option per iteration,
      -- otherwise we might miss a handler test at the next loop.
      if c == 0 then
        -- Consume long option.
        spec:gsub ("^%-%-([%-%w]+),?%s+(.*)$",
                   function (opt, rest)
                     table_insert (options, opt)
                     spec = rest
                   end)
      end
    end

    -- Unless specified otherwise, treat each option as a flag.
    on (parser, options, handler or flag)
  end

  return setmetatable (parser, getmetatable (self))
end


--- Signature for initialising a custom OptionParser.
--
-- Read the documented options from *spec* and return custom parser that
-- can be used for parsing the options described in *spec* from a run-time
-- argument list.  Options in *spec* are recognised as lines that begin
-- with at least two spaces, followed by a hyphen.
-- @static
-- @function OptionParser_Init
-- @string spec option parsing specification
-- @treturn OptionParser a parser for options described by *spec*
-- @usage
-- customparser = optparse (optparse_spec)


return setmetatable ({
  --- Module table.
  -- @table optparse
  -- @string version release version identifier


  --- OptionParser prototype object.
  --
  -- Most often, after instantiating an @{OptionParser}, everything else
  -- is handled automatically.
  --
  -- Then, calling `parser:parse` as shown below saves unparsed arguments
  -- into `_G.arg` (usually filenames or similar), and `_G.opts` will be a
  -- table of successfully parsed option values. The keys into this table
  -- are the long-options with leading hyphens stripped, and non-word
  -- characters turned to `_`.  For example if `--another-long` had been
  -- found in the initial `_G.arg`, then `_G.opts` will have a key named
  -- `another_long`, with an appropriate value.  If there is no long
  -- option name, then the short option is used, i.e. `_G.opts.b` will be
  -- set.
  --
  -- The values saved against those keys are controlled by the option
  -- handler, usually just `true` or the option argument string as
  -- appropriate.
  -- @object OptionParser
  -- @tparam OptionParser_Init _init initialisation function
  -- @string program the first word following "Usage:" from *spec*
  -- @string version the last white-space delimited word on the first line
  --   of text from *spec*
  -- @string versiontext everything preceding "Usage:" from *spec*, and
  --   which will be displayed by the @{version} @{on_handler}
  -- @string helptext everything including and following "Usage:" from
  --   *spec* string and which will be displayed by the @{help}
  --   @{on_handler}
  -- @usage
  -- local optparse = require "optparse"
  --
  -- local optparser = optparse [[
  -- any text VERSION
  -- Additional lines of text to show when the --version
  -- option is passed.
  --
  -- Several lines or paragraphs are permitted.
  --
  -- Usage: PROGNAME
  --
  -- Banner text.
  --
  -- Optional long description text to show when the --help
  -- option is passed.
  --
  -- Several lines or paragraphs of long description are permitted.
  --
  -- Options:
  --
  --   -b                       a short option with no long option
  --       --long               a long option with no short option
  --       --another-long       a long option with internal hypen
  --   -v, --verbose            a combined short and long option
  --   -n, --dryrun, --dry-run  several spellings of the same option
  --   -u, --name=USER          require an argument
  --   -o, --output=[FILE]      accept an optional argument
  --       --version            display version information, then exit
  --       --help               display this help, then exit
  --
  -- Footer text.  Several lines or paragraphs are permitted.
  --
  -- Please report bugs at bug-list@yourhost.com
  -- ]]
  --
  -- -- Note that `std.io.die` and `std.io.warn` will only prefix messages
  -- -- with `parser.program` if the parser options are assigned back to
  -- -- `_G.opts`:
  -- _G.arg, _G.opts = optparser:parse (_G.arg)
  prototype = setmetatable ({
    -- Prototype initial values.
    opts        = {},
    helptext    = "",
    program     = "",
    versiontext = "",
    version     = 0,
  }, {
    _type = "OptionParser",

    __call = _init,

    --- @export
    __index = {
      boolean  = boolean,
      file     = file,
      finished = finished,
      flag     = flag,
      help     = help,
      optional = optional,
      required = required,
      version  = version,

      on     = on,
      opterr = opterr,
      parse  = parse,
    },
  }),
}, {
  --- Metamethods
  -- @section Metamethods

  _type = "Module",


  -- Pass through options to the OptionParser prototype.
  __call = function (self, ...) return self.prototype (...) end,
  

  --- Lazy loading of optparse submodules.
  -- Don't load everything on initial startup, wait until first attempt
  -- to access a submodule, and then load it on demand.
  -- @function __index
  -- @string name submodule name
  -- @treturn table|nil the submodule that was loaded to satisfy the missing
  --   `name`, otherwise `nil` if nothing was found
  -- @usage
  -- local optparse = require "optparse"
  -- local version = optparse.version
  __index = function (self, name)
    local ok, t = pcall (require, "optparse." .. name)
    if ok then
      rawset (self, name, t)
      return t
    end
  end,
})

end)()



do
-- Lua 5.3
unpack     = unpack     or table.unpack
loadstring = loadstring or load

-------------------------------------------------------------------------------

function DBG1 (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function ASR1 (cond, msg)
    if cond then
        return cond
    end
    if TESTS then
        return assert(false, msg)
                -- TODO: error(msg) ???
    else
        DBG('>>> ERROR : '..msg)
        os.exit(1)
    end
end

-------------------------------------------------------------------------------

function DBG2 (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function WRN (cond, ln, code, msg)
    if cond then
        return cond
    end

    if not tonumber(code) then
        code, msg, extra = '0000', code, msg
    end
    ln = (AST.is_node(ln) and ln.ln) or ln
    msg = 'WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg

    if TESTS_file and tonumber(code)>1100 then
        TESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[

==============
]])
    end

    DBG2('WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg)
    return cond
end
function ASR2 (cond, ln, code, msg, extra)
    if cond then
        return cond
    end

    if not tonumber(code) then
        code, msg, extra = '0000', code, msg
    end
    ln = (AST.is_node(ln) and ln.ln) or ln
    msg = 'ERR ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg
    if extra and OPTS.verbose then
        msg = msg..'\n'..extra
    end

    if TESTS_file and tonumber(code)>1100 then
        TESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[
==============
]])
    end

    if TESTS then
        return assert(false, msg)
                -- TODO: error(msg) ???
    else
        DBG2(msg)
        os.exit(1)
    end
end

local pass = function () end
function ASR_WRN_PASS (v)
    if v == 'error' then
        return ASR
    elseif v == 'warning' then
        return WRN
    else
        assert(v == 'pass')
        return pass
    end
end

end

DBG,ASR = DBG1,ASR1

do
PAK = PAK or {
    ceu_ver = '?',
    ceu_git = '?',
}

if not TESTS then
    CEU = {}

    local help = [[
ceu ]]..PAK.ceu_ver..' ('..PAK.ceu_git..[[)

Usage: ceu [<options>] <file>...

Options:

    --help                      display this help, then exit
    --version                   display version information, then exit

    --pre                       Preprocessor phase: preprocess Céu into Céu
    --pre-exe=FILE                  preprocessor executable
    --pre-args=ARGS                 preprocessor arguments
    --pre-input=FILE                input file to compile (Céu source)
    --pre-output=FILE               output file to generate (Céu source)

    --ceu                       Céu phase: compiles Céu into C
    --ceu-input=FILE                input file to compile (Céu source)
    --ceu-output=FILE               output source file to generate (C source)
    --ceu-line-directives=BOOL      insert `#line´ directives in the C output

    --ceu-features-lua=BOOL         enable `lua´ support
    --ceu-features-thread=BOOL      enable `async/thread´ support

    --ceu-err-unused=OPT            effect for unused identifier: error|warning|pass
    --ceu-err-unused-native=OPT                unused native identifier
    --ceu-err-unused-code=OPT                  unused code identifier
    --ceu-err-uninitialized=OPT     effect for uninitialized variable: error|warning|pass

    --env                       Environment phase: packs all C files together
    --env-types=FILE                header file with type declarations (C source)
    --env-threads=FILE              header file with thread declarations (C source)
    --env-ceu=FILE                  output file from Céu phase (C source)
    --env-main=FILE                 source file with main function (C source)
    --env-output=FILE               output file to generate (C source)

    --cc                        C phase: compiles C into binary
    --cc-exe=FILE                   C compiler executable
    --cc-args=ARGS                  compiler arguments
    --cc-input=FILE                 input file to compile (C source)
    --cc-output=FILE                output file to generate (binary)

http://www.ceu-lang.org/

Please report bugs at <http://github.com/fsantanna/ceu/issues>.
]]

--[[
  -b                       a short option with no long option
      --long               a long option with no short option
      --another-long       a long option with internal hypen
      --true               a Lua keyword as an option name
  -v, --verbose            a combined short and long option
  -n, --dryrun, --dry-run  several spellings of the same option
  -u, --name=USER          require an argument
  -o, --output=[FILE]      accept an optional argument
  --                       end of options
]]

    local parser = optparse(help)
    local arg, opts = parser:parse(_G.arg)
--[[
    print'------'
    for k,v in pairs(arg) do
        print(k,v)
    end
    print'------'
    for k,v in pairs(opts) do
        print(k,v)
    end
    print'------'
]]

    CEU.help = help
    CEU.arg  = arg
    CEU.opts = opts
end

for i,v in pairs(CEU.arg) do
    DBG(CEU.help)
    ASR(false, 'invalid option "'..v..'"')
end

local function check_no (pre)
    for k,v in pairs(CEU.opts) do
        local kk = string.gsub(k,'_','-')
        ASR(not string.find(k, '^'..pre..'_'),
            'invalid option "'..kk..'" : '..
            'expected option "'..pre..'"')
    end
end

if not (CEU.opts.pre or CEU.opts.ceu or CEU.opts.env or CEU.opts.cc) then
    DBG(CEU.help)
    ASR(false, 'expected some option')
end

if CEU.opts.pre then
    CEU.opts.pre_exe  = CEU.opts.pre_exe  or 'cpp'
    CEU.opts.pre_args = CEU.opts.pre_args or ''
    ASR(CEU.opts.pre_input, 'expected option `pre-input´')
    CEU.opts.pre_output = CEU.opts.pre_output or '-'
else
    check_no('pre')
end

do
    local function toboolean (v)
        if v == 'true' then
            return true
        elseif v == 'false' then
            return false
        end
        return nil
    end

    local T = {
        ceu_output          = { tostring,  '-'     },
        ceu_line_directives = { toboolean, 'true'  },
        ceu_features_lua    = { toboolean, 'false' },
        ceu_features_thread = { toboolean, 'false' },

        env_output          = { tostring,  '-'     },
    }

    for k, t in pairs(T) do
        local tp, v = unpack(t)
        local pre = string.match(k, '^(.-)_')
        if CEU.opts[pre] then
            v = tp(CEU.opts[k] or v)
            ASR(v ~= nil, 'invalid value for option "'..k..'"')
            CEU.opts[k] = v
        end
    end
end

if CEU.opts.ceu then
    if CEU.opts.pre then
        if CEU.opts.ceu_input then
            ASR(CEU.opts.ceu_input == CEU.opts.pre_output,
                "`pre-output´ and `ceu-input´ don't match")
        else
            if CEU.opts.pre_output == '-' then
                CEU.opts.pre_output = os.tmpname()
            end
            CEU.opts.ceu_input = CEU.opts.pre_output
        end
    end
    ASR(CEU.opts.ceu_input, 'expected option `ceu-input´')
else
    check_no('ceu')
end

if CEU.opts.env then
    if not CEU.opts.ceu then
        ASR(not CEU.opts.pre, 'expected option `ceu´')
    end

    ASR(CEU.opts.env_types,   'expected option `env-types´')
    --ASR(CEU.opts.env_threads, 'expected option `env-threads´')
    --ASR(CEU.opts.env_main,    'expected option `env-main´')

    if CEU.opts.ceu then
        if CEU.opts.env_ceu then
            ASR(CEU.opts.env_ceu == CEU.opts.ceu_output,
                "`ceu-output´ and `env-ceu´ don't match")
        else
            if CEU.opts.ceu_output == '-' then
                CEU.opts.ceu_output = os.tmpname()
            end
            CEU.opts.env_ceu = CEU.opts.ceu_output
        end
    end
    ASR(CEU.opts.env_ceu, 'expected option `env-ceu´')
else
    check_no('env')
end

if CEU.opts.cc then
    if not CEU.opts.env then
        ASR(not CEU.opts.pre, 'expected option `env´')
        ASR(not CEU.opts.ceu, 'expected option `env´')
    end

    CEU.opts.cc_exe  = CEU.opts.cc_exe  or 'gcc'
    CEU.opts.cc_args = CEU.opts.cc_args or ''

    if CEU.opts.env then
        if CEU.opts.cc_input then
            ASR(CEU.opts.cc_input == CEU.opts.env_output,
                "`env-output´ and `cc-input´ don't match")
        else
            if CEU.opts.env_output == '-' then
                CEU.opts.env_output = os.tmpname()
            end
            CEU.opts.cc_input = CEU.opts.env_output
        end
    end
    ASR(CEU.opts.cc_input, 'expected option `cc-input´')

    ASR(CEU.opts.cc_output, 'expected option `cc-output´')
else
    check_no('cc')
end

end

if CEU.opts.pre then
    
do
-- "-C":  keep comments (because of nesting)
-- "-dD": repeat #define's (because of macros used as C functions)
local f = io.popen(CEU.opts.pre_exe..' -C -dD '..CEU.opts.pre_args..
            ' '..CEU.opts.pre_input..' -o '..CEU.opts.pre_output..' 2>&1')
local out = f:read'*a'
ASR(f:close(), out)

if CEU.opts.pre_output == '-' then
    print(out)
end

end

end
if CEU.opts.ceu then
    
do
m = require 'lpeg'
m.setmaxstack(1000)

local LINE = 1
local FILE = CEU.opts.pre_input or CEU.opts.ceu_input
local patt

CEU.i2l = {}

local line = m.Cmt('\n',
    function (s,i)
        for i=#CEU.i2l, i do
            CEU.i2l[i] = { FILE, LINE }
        end
        LINE = LINE + 1
        return true
    end )

local S = (m.S'\t\r ' + m.P'\\'*(1-m.P'\n')^0*'\n')
local SS = S^0

-- #line N "file" :: directive to set line/filename
local dir_lins = m.Cmt( m.P'#' *SS* m.P'line'^-1
                          *SS* m.C(m.R'09'^1)             -- line
                          *SS* ( m.P'"' * m.C((1-m.P'"')^0) * m.P'"'
                              + m.Cc(false) )            -- file
                          * (S + (m.P(1)-'\n'))^0 * '\n' -- \n
                 ,
    function (s,i, line, file)
        LINE = tonumber(line)
        FILE = file
        return true
    end )

patt = (line + dir_lins + 1)^0

local f = ASR(io.open(CEU.opts.ceu_input))
CEU.source = '\n#line 1 "'..FILE..'"'..'\n'..f:read'*a'..'\n'
f:close()
patt:match(CEU.source)

end

    
do
local P, C, V, S, Cc, Ct, Cg = m.P, m.C, m.V, m.S, m.Cc, m.Ct, m.Cg

--local __debug = true
local spc = 0
if __debug then
    local VV = V
    V = function (id)
        return
            m.Cmt(P'',
                function ()
                    DBG(string.rep(' ',spc)..'>>>', id)
                    spc = spc + 2
                    return true
                end)
            * (
                VV(id) * m.Cmt(P'',
                            function ()
                                spc = spc - 2
                                DBG(string.rep(' ',spc)..'+++', id)
                                return true
                            end)
              + m.Cmt(P'',
                    function ()
                        spc = spc - 2
                        DBG(string.rep(' ',spc)..'---', id)
                        return false
                    end) * P(false)
            )
    end
end

local x = V'__SPACE'^0
local X = V'__SPACE'^1

local T = {
    {
        '`%*´ or `/´ or `%%´ or `%+´ or `%-´ or `>>´ or `<<´ or `&´ or `^´ or `|´ or `!=´ or `==´ or `<=´ or `>=´ or `<´ or `>´ or `and´ or `or´',
        'binary operator'
    },
    {
        '`%*´ or `/´ or `%%´ or `%+´ or `%-´ or `>>´ or `<<´ or `^´ or `|´ or `!=´ or `==´ or `<=´ or `>=´ or `<´ or `>´ or `and´ or `or´',
        'binary operator'
    },

    {
        '`&&´ or `%?´',
        'type modifier'
    },

    {
        '`&%?´ or `&´ or `%(´ or primitive type or abstraction identifier or native identifier',
        'type'
    },
    {
        'primitive type or abstraction identifier or native identifier',
        'type'
    },

    {
        '`native´ or `code´ or end of file',
        'end of file'
    },
    {
        '`;´ or `native´ or `code´ or `with´',
        '`with´'
    },
    {
        '`native´ or `code´ or `end´',
        '`end´'
    },

    {
        '`dynamic´ or `vector´ or `pool´ or `event´ or `var´',
        '`vector´ or `pool´ or `event´ or `var´',
    },
    {
        ' or `/dynamic´ or `/static´ or `/recursive´',
        '',
    },

    {
        '`%(´ or internal identifier or native identifier or `outer´ or `{´',
        'name expression'
    },
    {
        '`%*´ or `%$´ or name expression',
        'name expression'
    },
    {
        '`%*´ or `%$´ or internal identifier or native identifier or `outer´',
        'name expression'
    },
    {
        'abstraction identifier or name expression',
        'name expression'
    },
    {
        '`/dynamic´ or `/static´ or `/recursive´ or abstraction identifier',
        'abstraction identifier'
    },

    {
        '`do´ or `await´ or `%[´ or `call/recursive´ or `call´ or name expression or `&&´ or `&´ or `sizeof´ or `null´ or number or `false´ or `true´ or `"´ or string literal or `not´ or `%-´ or `%+´ or `~´ or `%$%$´ or `emit´ or `val´ or `new´ or `spawn´ or `_´ or `request´ or `watching´',
        'expression'
    },
    {
        '`call/recursive´ or `call´ or name expression or `&&´ or `&´ or `sizeof´ or `null´ or number or `false´ or `true´ or `"´ or string literal or `not´ or `%-´ or `%+´ or `~´ or `%$%$´',
        'expression'
    },
    {
        'name expression or `call/recursive´ or `call´ or `&&´ or `&´ or `sizeof´ or `null´ or number or `false´ or `true´ or `"´ or string literal or `not´ or `%-´ or `%+´ or `~´ or `%$%$´',
        'expression'
    },
    {
        '`not´ or `%-´ or `%+´ or `~´ or `%$%$´ or `call/recursive´ or `call´ or name expression or `&&´ or `&´ or `sizeof´ or `null´ or number or `false´ or `true´ or `"´ or string literal',
        'expression'
    },

    {
        '`nothing´ or `var´ or `vector´ or `pool´ or `event´ or `input´ or `output´ or `data´ or `code´ or `input/output´ or `output/input´ or `native´ or `deterministic´ or name expression or `await´ or `emit´ or `call/recursive´ or `call´ or `request´ or `spawn´ or `kill´ or `do´ or `if´ or `loop´ or `every´ or `par/or´ or `par/and´ or `watching´ or `pause/if´ or `async/isr´ or `atomic´ or `pre´ or `%[´ or `lua´ or `escape´ or `break´ or `continue´ or `par´ or end of file',
        'statement'
    },
    {
        '`nothing´ or `var´ or `vector´ or `pool´ or `event´ or `input´ or `output´ or `data´ or `code´ or `input/output´ or `output/input´ or `native´ or `deterministic´ or name expression or `await´ or `emit´ or `call/recursive´ or `call´ or `request´ or `spawn´ or `kill´ or `do´ or `if´ or `loop´ or `every´ or `par/or´ or `par/and´ or `watching´ or `pause/if´ or `async/isr´ or `atomic´ or `pre´ or `%[´ or `lua´ or `escape´ or `break´ or `continue´ or `par´ or `end´',
        'statement'
    },
    {
        '`nothing´ or `var´ or `vector´ or `pool´ or `event´ or `input´ or `output´ or `data´ or `code´ or `input/output´ or `output/input´ or `native´ or `deterministic´ or `%*´ or name expression or `await´ or `emit´ or `call/recursive´ or `call´ or `request´ or `spawn´ or `kill´ or `do´ or `if´ or `loop´ or `every´ or `par/or´ or `par/and´ or `watching´ or `pause/if´ or `async/isr´ or `atomic´ or `pre´ or `%[´ or `lua´ or `escape´ or `break´ or `continue´ or `par´ or end of file',
        'statement'
    },
}
if TESTS then
    TESTS.parser_translate = TESTS.parser_translate or { ok={}, original=T }
end

-- ( ) . % + - * ? [ ] ^ $

local function translate (msg)
    for i,t in ipairs(T) do
        local fr,to = unpack(t)
        local new = string.gsub(msg, fr, to)
        if TESTS then
            if msg ~= new then
                TESTS.parser_translate.ok[i] = true
            end
        end
        msg = new
--return new
    end
    return msg
end

local ERR_i    = 0
local ERR_strs = {}
local LST_i    = 0
local LST_str  = 'begin of file'

local IGN = 0
local ign_inc   = m.Cmt(P'', function() IGN=IGN+1 return true  end)
local ign_dec_t = m.Cmt(P'', function() IGN=IGN-1 return true  end)
local ign_dec_f = m.Cmt(P'', function() IGN=IGN-1 return false end)

local function I (patt)
    return ign_inc * (patt*ign_dec_t + ign_dec_f*P(false))
end

local function ERR ()
--DBG(LST_i, ERR_i, ERR_strs, _I2L[LST_i], I2TK[LST_i])
    local file, line = unpack(CEU.i2l[LST_i])
    return 'ERR : '..file..
              ' : line '..line..
              ' : after `'..LST_str..'´'..
              ' : expected '..translate(table.concat(ERR_strs,' or '))
end

local function fail (i, err)
    if i==ERR_i and (not ERR_strs[err]) then
        ERR_strs[#ERR_strs+1] = err
        ERR_strs[err] = true
    elseif i > ERR_i then
        ERR_i = i
        ERR_strs = { err }
        ERR_strs[err] = true
    end
    return false
end

-- KK accepts leading chars
local function KK (patt, err, nox)
    if type(patt) == 'string' then
        err = err or '`'..patt..'´'
    else
        err = err or error(debug.traceback())
    end

    local ret = m.Cmt(patt,
                    -- SUCCESS
                    function (_, i, tk)
                        if IGN>0 then return true end
if __debug then
    DBG(string.rep(' ',spc)..'|||', '|'..tk..'|')
end
                        if i > LST_i then
                            LST_i   = i
                            LST_str = tk
                        end
                        return true
                    end)
              + m.Cmt(P'',
                    -- FAILURE
                    function (_,i)
                        if err==true or IGN>0 then return false end
                        return fail(i,err)
                    end) * P(false)
                           -- (avoids "left recursive" error (explicit fail))

    if not nox then
        ret = ret * x
    end
    return ret
end

-- K is exact match
local function K (patt, err, nox)
    err = err or '`'..patt..'´'
    patt = patt * -m.R('09','__','az','AZ','\127\255')
    return KK(patt, err, nox)
end

local CKK = function (tk,err,nox)
    local patt = C(KK(tk,err,true))
    if nox == nil then
        patt = patt * x
    end
    return patt
end
local CK = function (tk,err,nox)
    local patt = C(K(tk,err,true))
    if nox == nil then
        patt = patt * x
    end
    return patt
end

local OPT = function (patt)
    return patt + Cc(false)
end

local PARENS = function (patt)
    return KK'(' * patt * KK')'
end

local function LIST (patt)
    return patt * (KK','*patt)^0 * KK','^-1
end

local E = function (msg)
    return m.Cmt(P'',
            function (_,i)
                return fail(i,msg)
            end)
end

-- TODO; remove
local EE = function (msg)
    return m.Cmt(P'',
            function (_,i)
                TESTS_TODO = true
                return fail(i,msg)
            end)
end

-->>> OK
local TYPES = P'bool' + 'byte'
            + 'f32' + 'f64' + 'float'
            + 'int'
            + 's16' + 's32' + 's64' + 's8'
            + 'ssize'
            + 'u16' + 'u32' + 'u64' + 'u8'
            + 'uint' + 'usize' + 'void'
--<<<

-- must be in reverse order (to count superstrings as keywords)
KEYS = P
'with' +
'watching' +
'vector' +
'var' +
'val' +
'until' +
'true' +
'traverse' +
'tight' +
'thread' +
'then' +
'spawn' +
'sizeof' +
'resume' +
'request' +
'recursive' +
'pure' +
'pre' +
'pos' +
'pool' +
'plain' +
'pause' +
'par' +
'output' +
'outer' +
'or' +
'null' +
'nothing' +
'not' +
'nohold' +
'new' +
'native' +
'lua' +
'loop' +
'kill' +
'isr' +
'is' +
'input' +
'in' +
'if' +
'hold' +
'FOREVER' +
'finalize' +
'false' +
'every' +
'event' +
'escape' +
'end' +
'emit' +
'else' +
'dynamic' +
'do' +
'deterministic' +
'data' +
'continue' +
'const' +
'code' +
'call' +
'break' +
'await' +
'atomic' +
'async' +
'as' +
'and' +
TYPES

KEYS = KEYS * -m.R('09','__','az','AZ','\127\255')

local Alpha    = m.R'az' + '_' + m.R'AZ'
local Alphanum = Alpha + m.R'09'
local ALPHANUM = m.R'AZ' + '_' + m.R'09'
local alphanum = m.R'az' + '_' + m.R'09'

-- Rule:    unchanged in the AST
-- _Rule:   changed in the AST as "Rule"
-- __Rule:  container for other rules, not in the AST
-- __rule:  (local) container for other rules

GG = { [1] = x * V'_Stmts' * V'Y' * (P(-1) + E('end of file'))

-->>> OK

    , Y = C''     -- yielding point

    , __seqs = KK';' * KK(';',true)^0     -- "true": ignore as "expected"
    , Nothing = K'nothing'

-- DO, BLOCK

    -- escape/A 10
    -- break/i
    -- continue/i
    , _Escape   = K'escape'   * ('/'*V'ID_int' + Cc(true)) * OPT(V'__Exp')
    , Break    = K'break'    * OPT('/'*V'ID_int') * V'Y'
    , Continue = K'continue' * OPT('/'*V'ID_int')

    -- do/A ... end
    , Do = K'do' * ('/'*(V'ID_int'+V'ID_any') + Cc(true)) *
                V'Block' *
           K'end'

    , __Do  = K'do' * V'Block' * K'end'
    , _Dopre = K'pre' * V'__Do'

    , Block = V'_Stmts'

-- PAR, PAR/AND, PAR/OR

    , Par     = K'par' * K'do' *
                 V'Block' * (K'with' * V'Block')^1 *
                K'end'
    , Par_And = K'par/and' * K'do' *
                    V'Block' * (K'with' * V'Block')^1 *
                K'end'
    , Par_Or  = K'par/or' * K'do' *
                    V'Block' * (K'with' * V'Block')^1 *
                K'end'

-- FLOW CONTROL

    , _If = K'if' * V'__Exp' * K'then' * V'Block' *
            (K'else/if' * V'__Exp' * K'then' * V'Block')^0 *
            OPT(K'else' * V'Block') *
            K'end'

    , _Loop_Num_Range = (CKK'[' + CKK']') * (
                            V'__Exp' * CKK'->' * (V'ID_any' + V'__Exp') +
                            (V'ID_any' + V'__Exp') * CKK'<-' * V'__Exp'
                          ) * (CKK'[' + CKK']') *
                          OPT(KK',' * V'__Exp')

    , _Loop_Num = K'loop' * OPT('/'*V'__Exp') *
                    (V'__ID_int'+V'ID_any') * OPT(K'in' * V'_Loop_Num_Range') *
                  V'__Do'
    , Loop_Pool = K'loop' * OPT('/'*V'__Exp') *
                    OPT(PARENS(V'List_Var')) *
                        K'in' * V'Exp_Name' *
                  V'__Do'
    , Loop      = K'loop' * OPT('/'*V'__Exp') *
                  V'__Do'

    , _Every  = K'every' * OPT((V'Exp_Name'+PARENS(V'List_Name')) * K'in') *
                    (V'Await_Ext' + V'Await_Int' + V'Await_Wclock') *
                V'__Do'

    , Stmt_Call = V'Abs_Call' + V'Exp_Call'

    , __fin_stmt  = V'___fin_stmt' * V'__seqs'
    , ___fin_stmt = V'Nothing'
                  + V'_Set'
                  + V'Emit_Ext_emit' + V'Emit_Ext_call'
                  + V'Stmt_Call'
    , __finalize  = K'finalize' * (PARENS(V'List_Name') + Cc(false)) * K'with' *
                        V'Block' *
                    OPT(K'pause'  * K'with' * V'Block') *
                    OPT(K'resume' * K'with' * V'Block') *
                    K'end'
    , Finalize = K'do' * OPT(V'__fin_stmt') * V'__finalize'

    , _Var_set_fin = K'var' * KK'&?' * V'Type' * V'__ID_int'
                   * (KK'='-'==') * KK'&'
                    * (V'Exp_Call' + V'Abs_Call')
                     * V'__finalize'

    , Pause_If = K'pause/if' * (V'Exp_Name'+V'ID_ext') * V'__Do'

-- ASYNCHRONOUS

    , Async        = K'await' * K'async' * (-P'/thread'-'/isr') * V'Y' *
                        OPT(PARENS(V'List_Var')) * V'__Do'
    , Async_Thread = K'await' * K'async/thread' * V'Y' *
                        OPT(PARENS(V'List_Var')) * V'__Do'
    , _Async_Isr   = K'async/isr' * KK'[' * V'List_Exp' * KK']' *
                            OPT(PARENS(V'List_Var')) *
                      V'__Do'
    , Atomic  = K'atomic' * V'__Do'

-- CODE / EXTS (call, req)

    -- CODE

    , __code = K'code' * Ct( Cg(K'/tight'*Cc'tight','tight') *
                             Cg(K'/dynamic'*Cc'dynamic','dynamic')^-1 *
                             Cg(K'/recursive'*Cc'recursive','recursive')^-1 ) *
                (V'__ID_abs'-V'__id_data') *
                    V'Code_Pars' * KK'->' *
                        Cc(false) *
                            V'Type'
             + K'code' * Ct( Cg(K'/await'*Cc'await','await') *
                             Cg(K'/dynamic'*Cc'dynamic','dynamic')^-1 *
                             Cg(K'/recursive'*Cc'recursive','recursive')^-1 ) *
                (V'__ID_abs'-V'__id_data') *
                    V'Code_Pars' * KK'->' *
                        OPT(V'Code_Pars' * KK'->') *
                            (V'Type' + CK'FOREVER')

    , _Code_proto = V'Y' * V'__code' * Cc(false)
    , _Code_impl  = V'Y' * V'__code' * V'__Do' * V'Y'

    , _Spawn_Block = K'spawn' * V'__Do'

    -- EXTS

    -- call
    , __extcode = (CK'input/output' + CK'output/input') * K'/tight'
                    * OPT(CK'/recursive')
                    * V'__ID_ext' * V'Code_Pars' * KK'->' * V'Type'
* EE'TODO-PARSER: extcode'
    , _Ext_Code_proto = V'__extcode'
    , _Ext_Code_impl  = V'__extcode' * V'__Do'

    -- req
    , __extreq = (CK'input/output' + CK'output/input') * K'/await'
                   * OPT('[' * (V'__Exp'+Cc(true)) * KK']')
                   * V'__ID_ext' * V'Code_Pars' * KK'->' * V'Type'
* EE'TODO-PARSER: request'
    , _Ext_Req_proto = V'__extreq'
    , _Ext_Req_impl  = V'__extreq' * V'__Do'

    -- TYPEPARS

    -- (var& int, var/nohold void&&)
    -- (var& int v, var/nohold void&& ptr)
    , __typepars_pre = CK'vector' * CKK'&' * V'__Dim' * V'Type'
                     + CK'pool'   * CKK'&' * V'__Dim' * V'Type'
                     + CK'event'  * OPT(V'__ALS') * Cc(false) * (PARENS(V'Typelist') + V'Type')
                     + CK'var'    * OPT(V'__ALS') * OPT(KK'/'*CK'hold') * V'Type'
    , _Code_Pars_Item  = Ct( Cg(K'dynamic','dynamic')^-1 )
                            * V'__typepars_pre' * OPT(V'__ID_int')

    , Code_Pars = #KK'(' * (
                    PARENS(P'void') +
                    PARENS(LIST(V'_Code_Pars_Item'))
                  )

-- DATA

    , __data       = K'data' * V'__ID_abs' * OPT(KK'is' * V'__Exp')
    , _Data_simple = V'__data'
    , _Data_block  = V'__data' * K'with' * (
                        (V'_Vars'+V'_Vecs'+V'_Pools'+V'_Evts') *
                            V'__seqs'
                     )^1 * K'end'

-- NATIVE, C, LUA

    -- C

    , _Nats  = K'native' *
                    OPT(KK'/'*(CK'pure'+CK'const'+CK'nohold'+CK'plain')) *
                        LIST(V'__ID_nat')
        --> Nat+

    , Nat_End = K'native' * KK'/' * K'end'
    , Nat_Block = K'native' * (CK'/pre'+CK'/pos') * (#K'do')*'do' *
                ( C(V'_C') + C((P(1)-(S'\t\n\r '*'end'*P';'^0*'\n'))^0) ) *
             x* K'end'

    , Nat_Stmt = KK'{' * C(V'__nat') * KK'}'
    , _Nat_Exp = KK'{' * C(V'__nat') * KK'}'
    , __nat   = ((1-S'{}') + '{'*V'__nat'*'}')^0

    -- Lua

    , _Lua_Do  = K'lua' * V'__Dim' * V'__Do'
    , _Lua     = KK'[' * m.Cg(P'='^0,'lua') * KK('[',nil,true) *
                 ( V'__luaext' + C((P(1)-V'__luaext'-V'__luacmp')^1) )^0
                  * (V'__luacl'/function()end) *x
    , __luaext = P'@' * V'__Exp'
    , __luacl  = ']' * C(P'='^0) * KK']'
    , __luacmp = m.Cmt(V'__luacl' * m.Cb'lua',
                    function (s,i,a,b) return a == b end)

-- VARS, VECTORS, POOLS, VTS, EXTS

    -- DECLARATIONS

    , __ALS = (CKK'&?' + CKK'&')

    , __vars_set  = V'__ID_int' * OPT(Ct(V'__Sets_one'+V'__Sets_many'))

    , _Vars_set  = K'var' * OPT(V'__ALS') * V'Type' *
                    LIST(V'__vars_set')
    , _Vars      = K'var' * OPT(V'__ALS') * V'Type' *
                    LIST(V'__ID_int')

    , _Vecs_set  = K'vector' * OPT(CKK'&') * V'__Dim' * V'Type' *
                    LIST(V'__vars_set')
                        -- TODO: only vec constr
    , _Vecs      = K'vector' * OPT(CKK'&') * V'__Dim' * V'Type' *
                    LIST(V'__ID_int')

    , _Pools_set = K'pool' * OPT(CKK'&') * V'__Dim' * V'Type' *
                    LIST(V'__vars_set')
    , _Pools     = K'pool' * OPT(CKK'&') * V'__Dim' * V'Type' *
                    LIST(V'__ID_int')

    , _Evts_set  = K'event' * OPT(V'__ALS') * (PARENS(V'Typelist')+V'Type') *
                    LIST(V'__vars_set')
    , _Evts      = K'event' * OPT(V'__ALS') * (PARENS(V'Typelist')+V'Type') *
                    LIST(V'__ID_int')

    , _Exts      = (CK'input'+CK'output') * (PARENS(V'Typelist')+V'Type') *
                    LIST(V'__ID_ext')
    , Typelist   = LIST(V'Type')

-- AWAIT, EMIT

    , __Awaits_one  = K'await' * (V'Await_Wclock' + V'Abs_Await')
    , __Awaits_many = K'await' * V'Await_Until'

    , Await_Until  = (V'Await_Ext' + V'Await_Int') * OPT(K'until'*V'__Exp')

    , Await_Ext    = V'ID_ext'   * V'Y' -I(V'Abs_Await')                 -- TODO: rem
    , Await_Int    = V'Exp_Name' * V'Y' -I(V'Await_Wclock'+V'Abs_Await') -- TODO: rem
    , Await_Wclock = (V'WCLOCKK' + V'WCLOCKE') * V'Y'

    , Await_Forever = K'await' * K'FOREVER' * V'Y'
    , Await_Pause   = K'await' * K'pause'   * V'Y'
    , Await_Resume  = K'await' * K'resume'  * V'Y'

    , _Emit_ps = OPT(V'__Exp' + PARENS(OPT(V'List_Exp')))
    , Emit_Wclock   = K'emit' * (V'WCLOCKK'+V'WCLOCKE')
    , Emit_Ext_emit = K'emit'                     * V'ID_ext' * V'_Emit_ps'
    , Emit_Ext_call = (K'call/recursive'+K'call') * V'ID_ext' * V'_Emit_ps'
    , Emit_Ext_req  = K'request'                  * V'ID_ext' * V'_Emit_ps'
* EE'TODO-PARSER: request'

    , Emit_Evt = K'emit' * -#(V'WCLOCKK'+V'WCLOCKE') * V'Exp_Name' * V'_Emit_ps' * V'Y'

    , __watch = (V'Await_Ext' + V'Await_Int' + V'Await_Wclock' + V'Abs_Await')
    , _Watching = K'watching'
                    * LIST(V'__watch')
                * V'__Do'

    , __num = CKK(m.R'09'^1,'number') / tonumber
    , WCLOCKK = #V'__num' *
                (V'__num' * KK'h'   *x + Cc(0)) *
                (V'__num' * KK'min' *x + Cc(0)) *
                (V'__num' * KK's'   *x + Cc(0)) *
                (V'__num' * KK'ms'  *x + Cc(0)) *
                (V'__num' * KK'us'  *x + Cc(0))
                    * OPT(CK'/_')
    , WCLOCKE = PARENS(V'__Exp') * (
                    CK'h' + CK'min' + CK's' + CK'ms' + CK'us'
                  + E'<h,min,s,ms,us>'
              ) * OPT(CK'/_')

-- DETERMINISTIC

    , __det_id = V'ID_ext' + V'ID_int' + V'ID_nat'
    , Deterministic = K'deterministic' * V'__det_id' * (
                        K'with' * LIST(V'__det_id')
                      )^-1

-- ABS
    , __abs_mods = Ct ( (Cg(K'/dynamic'*Cc'dynamic','dynamic') +
                         Cg(K'/static' *Cc'static', 'static'))^-1 *
                         Cg(K'/recursive'*Cc'recursive','recursive')^-1 )
    , Abs_Call  = K'call' * V'__abs_mods' * (V'Abs_Cons' -I(V'__id_data'))
    , Abs_Val   = CK'val' * V'Abs_Cons'
    , Abs_New   = CK'new' * V'Abs_Cons'
    , Abs_Await = V'__Abs_Cons_Code'

    , Abs_Spawn_Single = K'spawn' * V'__Abs_Cons_Code' * (-KK'in') * Cc(false)
    , Abs_Spawn_Pool   = K'spawn' * V'__Abs_Cons_Code' * KK'in' * V'Exp_Name'

    , __Abs_Cons_Code = V'__abs_mods' * (V'Abs_Cons' -I(V'__id_data')) *
                            OPT(KK'->' * PARENS(V'_List_Var_Ref')) * V'Y'
    , Abs_Cons   = V'ID_abs' * PARENS(OPT(V'Abslist'))
    , Abslist    = LIST(V'__abs_item')^-1
    , __abs_item = (V'Abs_Cons' + V'Vec_Cons' + V'__Exp' + V'ID_any')


-- SETS

    , _Set = V'Exp_Name' * V'__Sets_one'
           + (V'Exp_Name' + PARENS(V'List_Name')) * V'__Sets_many'

    , __Sets_one  = (KK'='-'==') * (V'__sets_one'  + PARENS(V'__sets_one'))
    , __Sets_many = (KK'='-'==') * (V'__sets_many' + PARENS(V'__sets_many'))

    , __sets_one =
          V'_Set_Do'
        + V'_Set_Await_one'
        + V'_Set_Async_Thread'
        + V'_Set_Lua'
        + V'_Set_Vec'
        + V'_Set_Emit_Wclock'
        + V'_Set_Emit_Ext_emit' + V'_Set_Emit_Ext_call'
        + V'_Set_Abs_Val'
        + V'_Set_Abs_New'
        + V'_Set_Abs_Spawn_Pool'
        + V'_Set_Any'
        + V'_Set_Exp'

    , __sets_many = V'_Set_Emit_Ext_req' + V'_Set_Await_many' + V'_Set_Watching'

    -- after `=´

    , _Set_Do             = #K'do'            * V'Do'

    , _Set_Await_one      = #K'await'         * V'__Awaits_one'
    , _Set_Await_many     = #K'await'         * V'__Awaits_many'
    , _Set_Watching       = #K'watching'      * V'_Watching'

    , _Set_Async_Thread   = #(K'await' * K'async/thread') * V'Async_Thread'
    , _Set_Lua            = #V'__lua_pre'     * V'_Lua'
    , _Set_Lua_Do         =                     V'_Lua_Do'
    , _Set_Vec            =                     V'Vec_Cons'

    , _Set_Emit_Wclock    = #K'emit'          * V'Emit_Wclock'
    , _Set_Emit_Ext_emit  = #K'emit'          * V'Emit_Ext_emit'
    , _Set_Emit_Ext_req   = #K'request'       * V'Emit_Ext_req'
    , _Set_Emit_Ext_call  = #V'__extcode_pre' * V'Emit_Ext_call'

    , _Set_Abs_Val        = #K'val'           * V'Abs_Val'
    , _Set_Abs_New        = #K'new'           * V'Abs_New'
    , _Set_Abs_Spawn_Pool = #K'spawn'         * V'Abs_Spawn_Pool'

    , _Set_Any            = #K'_'             * V'ID_any'
    , _Set_Exp            =                     V'__Exp'

    , __extcode_pre = (K'call/recursive'+K'call') * V'ID_ext'
    , __lua_pre     = KK'[' * (P'='^0) * '['
    , __vec_pre     = KK'[' - V'__lua_pre'

    , __vec_concat = KK'..' * (V'__Exp' + V'_Lua' + #KK'['*V'Vec_Tup')
    , Vec_Tup  = V'__vec_pre' * OPT(V'List_Exp') * KK']'
    , Vec_Cons = V'__Exp'   * V'__vec_concat'^1
               + V'Vec_Tup' * V'__vec_concat'^0

-- IDS

    , ID_prim = V'__ID_prim'
    , ID_ext  = V'__ID_ext'
    , ID_int  = V'__ID_int'
    , ID_abs  = V'__ID_abs'
    , ID_nat  = V'__ID_nat'
    , ID_any  = V'__ID_any'

    , __ID_prim = CK(TYPES,                     'primitive type')
    , __ID_ext  = CK(m.R'AZ'*ALPHANUM^0  -KEYS, 'external identifier')
    , __ID_int  = CK(m.R'az'*Alphanum^0  -KEYS, 'internal identifier')
    , __ID_nat  = CK(P'_' * Alphanum^1,         'native identifier')
    , __ID_any  = CK(P'_' * -Alphanum,          '`_´')

    , __id_abs  = m.R'AZ'*V'__one_az' -KEYS
    , __id_data = V'__id_abs' * ('.' * V'__id_abs')^1
    , __ID_abs = CK(V'__id_data'+V'__id_abs', 'abstraction identifier')

    -- at least one lowercase character
    , __one_az = #(ALPHANUM^0*m.R'az') * Alphanum^0


-- MODS

    , __Dim = KK'[' * (V'__Exp'+Cc('[]')) * KK']'

-- LISTS

-- TODO: rename List_*
    , List_Name = LIST(V'Exp_Name' + V'ID_any')
    , List_Exp  = LIST(V'__Exp')
    , List_Var  = LIST(V'ID_int' + V'ID_any')
    , _List_Var_Ref = LIST(KK'&'*V'ID_int' + V'ID_any')

 --<<<

    , Kill  = K'kill' * V'Exp_Name' * OPT(PARENS(V'__Exp'))

-- Types

    , Type = (V'ID_prim' + V'ID_abs' + V'ID_nat') * (CKK'&&')^0 * CKK'?'^-1

-- Expressions

    -- Exp_Name

    , Exp_Name   = V'__01_Name'
    , __01_Name  = (Cc('pre') * (CKK'*'+(CKK'$'-'$$')))^-1 * V'__02_Name'
    , __02_Name  = V'__03_Name' *
                    (Cc'pos' * (
                        KK'[' * Cc'idx' * V'__Exp' * KK']' +
                        (CKK':' + (CKK'.'-'..')) * (V'__ID_int'+V'__ID_nat') +
                        (CKK'!'-'!=') * Cc(false)
                      )
                    )^0
    , __03_Name  = PARENS(V'__01_Name' *
                    (CK'as' * (V'Type' + KK'/'*(CK'nohold'+CK'plain'+CK'pure')))^-1
                   )
                 + V'ID_int'  + V'ID_nat'
                 + V'Outer'
                 + V'_Nat_Exp'

    -- Exp

    , __Exp  = V'__01'
    , __01   = V'__12' * ( CK'is' * V'Type'
                         + CK'as' * (V'Type' + KK'/'*(CK'nohold'+CK'plain'+CK'pure'))
                         )
             + V'__02'
    , __02   = V'__03' * (CK'or'  * V'__03')^0
    , __03   = V'__04' * (CK'and' * V'__04')^0
    , __04   = V'__05' * ( ( CKK'!='+CKK'=='+CKK'<='+CKK'>='
                           + (CKK'<'-'<<'-'<-')+(CKK'>'-'>>')
                           ) * V'__05'
                         )^0
    , __05   = V'__06' * ((CKK'|'-'||') * V'__06')^0
    , __06   = V'__07' * (CKK'^' * V'__07')^0
    , __07   = V'__08' * ((CKK'&'-'&&') * V'__08')^0
    , __08   = V'__09' * ((CKK'>>'+CKK'<<') * V'__09')^0
    , __09   = V'__10' * ((CKK'+'+(CKK'-'-'->')) * V'__10')^0
    , __10   = V'__11' * ((CKK'*'+(CKK'/'-'//'-'/*')+CKK'%') * V'__11')^0
    , __11   = ( Cc('pre') *
                    ( CK'not'+(CKK'-'-'->')+CKK'+'+CKK'~'+CKK'$$' )
               )^0 * V'__12'
    , __12   = V'Exp_Call'  -- TODO: ambiguous w/ PARENS,Name
             + V'Abs_Call'
             + V'Exp_Name' * (Cc'pos' * (CKK'?' * Cc(false)))^-1
             + Cc('pre') * CKK'&&'       * V'Exp_Name'
             + Cc('pre') * (CKK'&'-'&&') * (V'Exp_Call'+V'Exp_Name')
             + PARENS(V'__Exp')
             + V'SIZEOF'
             + V'NULL' + V'NUMBER' + V'BOOL' + V'STRING'

    , SIZEOF = K'sizeof' * PARENS((V'Type' + V'__Exp'))

    , NUMBER = CK( #m.R'09' * (m.R'09'+S'xX'+m.R'AF'+m.R'af'+(P'.'-'..')
                                      +(S'Ee'*'-')+S'Ee')^1,
                   'number' )
             --+ CKK( "'" * (P(1)-"'")^0 * "'" , 'number' )

    , BOOL   = K'false' / function() return 0 end
             + K'true'  / function() return 1 end
    , STRING = CKK( CKK'"' * (P(1)-'"'-'\n')^0 * K'"', 'string literal' )
    , NULL   = CK'null'     -- TODO: the idea is to get rid of this

    , Outer   = K'outer'

    , __exp_call = (CK'call/recursive' + CK'call' + Cc'call')
    , Exp_Call = V'__exp_call' * (V'Exp_Name'+PARENS(V'__Exp')) *
                                PARENS(OPT(V'List_Exp'))

---------
                -- "Ct" as a special case to avoid "too many captures" (HACK_1)
    , _Stmts  = Ct (( V'__Stmt_Simple' * V'__seqs' +
                      V'__Stmt_Block' * (KK';'^0)
                   )^0
                 * ( V'__Stmt_Last' * V'__seqs' +
                     V'__Stmt_Last_Block' * (KK';'^0)
                   )^-1
                 * (V'Nat_Block'+V'_Code_impl')^0 )

    , __Stmt_Last  = V'_Escape' + V'Break' + V'Continue' + V'Await_Forever'
    , __Stmt_Last_Block = V'Y' * V'Par'
    , __Stmt_Simple = V'Nothing'
                    + V'_Vars_set'  + V'_Vars'
                    + V'_Vecs_set'  + V'_Vecs'
                    + V'_Pools_set' + V'_Pools'
                    + V'_Evts_set'  + V'_Evts'
                    + V'_Exts'
                    + V'_Data_simple'
                    + V'_Code_proto' + V'_Ext_Code_proto' + V'_Ext_Req_proto'
                    + V'_Nats'  + V'Nat_End'
                    + V'Deterministic'
                    + V'_Set'
                    + V'__Awaits_one' + V'__Awaits_many'
                    + V'Await_Pause' + V'Await_Resume'
                    + V'Emit_Wclock'
                    + V'Emit_Ext_emit' + V'Emit_Ext_call' + V'Emit_Ext_req'
                    + V'Emit_Evt'
                    + V'Abs_Spawn_Single' + V'Abs_Spawn_Pool' + V'Kill'
-- TODO: remove class/interface
+ I((K'class'+K'interface'+K'traverse')) * EE'TODO-PARSER: class/interface'
                    + V'Stmt_Call'
                    + V'Nat_Stmt'

    , __Stmt_Block = V'_Code_impl' + V'_Ext_Code_impl' + V'_Ext_Req_impl'
              + V'_Data_block'
              + V'Nat_Block'
              + V'Do'    + V'_If'
              + V'Loop' + V'_Loop_Num' + V'Loop_Pool'
              + V'_Every'
              + V'_Spawn_Block'
              + V'Finalize'
              + V'Y'*V'Par_Or' + V'Y'*V'Par_And' + V'_Watching'
              + V'Pause_If'
              + V'Async' + V'Async_Thread' + V'_Async_Isr' + V'Atomic'
              + V'_Dopre'
              + V'_Lua' + V'_Lua_Do'
              + V'_Var_set_fin'

    --, _C = '/******/' * (P(1)-'/******/')^0 * '/******/'
    , _C      = m.Cg(V'_CSEP','mark') *
                    (P(1)-V'_CEND')^0 *
                V'_CEND'
    , _CSEP = '/***' * (1-P'***/')^0 * '***/'
    , _CEND = m.Cmt(C(V'_CSEP') * m.Cb'mark',
                    function (s,i,a,b) return a == b end)

    , __SPACE = ('\n' * (V'__comm'+S'\t\n\r ')^0 *
                  '#' * (P(1)-'\n')^0)
              + ('//' * (P(1)-'\n')^0)
              + S'\t\n\r '
              + V'__comm'

    , __comm    = '/' * m.Cg(P'*'^1,'comm') * (P(1)-V'__commcmp')^0 * 
                    V'__commcl'
                    / function () end
    , __commcl  = C(P'*'^1) * '/'
    , __commcmp = m.Cmt(V'__commcl' * m.Cb'comm',
                    function (s,i,a,b) return a == b end)

}

if TESTS then
    assert(m.P(GG):match(CEU.source), ERR())
else
    if not m.P(GG):match(CEU.source) then
             -- TODO: match only in ast.lua?
        DBG(ERR())
        os.exit(1)
    end
end

end

    
do
AST = {
    root = nil,
}

local STACK = {}

local MT = {}
function AST.is_node (node)
    return (getmetatable(node) == MT) and node.tag
end

AST.tag2id = {
    Abs_Await        = 'await',
    Abs_Spawn_Single = 'spawn',
    Abs_Spawn_Pool   = 'spawn',
    Alias            = 'alias',
    Async            = 'async',
    _Async_Isr       = 'async/isr',
    Async_Thread     = 'async/thread',
    Await_Until      = 'await',
    Await_Ext        = 'await',
    Await_Forever    = 'await',
    Await_Int        = 'await',
    Await_Wclock     = 'await',
    Break            = 'break',
    Code             = 'code',
    Continue         = 'continue',
    Data             = 'data',
    Emit_Evt         = 'emit',
    Emit_ext_req     = 'request',
    EOC              = 'end of code',
    EOF              = 'end of file',
    Escape           = 'escape',
    Every            = 'every',
    Evt              = 'event',
    Ext_Code         = 'external code',
    Ext_Code         = 'external code',
    Ext              = 'external',
    Finalize         = 'finalize',
    Kill             = 'kill',
    Loop             = 'loop',
    Loop_Num         = 'loop',
    Loop_Pool        = 'loop',
    Nat_Block        = 'native block',
    Nat              = 'native',
    Nothing          = 'nothing',
    Par_And          = 'par/and',
    Par_Or           = 'par/or',
    Par              = 'par',
    Watching         = 'watching',
    Pool             = 'pool',
    Prim             = 'primitive',
    Set_Await_many   = 'await',
    Val              = 'value',
    Var              = 'variable',
    Vec              = 'vector',
}

local _N = 0
function AST.node (tag, ln, ...)
    local me
    if tag == '_Stmts' then
        -- "Ct" as a special case to avoid "too many captures" (HACK_1)
        tag = 'Stmts'
        me = setmetatable((...), MT)
    else
        me = setmetatable({ ... }, MT)
    end
    me.n = _N
    --me.xxx = debug.traceback()
    _N = _N + 1
    me.ln  = ln
    --me.ln[2] = me.n
    me.tag = tag

    for i,sub in ipairs(me) do
        if AST.is_node(sub) then
            sub.__par   = me
            sub.__i     = i
        end
    end

    return me
end

function AST.depth (me)
    if me.__par then
        return 1 + AST.depth(me.__par)
    else
        return 1
    end
end

function AST.copy (node, ln, keep_n)
    if not AST.is_node(node) then
        return node
    end
    assert(node.tag ~= 'Ref')

    local ret = setmetatable({}, MT)
    local N = (keep_n and node.n) or _N
    if not keep_n then
        _N = _N + 1
    end

    for k, v in pairs(node) do
        if type(k) ~= 'number' then
            ret[k] = v
        else
            if AST.is_node(v) then
                AST.set(ret, k, AST.copy(v, ln, keep_n))
                ret[k].ln = ln or ret[k].ln
            else
                ret[k] = AST.copy(v, ln, keep_n)
            end
        end
    end
    ret.n = N

    return ret
end

function AST.is_equal (n1, n2, ignore)
    if ignore and ignore(n1,n2) then
        return true
    elseif n1 == n2 then
        return true
    elseif AST.is_node(n1) and AST.is_node(n2) then
        if n1.tag==n2.tag and #n1==#n2 then
            for i, v in ipairs(n1) do
                if not AST.is_equal(n1[i],n2[i],ignore) then
                    return false
                end
            end
            return true
        else
            return false
        end
    else
        return false
    end
end

--[[
function AST.idx (par, me)
    assert(AST.is_node(par))
    for i, sub in ipairs(par) do
        if sub == me then
            return i
        end
    end
    error'bug found'
end
]]

function AST.get (me, tag, ...)
    local idx, tag2 = ...

    if type(tag) == 'number' then
        if tag > 0 then
            if me.__par then
                return AST.get(me.__par, tag-1, ...)
            else
                return nil
            end
        else
            assert(tag == 0)
            return AST.get(me, ...)
        end
    end

    if not (AST.is_node(me) and (me.tag==tag or tag=='')) then
        return nil, tag, ((AST.is_node(me) and me.tag) or 'none')
    end

    if idx then
        return AST.get(me[idx], tag2, select(3,...))
    else
        return me
    end
end

function AST.asr (me, tag, ...)
    local ret, tag1, tag2 = AST.get(me, tag, ...)
    if not ret then
        DBG(debug.traceback())
        error('bug (expected: '..tag1..' | found: '..tag2..')')
    end
    return ret
end

function AST.set (par, i, child)
    assert(AST.is_node(child))
    par[i] = child
    child.__par = par
    child.__i   = i
end

function AST.insert (par, i, child)
    table.insert(par, i, {})
    AST.set(par, i, child)
    for i, sub in ipairs(par) do
        if AST.is_node(sub) then
            sub.__i = i
        end
    end
end

function AST.remove (par, i)
    table.remove(par, i)
    for i, sub in ipairs(par) do
        if AST.is_node(sub) then
            sub.__i = i
        end
    end
end

function AST.is_par (par, child)
    if par == child then
        return true
    elseif not child.__par then
        return false
    else
        return AST.is_par(par, child.__par)
    end
end

function AST.par (me, pred)
    if type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    if not me.__par then
        return nil
    elseif pred(me.__par) then
        return me.__par
    else
        return AST.par(me.__par, pred)
    end
end

function AST.pred_true (me) return true end

function AST.iter (pred, inc)
    if pred == nil then
        pred = AST.pred_true
    elseif type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    local from = (inc and 1) or #STACK
    local to   = (inc and #STACK) or 1
    local step = (inc and 1) or -1
    local i = from
    return function ()
        for j=i, to, step do
            local stmt = STACK[j]
            if pred(stmt) then
                i = j+step
                return stmt
            end
        end
    end
end

--[[
-- doesnt pass b/c of data inheritance
local __detect_same
function AST.check (me, not_first)
    if not_first == nil then
        __detect_same = {}
    end
--AST.dump(AST.root)
    assert(not __detect_same[me], 'AST.check fail: '..me.n..' : '..me.tag)
    __detect_same[me] = true

    for i, sub in ipairs(me) do
        if AST.is_node(sub) then
            AST.check(sub, true)
        end
    end
end
]]

function AST.dump (me, spc, lvl, __notfirst)
    if lvl and lvl==0 then
        return
    end
    spc = spc or 0
    local ks = ''
--[[
    for k, v in pairs(me) do
        if type(k)~='number' then
            v = string.gsub(string.sub(tostring(v),1,8),'\n','\\n')
            ks = ks.. k..'='..v..','
        end
    end
]]
    --local t=0; for _ in pairs(me.aw.t) do t=t+1 end
    --ks = 'n='..(me.aw.n or '?')..',t='..t..',ever='..(me.aw.forever_ and 1 or 0)
    --ks = table.concat(me.trails,'-')
--
--[[
if me.ana and me.ana.pre and me.ana.pos then
    local f = function(v)
                return type(v)=='table'
                            and (type(v[1])=='table' and v[1].id or v[1])
                    or tostring(v)
              end
    local t = {}
    for k in pairs(me.ana.pre) do t[#t+1]=f(k) end
    ks = '['..table.concat(t,',')..']'
    local t = {}
    for k in pairs(me.ana.pos) do t[#t+1]=f(k) end
    ks = ks..'['..table.concat(t,',')..']'
end
]]
--
    --ks = me.ns.trails..' / '..tostring(me.needs_clr)
    local me_str  = string.gsub(tostring(me),       'table: ', '')
--assert(me==AST.root or (me.__par and me.__i))
    local par_str = string.gsub(tostring(me.__par), 'table: ', '')
    DBG(string.rep(' ',spc)..me.tag..
        ' |'..me_str..'/'..par_str..'['..tostring(me.__i)..']|'..
--[[
        '')
]]
        ' (ln='..me.ln[2]..' n='..me.n..' d='..AST.depth(me)..
                           --' d='..(me.__depth or 0)..
                           --' p='..(me.__par and me.__par.n or '')..
                           ') '..ks)
--DBG'---'
--DBG(me.xxx)
--DBG'---'
    for i, sub in ipairs(me) do
        if AST.is_node(sub) then
            AST.dump(sub, spc+2, lvl and lvl-1)
        else
            DBG(string.rep(' ',spc+2) .. '['..tostring(sub)..']')
        end
    end
end

local function FF (F, str)
    local f = F[str]
    if type(f) == 'string' then
        return FF(F, f)
    end
    assert(f==nil or type(f)=='function')
    return f
end

local function from_to (old, new, t)
    if new and new~=old then
        new.__par = t[1]
        new.__i   = t[2]
        return true, new
    else
        return false, old
    end
end

local function visit_aux (F, me, I)
    local pre, mid, pos = FF(F,me.tag..'__PRE'), FF(F,me.tag), FF(F,me.tag..'__POS')
    local bef, aft = FF(F,me.tag..'__BEF'), FF(F,me.tag..'__AFT')

    local chg = false
    local t   = { me.__par, me.__i }

    if F.Node__PRE then
        chg, me = from_to(me, F.Node__PRE(me), t)
        if chg then
            return visit_aux(F, me)
        end
    end
    if pre then
        chg, me = from_to(me, pre(me), t)
        if chg then
            return visit_aux(F, me)
        end
    end

    STACK[#STACK+1] = me

    for i, _ in ipairs(me) do
        if bef then assert(bef(me,me[i],i)==nil) end
        if AST.is_node(me[i]) then
            me[i] = visit_aux(F, me[i], i)
        end
        if aft then assert(aft(me,me[i],i)==nil) end
    end

    if mid then
        assert(mid(me) == nil, me.tag)
    end
    if F.Node then
        assert(F.Node(me) == nil)
    end

    STACK[#STACK] = nil

    if pos then
        chg, me = from_to(me, pos(me), t)
        if chg then
            return visit_aux(F, me)
        end
    end
     if F.Node__POS then
        chg, me = from_to(me, F.Node__POS(me), t)
        if chg then
            return visit_aux(F, me)
        end
    end

   return me
end
AST.visit_aux = visit_aux

function AST.visit (F, node)
    assert(AST)
    --STACK = {}
    return visit_aux(F, node or AST.root)
end

local function i2l (p)
    return CEU.i2l[p]
end

for tag, patt in pairs(GG) do
    if string.sub(tag,1,2) ~= '__' then
        GG[tag] = m.Cc(tag) * (m.Cp()/i2l) * patt / AST.node
    end
end

local function f (ln, v1, v2, v3, v4, ...)
    --DBG('>>>',ln[2],v1,v2,v3,v4,...)
    if v1 == 'pre' then
        local x = ''
        if v2=='+' or v2=='-' or v2=='&' or v2=='*' then
            x = '1' -- unary +/-
        end
        return AST.node('Exp_'..x..v2, ln, v2, f(ln,v3,v4,...))
    elseif v2 == 'pos' then
        return f(ln, AST.node('Exp_'..v3,ln,v3,v1,v4), ...)
    elseif v2 then
        -- binary
        return f(ln, AST.node('Exp_'..v2,ln,v2,v1,v3), v4, ...)
    else
        -- primary
        return v1
    end
end

local __exps = { '', '_Name', '_Call' }
for _, id in ipairs(__exps) do
    for i=0, 12 do
        if i < 10 then
            i = '0'..i
        end
        local tag = '__'..i..id
        if GG[tag] then
            GG[tag] = (m.Cp()/i2l) * GG[tag] / f
        end
    end
end

AST.root = m.P(GG):match(CEU.source)
AST.visit({})

end

    DBG,ASR = DBG2,ASR2
    
do
ADJS = {
}

local node = AST.node

local Pre_Stmts

F = {
    ['1__PRE'] = function (me)
        local stmts, eof = unpack(me)
        AST.asr(stmts, 'Stmts')
        AST.set(stmts, #stmts+1, eof)

        --  Stmts
        --      to
        --  Block
        --      Stmts
        --          nats
        --          Var             -- _ret
        --          Set
        --              ret
        --              Do
        --                  Block
        --                      Stmts
        --                          _Lua_Do
        --                              Stmts   -- pre do (Pre_Stmts)
        --                              Stmts   -- orig

        Pre_Stmts = node('Stmts', me.ln)
        AST.insert(stmts, 1, Pre_Stmts)

        local nats = node('Stmts', me.ln,
                        node('Nat', me.ln,
                            false,
                            node('Type', me.ln,
                                node('ID_prim', me.ln, '_')),
                            '_{}'),
                        node('Nat', me.ln,
                            false,
                            'plain',
                            '_char'),
                        node('Nat', me.ln,
                            'nohold',
                            node('Type', me.ln,
                                node('ID_prim', me.ln, '_')),
                            '_ceu_callback_assert_msg'))
        nats[3].is_predefined = true

        local ret = node('Var', me.ln,
                        false,
                        node('Type', me.ln,
                            node('ID_prim', me.ln, 'int')),
                        '_ret')
        ret.is_implicit = true

        local lua do
            if CEU.opts.ceu_features_lua then
                lua = node('Stmts', me.ln,
                        node('_Lua_Do', me.ln,
                            '[]',
                            node('Block', me.ln,
                                stmts)))
            else
                lua = stmts
            end
        end

        AST.root =
            node('ROOT', me.ln,
                node('Block', me.ln,
                    node('Stmts', me.ln,
                        nats,
                        ret,
                        node('_Set', me.ln,
                            node('Exp_Name', me.ln,
                                node('ID_int', me.ln, '_ret')),
                            node('_Set_Do', me.ln,
                                node('Do', me.ln,
                                    true,
                                    node('Block', me.ln, lua)))))))
        return AST.root
    end,
    _Stmts__PRE = function (me)
error'TODO: luacov never executes this?'
        local t = unpack(me)
        return node('Stmts', me.ln, unpack(t))
    end,
    _Dopre__POS = function (me)
        AST.set(Pre_Stmts, #Pre_Stmts+1, AST.asr(me,'', 1,'Block', 1,'Stmts'))
        return AST.node('Nothing', me.ln)
    end,

-------------------------------------------------------------------------------

    -- TODO: "__PRE" because of "continue"
    _If__PRE = function (me)
        local cnd, t, f_or_more = unpack(me)
        if #me == 3 then
            -- if <cond> then <t> else <f> end
            me.tag = 'If'
            if f_or_more == false then
                AST.set(me, 3, node('Block', me.ln,
                                node('Stmts', me.ln)))
            end
            return      -- has no "else/if" and has "else" clause
        else
            return node('If', me.ln,
                    cnd,
                    t,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('_If', me.ln,
                                f_or_more,
                                select(4,unpack(me))))))
        end
    end,

    _Spawn_Block__PRE = function (me)
        local blk = unpack(me)

        -- all statements after myself
        local par_stmts = AST.asr(me.__par, 'Stmts')
        local cnt_stmts = { unpack(par_stmts, me.__i+1) }
        for i=me.__i, #par_stmts do
            par_stmts[i] = nil
        end

        local awaitN = node('Await_Forever', me.ln)
-- TODO
        awaitN.__adj_no_not_reachable_warning = true

        local orig = AST.asr(blk,'Block', 1,'Stmts')
-- TODO
        orig.__adj_is_spawnanon = true
        orig.ln = me.ln
        AST.set(blk, 1, node('Stmts', me.ln, blk[1], awaitN))

        local ret = node('Par_Or', me.ln,
                        blk,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                unpack(cnt_stmts))))
-- TODO
        ret.__adj_no_should_terminate_warning = true
        return ret
    end,


-------------------------------------------------------------------------------

    _Data_simple__PRE = '_Data_block__PRE',
    _Data_block__PRE = function (me)
        local id, enum = unpack(me)
        return node('Data', me.ln,
                id, enum,
                node('Block', me.ln,
                    node('Stmts', me.ln,
                        unpack(me, 3))))
    end,

    _Ext_Req_proto__PRE  = '_Code_proto__PRE',
    _Ext_Code_proto__PRE = '_Code_proto__PRE',
    _Code_proto__PRE = function (me)
        local tag = string.match(me.tag,'(.*)_proto')
        return node(tag, me.ln, unpack(me))
    end,

    _Ext_Req_impl__PRE  = '_Code_impl__PRE',
    _Ext_Code_impl__PRE = '_Code_impl__PRE',
    _Code_impl__PRE = function (me)
        local _,_,_,_,_,out,blk = unpack(me)

        local stmts_old = AST.asr(blk,'Block', 1,'Stmts')
        local stmts_new = node('Stmts', me.ln)
        AST.set(blk, 1, stmts_new)

        local Type = AST.get(out,'Type')
        if Type then
            -- enclose "blk" with "_ret = do ... end"

            local ID_prim,mod = unpack(Type)
            local is_void = (ID_prim.tag=='ID_prim' and ID_prim[1]=='void' and (not mod))
            local do_ = node('Do', me.ln,
                            true,
                            node('Block', me.ln,
                                stmts_old))
            if is_void then
                AST.set(stmts_new, 1, do_)
            else
                AST.set(stmts_new, 1,
                        node('_Set', me.ln,
                            node('Exp_Name', me.ln,
                                node('ID_int', me.ln, '_ret')),
                            node('_Set_Do', me.ln,
                                do_)))
            end
        else
            -- ok
            AST.set(stmts_new, 1, node('Block', me.ln, stmts_old))
        end

        local tag = string.match(me.tag,'(.*)_impl')
        return node(tag, me.ln, unpack(me))
    end,

    _Code__PRE = function (me)
        local Y, mods, id, ins, mid, out, blk, eoc = unpack(me)
        mid = mid or AST.node('Code_Pars', me.ln)

        local Type = AST.get(out,'Type')
        if Type then
            local ID_prim,mod = unpack(Type)
            local is_void = (ID_prim.tag=='ID_prim' and ID_prim[1]=='void' and (not mod))
            if is_void then
                out = node('Var_', me.ln, false, AST.copy(out), '_ret')
                    -- TODO: HACK_5
            else
                out = node('Var', me.ln, false, AST.copy(out), '_ret')
            end
            out.is_implicit = true
        else
            out = node('Nothing', me.ln)
        end

        local ret = node('Code', me.ln, Y, mods, id,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('Stmts', me.ln, ins, mid, out),
                                (blk or node('Stmts',me.ln)))),
                        eoc)
        ret.is_impl = (blk ~= false)
        return ret
    end,

    Code_Pars__PRE = function (me)
        local Code = AST.par(me,'Code')

        local params, mids = unpack(AST.asr(me,1,'Stmts'))

        local is_param = (params == me)
        local is_mid   = (mids == me)

        for i, v in ipairs(me) do
            if v == 'void' then
error'TODO'
            else
                AST.asr(v,'_Code_Pars_Item')
                local mods,pre,is_alias = unpack(v)
                local _,dim,hold,tp,id
                local dcl
                if pre == 'var' then
                    _,_,_,hold,tp,id = unpack(v)
                    id = id or '_anon_'..i
                    AST.set(me, i, node('Var', me.ln, is_alias, AST.copy(tp), id))
                elseif pre == 'vector' then
                    _,_,_,dim,tp,id = unpack(v)
                    id = id or '_anon_'..i
                    AST.set(me, i,
                            node('Vec', me.ln, is_alias, AST.copy(tp), id, AST.copy(dim)))
                elseif pre == 'pool' then
                    _,_,_,dim,tp,id = unpack(v)
                    id = id or '_anon_'..i
                    AST.set(me, i,
                            node('Pool', me.ln, is_alias, AST.copy(tp), id, AST.copy(dim)))
                elseif pre == 'event' then
                    _,_,_,_,tp,id = unpack(v)
                    id = id or '_anon_'..i
                    if tp.tag == 'Type' then
                        tp = node('Typelist', me.ln, tp)
                        AST.set(v, 4, tp)
                    end
                    AST.set(me, i, node('Evt', me.ln, is_alias, AST.copy(tp), id))
                else
                    error'TODO'
                end
                me[i].is_param   = is_param
                me[i].is_mid_idx = is_mid and ((params and #params or 0) + i)
                me[i].mods       = mods
                if Code.is_impl then
                    ASR(id ~= '_anon_'..i, me,
                        'invalid declaration : parameter #'..i..' : expected identifier')
                end
            end
        end
    end,

-------------------------------------------------------------------------------

    _Loop__PRE = function (me)
        local max, body = unpack(me)

        local max_dcl = node('Nothing', me.ln)
        local max_ini = node('Nothing', me.ln)
        local max_inc = node('Nothing', me.ln)
        local max_chk = node('Nothing', me.ln)
        if max then
            max_chk = node('Stmt_Call', me.ln,
                        node('Exp_Call', me.ln,
                            'call',
                            node('Exp_Name', me.ln,
                                node('ID_nat', me.ln,
                                    '_ceu_callback_assert_msg')),
                            node('List_Exp', me.ln,
                                node('Exp_<', me.ln, '<',
                                    node('Exp_Name', me.ln,
                                        node('ID_int', me.ln, '__max_'..me.n)),
                                    AST.copy(max)),
                                node('STRING', me.ln,
                                    '"`loop´ overflow"'))))
        end

        local Stmts = AST.asr(body,'Block', 1,'Stmts')
        local i = (from_loop_num and 2 or 1)  -- after lim_chk
        AST.insert(Stmts, i,        max_chk)
        AST.insert(Stmts, #Stmts+1, max_inc)

        return node('Block', me.ln,
                node('Stmts', me.ln,
                    max_dcl,
                    max_ini,
                    node('Loop', me.ln, max, body)))
    end,
    _Loop_Num__PRE = function (me)
        local max, i, range, body = unpack(me)

        -- loop i do end
        -- loop i in [0 -> _] do end
        if not range then
            range = node('Loop_Num_Rage', me.ln,
                        '[',
                        node('NUMBER', me.ln, 0),
                        '->',
                        node('ID_any', me.ln),
                        ']',
                        false)
        end
        local lb, fr, dir, to, rb, step = unpack(range)

        -- loop i in [...] do end
        -- loop i in [...], 1 do end
        if step == false then
            step = node('NUMBER', me.ln, 1)
        end

        fr.__adj_step_mul = 0
        to.__adj_step_mul = 0

        -- loop i in [0 <- 10], 1 do end
        -- loop i in [10 -> 1], -1 do end
        if dir == '<-' then
            fr, to = to, fr
            step = node('Exp_1-', me.ln, '-', step)

            -- loop i in [... 10[ do end
            -- loop i in [... 10-1] do end
            if rb == '[' then
                fr.__adj_step_mul = 1
            end
            if lb == ']' then
                to.__adj_step_mul = 1
            end
        else
            --step = node('Exp_1+', me.ln, '+', step)

            -- loop i in ]0 ...] do end
            -- loop i in [0+1 ...] do end
            if lb == ']' then
                fr.__adj_step_mul = 1
            end
            if rb == '[' then
                to.__adj_step_mul = 1
            end
        end

        local i_dcl = node('Nothing', me.ln)
        if AST.is_node(i) then
            AST.asr(i, 'ID_any')
            i = '__i_'..me.n    -- invent an ID not referenceable
            i_dcl = node('Var', me.ln,
                        false,
                        node('Type', me.ln,
                            node('ID_prim', me.ln, 'int')),
                        i)
        end

        i = node('ID_int', me.ln, i)

        return node('Block', me.ln,
                node('Stmts', me.ln,
                    AST.copy(i_dcl),
                    node('Loop_Num', me.ln,
                        max,
                        i,
                        node('Loop_Num_Range', me.ln, fr, dir, to, step),
                        body)))
    end,

    _Every__PRE = function (me)
        local to, awt, Y, body = unpack(me)

        --[[
        --      every a=EXT do ... end
        -- becomes
        --      loop a=await EXT; ... end
        --]]

        local dcls = node('Stmts', me.ln)
        local set_awt
        if to then
            if awt.tag=='Await_Ext' or awt.tag=='Await_Int' then
                set_awt = node('Set_Await_many', me.ln, awt, to)
            else
                set_awt = node('Set_Await_one', me.ln, awt, to)
            end
        else
            set_awt = awt
        end

        return node('Every', me.ln,
                node('Loop', me.ln,
                    false,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            dcls,
                            set_awt,
                            Y,
                            body))))
    end,

-------------------------------------------------------------------------------

    _Set__PRE = function (me)
        local to,set = unpack(me)

        --  _Set
        --      to
        --      _Set_Watching
        --          _Watching
        --              Await_*
        --              Block
        -->>>
        --  _Watching
        --      _Set
        --          to
        --          _Set_Await_many
        --              Await_*
        --      Block
        if set.tag == '_Set_Watching' then
            local watching = AST.asr(unpack(set),'_Watching')
            local awt = unpack(watching)
            local tag do
                if awt.tag=='Await_Ext' or awt.tag=='Await_Int' then
                    tag = '_Set_Await_many'
                else
                    tag = '_Set_Await_one'
                end
            end
            AST.set(me, 2, node(tag, me.ln, awt))
            me[2].__adjs_is_watching = true
            AST.set(watching, 1, me)
            return watching

        elseif set.tag == '_Set_Await_many' then
            local unt = unpack(set)
            if unt.tag == 'Await_Until' then
                local awt = unpack(unt)
                AST.set(unt, 1, me)
                AST.set(set, 1, awt)
                return unt
            end
        end

        -----------------------------------------------------------------------

        if set.tag == '_Set_Do' then
            -- set to "to" happens on "escape"
            local do_ = unpack(set)
            AST.set(do_, #do_+1, to)
            return do_
        else
            --  _Set
            --      to
            --      _Set_*
            --          fr
            -->>>
            --  _Set_*
            --      fr
            --      to

            assert(#set==1 or #set==2, 'bug found')
            set.tag = string.sub(set.tag,2)
            AST.set(set, 2, to)

            -- a = &b   (Set_Exp->Set_Alias)
            if set.tag=='Set_Exp' and set[1].tag=='Exp_1&' then
                set.tag = 'Set_Alias'
            end

            return set
        end
    end,

    _Escape__PRE = function (me)
        local _, fr = unpack(me)

        local set = node('Set_Exp', me.ln,
                        fr,
                        node('TODO', me.ln, 'escape', me))   -- see dcls.lua
        -- a = &b   (Set_Exp->Set_Alias)
        if fr and fr.tag=='Exp_1&' then
            set.tag = 'Set_Alias'
        end

        me.tag = 'Escape'
        me[2] = nil
        return node('Stmts', me.ln, set, me)
    end,

    _Watching__PRE = function (me)
        local watch, block = unpack(me)

        -- watching Ff()->(), Gg()->(), ...
        if block.tag ~= 'Block' then
            return node('_Watching', me.ln, watch,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('_Watching', me.ln,
                                unpack(me,2)))))
        end

        return node('Watching', me.ln,
                node('Par_Or', me.ln,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            watch)),
                    block))
    end,
    _List_Var_Ref = function (me)
        me.tag = 'List_Var'
    end,

-------------------------------------------------------------------------------

    Vec_Cons__POS = function (me)
        local Set = AST.par(me,'Set_Abs_Val')
        if not Set then
            return
        end

        local T = { }

        local old = me
        local new = AST.par(me, 'Abs_Cons')

        while new do
            assert(AST.asr(new,'', 2,'Abslist', old.__i,'') == old)
            table.insert(T, 1, old.__i)
            old = new
            new = AST.par(new, 'Abs_Cons')
        end

        Set.__adjs_sets = Set.__adjs_sets or node('Stmts', me.ln)

        AST.insert(Set.__adjs_sets, #Set.__adjs_sets+1,
                    node('Set_Vec', me.ln,
                        me,                -- see dcls.lua
                        node('TODO', me.ln, 'vec_cons', T)))

        return node('ID_any', me.ln)
    end,

    Set_Abs_Val__POS = function (me)
        if me.__adjs_sets then
            local ret = node('Stmts', me.ln, me, me.__adjs_sets)
            me.__adjs_sets = nil
            return ret
        end
    end,

-------------------------------------------------------------------------------

--[=[
    _Async_Thread__PRE = function (me)
        me.tag = 'Async_Thread'
        return node('Stmts', me.ln,
                me,
                node('Async', me.ln,
                    node('VarList', me.ln),
                    node('Block', me.ln, node('Stmts', me.ln))))
                    --[[ HACK_2:
                    -- Include <async do end> after it to enforce terminating
                    -- from the main program.
                    --]]
    end,
]=]

-------------------------------------------------------------------------------

    _Lua_Do__PRE = function (me)
        me.tag = 'Lua_Do'
        return node('Block', me.ln,
                node('Stmts', me.ln,
                    node('Lua_Do_Open', me.ln, me.n),
                    node('Finalize', me.ln,
                        false,
                        false,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('Lua_Do_Close', me.ln, me.n)))),
                    me))
    end,

    _Lua = function (me)
        --[[
        -- a = @a ; b = @b
        --
        -- __ceu_1, __ceu_2 = ...
        -- a = __ceu_1 ; b = __ceu_2
        --]]
        local params = {}
        local code = {}
        local names = {}
        for _, v in ipairs(me) do
            if type(v) == 'table' then
                params[#params+1] = v
                code[#code+1] = '_ceu_'..#params
                names[#names+1] = code[#code]
            else
                code[#code+1] = v;
            end
        end

        -- me.ret:    node to assign result ("_Set_pre")
        -- me.params: @v1, @v2
        -- me.lua:    code as string

        if AST.par(me,'Set_Lua') or AST.par(me,'Set_Vec') then
           table.insert(code, 1, 'return')
        end

        me.params = params
        if #params == 0 then
            me.lua = table.concat(code,' ')
        else
            me.lua = table.concat(names,', ')..' = ...\n'..
                     table.concat(code,' ')
        end

        me.tag = 'Lua'
    end,

-------------------------------------------------------------------------------

    -- single declaration with multiple ids
    --      -> multiple declarations with single ids

    __dcls__PRE = function (me)
        local is_alias, dim, tp
        local tag = string.sub(me.tag,2,-2)
        local idx do
            if tag=='Pool' or tag=='Vec' then
                idx = 3
                is_alias, dim, tp = unpack(me)
            else
                idx = 2
                is_alias, tp = unpack(me)
            end
        end

        local ids = { unpack(me, idx+1) }
        local ret = node('Stmts', me.ln)
        for _,id in ipairs(ids) do
            if tag=='Pool' or tag=='Vec' then
                AST.set(ret, #ret+1,
                        node(tag, me.ln, is_alias, AST.copy(tp), id, AST.copy(dim)))
            else
                AST.set(ret, #ret+1,
                        node(tag, me.ln, is_alias, AST.copy(tp), id))
            end
        end
        return ret
    end,
    _Vars__PRE = '__dcls__PRE',
    _Vecs__PRE = '__dcls__PRE',
    _Pools__PRE = '__dcls__PRE',
    _Evts__PRE = function (me)
        local _,tp = unpack(me)
        if tp.tag == 'Type' then
            AST.set(me, 2, node('Typelist', me.ln, tp))
        end
        return F.__dcls__PRE(me)
    end,
    _Exts__PRE = function (me)
        local _,tp = unpack(me)
        if tp.tag == 'Type' then
            AST.set(me, 2, node('Typelist', me.ln, tp))
        end
        return F.__dcls__PRE(me)
    end,
    _Nats__PRE = function (me)
        AST.insert(me, 2,
            node('Type', me.ln,
                node('ID_prim', me.ln, '_')))
        return F.__dcls__PRE(me)
    end,

    __dcls_set__PRE = function (me, tag, idx)
        local is_alias, dim, tp, id
        local tag = string.sub(me.tag,2,-6)
        local idx do
            if tag=='Pool' or tag=='Vec' then
                idx = 3
                is_alias, dim, tp, id = unpack(me)
            else
                idx = 2
                is_alias, tp, id = unpack(me)
            end
        end

        local ret = node('Stmts', me.ln)
        local sets = { unpack(me, idx+1) }
        for i=1, #sets, 2 do
            local id, set = unpack(sets,i)

            if tag=='Pool' or tag=='Vec' then
                AST.set(ret, #ret+1,
                        node(tag, me.ln, is_alias, AST.copy(tp), id, AST.copy(dim)))
            else
                AST.set(ret, #ret+1,
                        node(tag, me.ln, is_alias, AST.copy(tp), id))
            end

            if set then
                local _,v = unpack(set)
                local to = node('Exp_Name', me.ln,
                            node('ID_int', me.ln, id))
                AST.set(ret, #ret+1,
                        node('_Set', me.ln, to, unpack(set)))
            end
        end
        return ret
    end,

    _Vars_set__PRE = '__dcls_set__PRE',
    _Vecs_set__PRE = '__dcls_set__PRE',
    _Pools_set__PRE = '__dcls_set__PRE',
    _Evts_set__PRE = function (me)
        local _,tp = unpack(me)
        if tp.tag == 'Type' then
            tp = node('Typelist', me.ln, tp)
        end
        return F.__dcls_set__PRE(me)
    end,

-------------------------------------------------------------------------------

    _Var_set_fin__PRE = function (me)
        local Type, __ID_int, Exp_Call = unpack(me)

        --  var & Type __ID_int = & Exp_Call finalize with ... end
        -->>>
        --  var & Type __ID_int;
        --  do
        --      ID_int = & Exp_Call;
        --  finalize with
        --      ...
        --  end

        return node('Stmts', me.ln,
                node('Var', me.ln,
                    '&?',
                    Type,
                    __ID_int),
                node('Finalize', me.ln,
                    node('Set_Alias', me.ln,
                        node('Exp_1&', Exp_Call.ln, '&',
                            Exp_Call),
                        node('Exp_Name', Type.ln,
                            node('ID_int', Type.ln, __ID_int))),
                    unpack(me,4)))
    end,

-------------------------------------------------------------------------------

    -- Type -> Typelist
    -- input int X  -> input (int) X;
    -- input void X -> input () X;
    Ext__PRE = 'Evt__PRE',
    Evt__PRE = function (me)
        local _,Type = unpack(me)
        if Type.tag == 'Type' then
            AST.set(me, 2, node('Typelist', me.ln, Type))
        end
    end,

    _Emit_ps__PRE = function (me)
        local exp = unpack(me)
        if exp and exp.tag == 'List_Exp' then
            return exp
        end
        local ret = node('List_Exp', me.ln)
        if exp then
            AST.set(ret, 1, exp)
        end
        return ret
    end,
    Exp_Call__PRE = function (me)
        local _,_, ps = unpack(me)
        if ps and ps.tag == 'List_Exp' then
            -- ok
        else
            AST.set(me, 3, node('List_Exp', me.ln))
            if ps then
                AST.set(me[3], 1, ps)
error'TODO: luacov never executes this?'
            end
        end
    end,

    Set_Await_many__PRE = function (me)
        local _,var,_ = unpack(me)
        if var.tag == 'Exp_Name' then
            AST.set(me, 2, node('List_Name', var.ln, var))
        end
    end,

    Typelist__PRE = function (me)
        local Type, snd = unpack(me)
        local ID_prim, mod = unpack(Type)
        if (not snd) and
           ID_prim.tag=='ID_prim' and ID_prim[1]=='void' and (not mod)
        then
            AST.remove(me,1)
        end
    end,

-------------------------------------------------------------------------------

    _Nat_Exp__PRE = function (me)
        return node('ID_nat', me.ln, '_{}', unpack(me))
    end,

    ['Exp_:__PRE'] = function (me)
        local op, e, field = unpack(me)
        return node('Exp_.', me.ln, '.',
                node('Exp_1*', me.ln, '*', e),
                field)
    end,

    NUMBER = function (me)
        local v = unpack(me)
        me[1] = ASR(tonumber(v), me, 'malformed number')
    end,
}

AST.visit(F)

end

    
do
TYPES = {
}

function TYPES.noc (str)
    str = string.gsub(str, '%.',  '__dot__')
    str = string.gsub(str, '%,',  '__comma__')
    str = string.gsub(str, '%?',  '__ask__')
    str = string.gsub(str, '%&&', '__ptr__')
    str = string.gsub(str, '%(',  '__lpar__')
    str = string.gsub(str, '%)',  '__rpar__')
    return str
end

function TYPES.n2uint (n)
    if n < 2^8 then
        return 'u8'
    elseif n < 2^16 then
        return 'u16'
    elseif n < 2^32 then
        return 'u32'
    end
    error'out of bounds'
end

local function types_id (tp)
    local ID = unpack(tp)
    local id = unpack(ID)
    return id
end

function TYPES.tostring (tp)
    if tp == true then
        return '*'
    elseif tp.tag == 'Typelist' then
        local ret = {}
        for i, tp in ipairs(tp) do
            ret[i] = TYPES.tostring(tp)
        end
        return '('..table.concat(ret,',')..')'
    end
    return types_id(tp) .. table.concat(tp,'',2)
end

function TYPES.dump (tp)
    DBG('TYPE', TYPES.tostring(tp))
end

function TYPES.toc (tp)
    assert(tp.tag == 'Type')
    local ID = unpack(tp)

    local pre = ''
    if TYPES.check(tp,'?') then
        pre = 'tceu_opt_'
    elseif ID.tag == 'ID_abs' then
        if ID.dcl.tag == 'Data' then
            pre = 'tceu_data_'
        else
            pre = 'tceu_code_mem_'
        end
    end

    local id = types_id(tp)
    id = string.gsub(id,'^_', '')
    id = TYPES.noc(id) -- data A.B -> A_B

    local mods = {}
    for i=2, #tp do
        local mod = tp[i]
        if mod == '&&' then
            if TYPES.check(tp,'?') then
                mod = '__ptr__'
            else
                mod = '*'
            end
        elseif mod == '?' then
            mod = ''
        end
        mods[i-1] = mod
    end

    return pre..id..table.concat(mods)
end

function TYPES.new (me, id, ...)
    local ID = (string.sub(id,1,1)==string.sub(string.upper(id),1,1) and
                'ID_abs' or 'ID_prim')
    return AST.node('Type', me.ln,
            AST.node(ID, me.ln,
                id),
            ...)
end

function TYPES.get (tp, n)
    assert(tp.tag == 'Type')
    tp = AST.copy(tp)
    for i=n+1, #tp do
        tp[i] = nil
    end
    return tp
end

function TYPES.pop (tp, mod)
    assert(tp.tag == 'Type')
    local v = tp[#tp]
    if mod and v~=mod then
        return tp
    end
    tp = AST.copy(tp)
    tp[#tp] = nil
    return tp
end

function TYPES.push (tp,v)
    assert(tp.tag == 'Type')
    tp = AST.copy(tp)
    tp[#tp+1] = v
    return tp
end

function TYPES.is_equal (tp1, tp2)
    assert(tp1.tag=='Type' and tp2.tag=='Type')
    if #tp1 ~= #tp2 then
        return false
    end
    for i=1, #tp1 do
        local v1, v2 = tp1[i], tp2[i]
        if i == 1 then
            v1, v2 = unpack(v1), unpack(v2)
        end
        if v1 ~= v2 then
            return false
        end
    end
    return true
end

function TYPES.check (tp, ...)
    if tp.tag == 'Typelist' then
        return false
    end
    assert(tp.tag == 'Type')

    local E = { ... }
    local j = 0
    for i=0, #E-1 do
        local J = #tp-j
        local v = tp[J]
        if J == 1 then
            assert(AST.is_node(v))
            v = unpack(v)
        end
        if v ~= E[#E-i] then
            return false
        end
        j = j + 1
    end
    return tp[#E]
end

function TYPES.is_num (tp)
    assert(tp.tag == 'Type')
    local blk = AST.asr(AST.root,'', 1,'Block')
    local dcl = DCLS.get(blk, types_id(tp), true)
    return TYPES.is_nat(tp)
        or dcl and (dcl.prim and dcl.prim.is_num and TYPES.check(tp,dcl.id))
end
function TYPES.is_int (tp)
    assert(tp.tag == 'Type')
    local blk = AST.asr(AST.root,'', 1,'Block')
    local dcl = DCLS.get(blk, types_id(tp), true)
    return TYPES.is_nat(tp)
        or dcl and (dcl.prim and dcl.prim.is_int and TYPES.check(tp,dcl.id))
end
function TYPES.is_nat (tp)
    assert(tp.tag == 'Type')
    local blk = AST.asr(AST.root,'', 1,'Block')
    local dcl = DCLS.get(blk, types_id(tp), true)
    return dcl and (dcl.tag=='Nat' or dcl.id=='_') and TYPES.check(tp,dcl.id)
        -- _char    yes
        -- _char&&  no
end
function TYPES.is_nat_plain (tp)
    assert(tp.tag == 'Type')
    if not TYPES.is_nat(tp) then
        return false
    end
    local ID_nat = AST.get(tp,'', 1,'ID_nat')
    if ID_nat then
        local mod = unpack(ID_nat.dcl)
        if mod == 'plain' then
            return true
        end
    end
    return false
end
function TYPES.is_nat_not_plain (tp)
    assert(tp.tag == 'Type')
    if not TYPES.is_nat(tp) then
        return false
    end
    local ID_nat = AST.get(tp,'', 1,'ID_nat')
    if ID_nat then
        local mod = unpack(ID_nat.dcl)
        if mod == 'plain' then
            return false
        end
    end
    return true
end

function TYPES.ID_plain (tp)
    return #tp==1 and tp[1]
end

function TYPES.abs_dcl (tp,kind)
    local ID = TYPES.ID_plain(tp)
    return ID and ID.dcl and ID.dcl.tag==kind and ID.dcl
end

do
    local __contains_num = {
        -- TODO: should 'int' be bottom?
        { 'f64','f32','float','int' },
        { 'u64','u32','u16','u8','int' },
        { 'usize','uint','int' },
        { 'ssize','int' },
        { 's64','s32','s16','s8','int' },
        { 'int','byte','int' },
    }
    local function contains_num (id1, id2)
        for _, t in ipairs(__contains_num) do
            for i=1,#t do
                local t1 = t[i]
                if t1 == id1 then
                    for j=i,#t do
                        local t2 = t[j]
                        if t2 == id2 then
                            return true
                        end
                    end
                end
            end
        end
        return false
    end

    local function contains_data (ID_abs_1, ID_abs_2)
        local id1 = unpack(ID_abs_1)
        local id2 = unpack(ID_abs_2)
        return (string.find(id2..'.',id1..'.',1,true) == 1)
    end

    function TYPES.contains (tp1, tp2, is_alias)
        if tp1 == true then
            return true
        end

        if tp1.tag=='Typelist' or tp2.tag=='Typelist' then
            if tp1.tag=='Typelist' and tp2.tag=='Typelist' then
                if #tp1 == #tp2 then
                    for i=1, #tp1 do
                        if not TYPES.contains(tp1[i],tp2[i],is_alias) then
                            return false
                        end
                    end
                    return true
                end
            end
            return false
        end

        if TYPES.check(tp1,'?') then
            tp1 = TYPES.pop(tp1)
            if TYPES.check(tp2,'?') then
                tp2 = TYPES.pop(tp2)
            end
        end

        local tp1_is_nat = TYPES.is_nat(tp1)
        local tp2_is_nat = TYPES.is_nat(tp2)

        local tp1_ID = TYPES.ID_plain(tp1)
        local tp2_ID = TYPES.ID_plain(tp2)

-- EQUAL TYPES
        if TYPES.is_equal(tp1, tp2) then
            return true

-- DATA vs DATA
        elseif tp1_ID and tp1_ID.tag=='ID_abs' and
               tp2_ID and tp2_ID.tag=='ID_abs'
        then
            return contains_data(tp1_ID, tp2_ID)

-- VOID <- _
        -- var& void ptr = &_f()
        -- var& void p = &v;
        elseif TYPES.check(tp1,'void') and tp2_ID then
            return true

-- NUMERIC TYPES
        elseif TYPES.is_num(tp1) and TYPES.is_num(tp2) then
            if TYPES.is_nat(tp1) or TYPES.is_nat(tp2) then
                return true
            elseif is_alias then
                return false
            else
                return contains_num(types_id(tp1),types_id(tp2))
            end

-- POINTER TYPES
        elseif (TYPES.check(tp1,'&&') or tp1_is_nat) and
               (TYPES.check(tp2,'&&') or tp2_is_nat)
        then
            if not tp1_is_nat then
                tp1 = TYPES.pop(tp1)
            end
            if not tp2_is_nat then
                tp2 = TYPES.pop(tp2)
            end
            if TYPES.check(tp1,'void') then
                -- void&& <- ?&&
                return true
            elseif TYPES.check(tp2,'null') then
                -- ?&& <- null
                return true
            elseif tp1_is_nat then
                -- _ <- ?&&
                return true
            elseif TYPES.contains(tp1,tp2) then
                return true
            end
        end
        return false
    end

    function TYPES.max (tp1, tp2)
        if TYPES.contains(tp1, tp2) then
            return tp1
        elseif TYPES.contains(tp2, tp1) then
            return tp2
        else
            return nil
        end
    end
end

end

    
do
DCLS = {
}

local function iter_boundary (cur, id, can_cross)
    return function ()
        while cur do
            local c = cur
            cur = cur.__par
            if c.tag == 'Block' then
                return c
            elseif can_cross then
                -- continue
            elseif string.sub(c.tag,1,5)=='Async' then
                -- see if varlist matches id to can_cross the boundary
                -- async (a,b,c) do ... end
                local can_cross2 = false

                local varlist,_
                if c.tag == 'Async_Isr' then
                    _,varlist = unpack(c)
                else
                    _,varlist = unpack(c)
                end

                if varlist then
                    for _, ID_int in ipairs(varlist) do
                        if ID_int[1] == id then
                            can_cross2 = true
                            break
                        end
                    end
                end
                if not can_cross2 then
                    return nil
                end
            elseif c.tag=='Data' or c.tag=='Code' or
                   c.tag=='Ext_Code' or c.tag=='Ext_Req'
            then
                return nil
            end
        end
    end
end

function DCLS.get (blk, id, can_cross)
    AST.asr(blk, 'Block')
    for blk in iter_boundary(blk,id,can_cross) do
        local dcl = blk.dcls[id]
        if dcl then
            dcl.is_used = true
            return dcl
        end
    end
    return nil
end

function DCLS.asr (me, blk_or_data, id, can_cross, err)
    local data = AST.get(blk_or_data, 'Data')
    local blk = (data and AST.asr(data,'',3,'Block')) or blk_or_data
    local ret = DCLS.get(blk, id, can_cross)
    if ret then
        return ret
    else
        if data then
            ASR(false, me, 
                'invalid member access : "'..
                err..  '" has no member "'..id..'" : '..
                '`data´ "'..data.id..
                '" ('..data.ln[1]..':'..  data.ln[2]..')')
        else
            local par = AST.par(me,'Code')
            if par and par[3]==id then
                return par
            else
                ASR(false, me,
                    err..' "'..id..'" is not declared')
            end
        end
    end
end

local function dcls_new (blk, me, can_cross)
    AST.asr(blk, 'Block')

    local old = DCLS.get(blk, me.id, can_cross)
    local implicit = (me.is_implicit and 'implicit ') or ''
    if old and (not old.is_predefined) then
        local F do
            if me.tag=='Nat'      or me.tag=='Ext' or
               me.tag=='Ext_Code' or me.tag=='Ext_Req'
            then
                F = ASR
            else
                F = WRN
            end
        end
        me.__dcls_dup = true
        F(false, me, old and
            implicit..'declaration of "'..me.id..'" hides previous declaration'..
                ' ('..old.ln[1]..' : line '..old.ln[2]..')')
    end

    blk.dcls[#blk.dcls+1] = me
    blk.dcls[me.id] = me
    me.blk = blk
    return me
end

function DCLS.is_super (super, sub)
    assert(super.hier and sub.hier)
    if super == sub then
        return true
    elseif sub.hier.up then
        return DCLS.is_super(super, sub.hier.up)
    else
        return false
    end
end

function DCLS.base (data)
    assert(data.hier)
    if data.hier.up then
        return DCLS.base(data.hier.up)
    else
        return data
    end
end

-- native declarations are allowed until `native/end´
local native_end = false

F = {
    -- Primitive types: id / is_num
    __prims = function (blk)
        local prims = {
            bool  = { is_num=false, is_int=false },
            byte  = { is_num=true,  is_int=true  },
            f32   = { is_num=true,  is_int=false },
            f64   = { is_num=true,  is_int=false },
            float = { is_num=true,  is_int=false },
            int   = { is_num=true,  is_int=true  },
            s16   = { is_num=true,  is_int=true  },
            s32   = { is_num=true,  is_int=true  },
            s64   = { is_num=true,  is_int=true  },
            s8    = { is_num=true,  is_int=true  },
            ssize = { is_num=true,  is_int=true  },
            u16   = { is_num=true,  is_int=true  },
            u32   = { is_num=true,  is_int=true  },
            u64   = { is_num=true,  is_int=true  },
            u8    = { is_num=true,  is_int=true  },
            uint  = { is_num=true,  is_int=true  },
            usize = { is_num=true,  is_int=true  },
            void  = { is_num=false, is_int=false },
            null  = { is_num=false, is_int=false },
            _     = { is_num=true,  is_int=true  },
        }
        for id, t in pairs(prims) do
            dcls_new(blk, {
                            tag   = 'Prim',
                            id    = id,
                            prim  = t,
                            is_used = true,
                          })
        end
    end,
    Block__PRE = function (me)
        me.dcls = {}
        if F.__prims then
            F.__prims(me)
            F.__prims = nil
        end
    end,
    Block__POS = function (me)
        if AST.par(me,'Data') then
            return
        end
        local Code = AST.par(me,'Code')
        if Code and ((not Code.is_impl) or Code.is_dyn_base) then
            return
        end

        for _, dcl in pairs(me.dcls) do
            if dcl.tag=='Data' and string.sub(dcl.id,1,1)=='_' then
                -- auto generated
            else
                local f = WRN
                if CEU.opts.ceu_err_unused then
                    f = ASR_WRN_PASS(CEU.opts.ceu_err_unused)
                end
                if dcl.tag=='Nat' and CEU.opts.ceu_err_unused_native then
                    f = ASR_WRN_PASS(CEU.opts.ceu_err_unused_native)
                elseif dcl.tag=='Code' and CEU.opts.ceu_err_unused_code then
                    f = ASR_WRN_PASS(CEU.opts.ceu_err_unused_code)
                end
                f(dcl.is_used or dcl.is_predefined, dcl,
                  AST.tag2id[dcl.tag]..' "'..dcl.id..'" declared but not used')
            end
        end
    end,
    __pass = function () end,

    ---------------------------------------------------------------------------

-- NEW

    -- LOC

    __no_abs = function (tp, no_what)
        local ID = unpack(tp)
        if ID.tag == 'ID_abs' then
            ASR(no_what and ID.dcl.tag~=no_what, tp,
                'invalid declaration : unexpected context for `code´ "'..
                    (ID.dcl.id or ID.dcl[3])..'"')
        end
    end,

    Var = function (me)
        local alias,Type,id = unpack(me)
        me.id = id
        dcls_new(AST.par(me,'Block'), me)
        F.__no_abs(Type, 'Code')

        if alias == '&?' then
            me.is_read_only = true
            ASR(not TYPES.check(Type,'?'), me,
                'invalid declaration : option type : not implemented')
        end

        if alias then
            -- NO: alias to pointer
            --  var& int&& x = ...;
            ASR(not TYPES.check(Type,'&&'), me,
                'invalid declaration : unexpected `&&´ : cannot alias a pointer')
        end

        local ID_prim,mod = unpack(Type)
        if ID_prim.tag=='ID_prim' and ID_prim[1]=='void' and (not mod) then
            ASR(alias, me,
                'invalid declaration : variable cannot be of type `void´') 
        end
    end,

    Vec = function (me)
        local is_alias,Type,id,dim = unpack(me)
        me.id = id
        dcls_new(AST.par(me,'Block'), me)
        F.__no_abs(Type, 'Code')

        -- vector[] void vec;
        local ID_prim,mod = unpack(Type)
        if ID_prim.tag=='ID_prim' and ID_prim[1]=='void' and (not mod) then
            ASR(false, me,
                'invalid declaration : vector cannot be of type `void´') 
        end
    end,

    Pool = function (me)
        local _,_,id,_ = unpack(me)
        me.id = id
        dcls_new(AST.par(me,'Block'), me)
    end,

    Evt = function (me)
        local _,Typelist,id = unpack(me)
        me.id = id

        -- no modifiers allowed
        for _, Type in ipairs(Typelist) do
            F.__no_abs(Type)

            local id, mod = unpack(Type)
            assert(id.dcl,'bug found')
            ASR(id.dcl.tag=='Prim' or TYPES.is_nat_plain(Type), me,
                'invalid event type : must be primitive')
            ASR(not mod, me,
                mod and 'invalid event type : cannot use `'..mod..'´')
        end

        dcls_new(AST.par(me,'Block'), me)
    end,

    -- NATIVE

    Nat_End = function (me)
        native_end = true
    end,
    Nat__PRE = function (me)
        local mod,_,id = unpack(me)
        me.id = id
        me.is_read_only = (mod == 'const')
        local blk = AST.asr(AST.root,'', 1,'Block')
        dcls_new(blk, me)

        ASR(not native_end, me,
            'native declarations are disabled')

        if id=='_{}' or id=='_char' then
            me.is_predefined = true
        end
    end,

    -- EXT

    Ext = function (me)
        local _, _, id = unpack(me)
        me.id = id
        local blk = AST.asr(AST.root,'', 1,'Block')
        dcls_new(blk, me)
    end,

    Ext_Code = 'Code',

    -- CODE / DATA

    Code_Pars = function (me)
        local Code = AST.asr(me,4,'Code')
        local _,mods = unpack(Code)

        -- check types only
        do
            local tps = AST.node('Typelist',me.ln)
            for i, dcl in ipairs(me) do
                tps[i] = dcl[2]
            end
            F.Typelist(tps)
        end

        -- check if all mid's are "&" aliases
        if AST.asr(me,1,'Stmts')[2] == me then
            for i, dcl in ipairs(me) do
                local is_alias, Type = unpack(dcl)
                ASR(is_alias, dcl,
                    'invalid `code´ declaration : `watching´ parameter #'..i..' : expected `&´')
assert(dcl.tag=='Var' or dcl.tag=='Vec' or dcl.tag=='Evt', 'TODO')
            end
        end

        -- multi-methods: changes "me.id" on Code
        me.ids_dyn = ''
        for i, dcl in ipairs(me) do
            if dcl.mods.dynamic then
                local is_alias,Type = unpack(dcl)
                ASR(dcl.tag~='Evt' and Type[1].tag=='ID_abs' and
                    (is_alias or Type[2]), me,
                    'invalid `dynamic´ declaration : parameter #'..i..
                    ' : unexpected plain `data´')
                dcl.id_dyn = '_'..i..'_'..dcl.tag..
                             '_'..(is_alias and 'y' or 'n')..
                             '_'..TYPES.tostring(Type)
                dcl.id_dyn = TYPES.noc(dcl.id_dyn)
                me.ids_dyn = me.ids_dyn..dcl.id_dyn
            end
        end

        if mods.dynamic and #me>0 then
            ASR(me.ids_dyn ~= '', me,
                'invalid `dynamic´ declaration : expected dynamic parameters')
        end
    end,

    -- detect "base" dynamic multimethod: create dummy copy with plain "id"
    Code__PRE = function (me)
        local _,mods,id = unpack(me)
        if not mods.dynamic then
            return  -- not dynamic code
        end

        local old = DCLS.get(AST.par(me,'Block'), id)
        if old then
            return  -- not first appearence
        end

        if me.is_dyn_base then
            return  -- not first appearence
        end

        if not me.is_impl then
            -- "base" method with plain "id"
            me.id = id
            me.is_dyn_base = true
            return
        end

        local proto_body = AST.asr(me,'', 4,'Block', 1,'Stmts')
        local orig = proto_body[2]
        AST.set(proto_body, 2, AST.node('Stmts', me.ln))
        local new = AST.copy(me)
        AST.set(proto_body, 2, orig)

        -- "base" method with plain "id"
        new.id = id
        new.is_dyn_base = true

        local s = AST.node('Stmts', me.ln, new, me)
        return s
    end,

    __proto_ignore = function (id1, id2)
        return (type(id1)=='string' and string.sub(id1,1,6)=='_anon_')
            or (type(id2)=='string' and string.sub(id2,1,6)=='_anon_')
    end,

    Code = function (me)
        local _,mods1,id,body1 = unpack(me)

        ASR(not AST.par(me,'Code'), me,
            'invalid `code´ declaration : nesting is not allowed')

        local blk = AST.par(me, 'Block')

        if not me.is_dyn_base then
            if mods1.dynamic and me.is_impl then
                local ins1 = AST.asr(body1,'Block', 1,'Stmts', 1,'Stmts', 1,'Code_Pars')
                me.id = id..ins1.ids_dyn
                me.dyn_base = DCLS.asr(me,blk,id)
                me.dyn_base.dyn_last = me
            else
                me.id = id
            end
        end

        local old = DCLS.get(blk, me.id)
        if old then
            local _,mods2,_,body2 = unpack(old)
            if me.is_impl then
                ASR(not (old.is_impl or old.__impl), me,
                    'invalid `code´ declaration : body for "'..id..'" already exists')
                old.__impl = true
            end

            -- compare ins
            local proto1 = AST.asr(body1,'Block',1,'Stmts',1,'Stmts')
            local proto2 = AST.asr(body2,'Block',1,'Stmts',1,'Stmts')
            local ok = AST.is_equal(proto1, proto2, F.__proto_ignore)

            -- compare mods
            do
                for k,v in pairs(mods1) do
                    if mods2[k] ~= v then
                        ok = false
                        break
                    end
                end
                for k,v in pairs(mods2) do
                    if mods1[k] ~= v then
                        ok = false
                        break
                    end
                end
            end

            ASR(ok, me,
                'invalid `code´ declaration : unmatching prototypes '..
                '(vs. '..proto1.ln[1]..':'..proto2.ln[2]..')')
        else
            blk.dcls[me.id] = me
            assert(me == DCLS.get(blk,me.id))

            if not mods1.dynamic then
                blk.dcls[id] = me
                assert(me == DCLS.get(blk,id))
            end
        end
        me.is_used = (old and old.is_used)
                        or (mods1.dynamic and (not me.is_dyn_base))
    end,

    Data__PRE = function (me)
        local id, num, blk = unpack(me)
        me.id = id
        local par = AST.par(me, 'Block')

        -- check "super" path
        local super,_ = string.match(me.id, '(.*)%.(.*)')
        if super then
            local dcl = DCLS.get(par, super, true)
            ASR(dcl, me,
                'invalid declaration : abstraction "'..super..'" is not declared')
            dcl.hier = dcl.hier or { down={} }
            dcl.hier.down[#dcl.hier.down+1] = me
            me.hier = { up=dcl, down={} }

            -- copy all super vars to myself
            -- (avoid inserting empty additional Stmts to break "empty-data-dcl" detection)
            local vars = AST.asr(dcl,'', 3,'Block', 1,'Stmts')
            if #vars > 0 then
                AST.insert(AST.asr(me,'',3,'Block',1,'Stmts'), 1,
                           AST.copy(vars))
            end
        end

        dcls_new(par, me)
    end,

    Data = function (me)
        me.weaker = 'plain'
        for _, dcl in ipairs(AST.asr(me,'',3,'Block').dcls) do
            local is_alias, tp = unpack(dcl)
            if TYPES.check(tp,'&&') then
                me.weaker = 'pointer'
                break   -- can't be worse
            elseif is_alias then
                me.weaker = 'alias'
            else
                local ID = TYPES.ID_plain(tp)
                if ID and ID.tag=='ID_abs' and ID.dcl.tag=='Data' then
                    if ID.dcl.weaker == 'pointer' then
                        me.weaker = 'pointer'
                        break   -- can't be worse
                    elseif ID.dcl.weaker == 'alias' then
                        me.weaker = 'alias'
                    end
                end
            end
        end
    end,

    -- Typelists

    Typelist = function (me)
        if #me == 1 then
            return
        end
        for _, Type in ipairs(me) do
            if Type.tag == 'Type' then
                local ID_prim,mod = unpack(Type)
                if ID_prim.tag=='ID_prim' and ID_prim[1]=='void' and (not mod) then
                    ASR(false, me,
                        'invalid declaration : unexpected type `void´')
                end
            end
        end
    end,

    ---------------------------------------------------------------------------

-- GET: ID -> DCL

    ID_prim = function (me)
        local id = unpack(me)
        me.dcl = DCLS.asr(me, AST.par(me,'Block'), id, true, 'primitive identifier')
    end,

    ID_nat = function (me)
        local id = unpack(me)
        me.dcl = DCLS.asr(me, AST.par(me,'Block'), id, true, 'native identifier')
    end,

    ID_ext = function (me)
        local id = unpack(me)
        me.dcl = DCLS.asr(me, AST.par(me,'Block'), id, true, 'external identifier')
    end,

    ID_abs = function (me)
        local id = unpack(me)

        -- search outside current "code/data"
        local code_or_data = AST.par(me,'Code') or AST.par(me,'Data')
        local blk = (code_or_data and AST.par(code_or_data,'Block'))
                        or AST.par(me,'Block')

        me.dcl = DCLS.asr(me, blk, id, false, 'abstraction')
    end,

    ID_int = function (me)
        local id = unpack(me)
        local blk = AST.par(me, 'Block')
        do
            -- escape should refer to the parent "a"
            -- var int a = do var int a; ... escape ...; end;
            local set = AST.par(me,'Set_Exp')
            if set and set.__dcls_is_escape then
                blk = AST.par(blk, 'Block')
            end
        end
        me.dcl = DCLS.asr(me, blk, id, false, 'internal identifier')
    end,

    ['Exp_.'] = function (me)
        local _, e, member = unpack(me)
        if e.tag == 'Outer' then
            local Code = ASR(AST.par(me,'Code'), me,
                            'invalid `outer´ : expected enclosing `code´ declaration')
            me.dcl = DCLS.asr(me, AST.par(Code,'Block'),
                              member, false, 'internal identifier')
        end
    end,

    ---------------------------------------------------------------------------

    Loop_Num = function (me)
        local _, i = unpack(me)
        i.dcl.is_read_only = true
    end,

    __loop = function (me)
        return me.tag=='Loop' or me.tag=='Loop_Num' or me.tag=='Loop_Pool'
    end,
    __outer = function (me)
        local lbl = unpack(me)
        for loop in AST.iter(F.__loop) do
            if not lbl then
                return loop
            else
                local _, id = unpack(loop)
                if id and id.dcl==lbl.dcl then
                    return loop
                end
            end
        end
    end,
    Break = function (me)
        me.outer = F.__outer(me)
        ASR(me.outer, me,
            'invalid `break´ : expected matching enclosing `loop´')
    end,
    Continue = function (me)
        me.outer = F.__outer(me)
        ASR(me.outer, me,
            'invalid `continue´ : expected matching enclosing `loop´')
    end,

    TODO__POS = function (me)
        local id = unpack(me)
        if id == 'escape' then
            local _, esc = unpack(me)
            local id_int1 = (esc[1]==true) or esc[1][1]
            local do_ = nil
            for n in AST.iter() do
                if string.sub(n.tag,1,5)=='Async' or
                   n.tag=='Data'  or n.tag=='Code' or
                   n.tag=='Ext_Code_impl' or n.tag=='Ext_Req_impl'
                then
                    break
                end
                if n.tag == 'Do' then
                    local id_int2 = (n[1]==true) or n[1][1]
                    if id_int1 == id_int2 then
                        do_ = n
                        break
                    end
                end
            end
            ASR(do_, esc, 'invalid `escape´ : no matching enclosing `do´')
            esc.outer = do_
            local _,_,to = unpack(do_)
            local set = AST.get(me.__par,'Set_Exp') or AST.asr(me.__par,'Set_Alias')
            set.__dcls_is_escape = true
            local fr = unpack(set)
            if to and type(to)~='boolean' then
                ASR(type(fr)~='boolean', me,
                    'invalid `escape´ : expected expression')
                to.__dcls_is_escape = true
                return AST.copy(to)
            else
                ASR(type(fr)=='boolean', me,
                    'invalid `escape´ : unexpected expression')
                set.tag = 'Nothing'
                return AST.node('Nothing', me.ln)
            end
        elseif id == 'vec_cons' then
            local _, T = unpack(me)
            local ID_int = AST.asr(me.__par.__par.__par,'Stmts',
                                   1,'Set_Abs_Val', 2,'Exp_Name', 1,'ID_int')
            local abs = TYPES.abs_dcl(ID_int.dcl[2], 'Data')
            ASR(abs, me, 'invalid constructor : TODO')
            local vars = AST.asr(abs,'Data', 3,'Block').dcls

            local ret = AST.copy(ID_int)
            for i, I in ipairs(T) do
                local _,tp,id = unpack(vars[I])
                ret = AST.node('Exp_.', me.ln, '.', ret, id)
                if i < #T then
                    local abs = TYPES.abs_dcl(tp, 'Data')
                    ASR(abs, me, 'invalid constructor : TODO')
                    vars = AST.asr(abs,'Data', 3,'Block').dcls
                end
            end

            return AST.node('Exp_Name', me.ln, ret)
        else
            error'bug found'
        end
    end,
}

AST.visit(F)

end

    
do
INFO = {
}

function INFO.asr_tag (e, cnds, err_msg)
    ASR(e.info, e, err_msg..' : expected name expression')
    --assert(e.info.obj.tag ~= 'Val')
    local ok do
        for _, tag in ipairs(cnds) do
            if tag == e.info.tag then
                ok = true
                break
            end
        end
    end
    ASR(ok, e, err_msg..' : '..
                'unexpected context for '..AST.tag2id[e.info.tag]
                                         ..' "'..e.info.id..'"')
end

function INFO.copy (old)
    local new = {}
    for k,v in pairs(old) do
        new[k] = v
    end
    return new
end

function INFO.new (me, tag, id, tp, ...)
    if AST.is_node(tp) and (tp.tag=='Type' or tp.tag=='Typelist') then
        assert(not ...)
    else
        assert(type(tp) == 'string')
        tp = TYPES.new(me, tp, ...)
    end
    return {
        id  = id or 'unknown',
        tag = tag,
        tp  = tp,
        --dcl
    }
end

F = {
-- IDs

    ID_nat = function (me)
        local id = unpack(me)
        me.info = {
            id  = id,
            tag = me.dcl.tag,
            tp  = me.dcl[2],
            dcl = me.dcl,
        }
    end,

    ID_int = function (me)
        local id = unpack(me)
        me.info = {
            id  = id,
            tag = me.dcl.tag,
            tp  = me.dcl[2],
            dcl = me.dcl,
        }
    end,

-- TYPECAST: as

    Exp_as = function (me)
        local op,e,Type = unpack(me)
        if not e.info then return end   -- see EXPS below

        -- ctx
        INFO.asr_tag(e, {'Alias','Val','Nat','Var','Pool'},
                     'invalid operand to `'..op..'´')

        -- tp
        ASR(not TYPES.check(e.info.tp,'?'), me,
            'invalid operand to `'..op..'´ : unexpected option type : got "'..
            TYPES.tostring(e.info.tp)..'"')

        local plain = TYPES.ID_plain(e.info.tp)
        if plain and plain.dcl and plain.dcl.tag=='Data' then
            if TYPES.check(Type,'int') then
                -- OK: "d as int"
            else
                -- NO:
                --  var Dx d = ...;
                --  (d as Ex)...
                local is_alias = unpack(e.info.dcl)
                ASR(is_alias, me,
                    'invalid operand to `'..op..'´ : unexpected plain `data´ : got "'..
                    TYPES.tostring(e.info.tp)..'"')

                -- NO:
                --  var Dx& d = ...;
                --  (d as Ex)...        // "Ex" is not a subtype of Dx
                -- YES:
                --  var Dx& d = ...;
                --  (d as Dx.Sub)...
                local cast = TYPES.ID_plain(Type)
                if cast and cast.dcl and cast.dcl.tag=='Data' then
                    local ok = cast.dcl.hier and plain.dcl.hier and
                                (DCLS.is_super(cast.dcl,plain.dcl) or
                                 DCLS.is_super(plain.dcl,cast.dcl))
                    ASR(ok, me,
                        'invalid operand to `'..op..'´ : unmatching `data´ abstractions')
                end
            end
        end

        -- info
        me.info = INFO.copy(e.info)
        if AST.is_node(Type) then
            me.info.tp = AST.copy(Type)
        else
            -- annotation (/plain, etc)
DBG'TODO: type annotation'
        end
    end,

-- OPTION: !

    ['Exp_!'] = function (me)
        local op,e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var','Evt'}, 'invalid operand to `'..op..'´')

        -- tp
        ASR((e.info.dcl[1]=='&?') or TYPES.check(e.info.tp,'?'), me,
            'invalid operand to `'..op..'´ : expected option type : got "'..
            TYPES.tostring(e.info.tp)..'"')

        -- info
        me.info = INFO.copy(e.info)
        if e.info.dcl[1] == '&?' then
            me.info.dcl = AST.copy(e.info.dcl,nil,true)
            me.info.dcl[1] = '&'
            me.info.dcl.orig = e.info.dcl.orig or e.info.dcl   -- TODO: HACK_3
        else
            me.info.tp = TYPES.pop(e.info.tp)
        end
    end,

-- INDEX

    ['Exp_idx'] = function (me)
        local _,vec,idx = unpack(me)

        -- ctx, tp

        local tp = AST.copy(vec.info.tp)
        tp[2] = nil
        if (vec.info.tag=='Var' or vec.info.tag=='Nat') and TYPES.is_nat(tp) then
            -- _V[0][0]
            -- var _char&&&& argv; argv[1][0]
            -- v[1]._plain[0]
            INFO.asr_tag(vec, {'Nat','Var'}, 'invalid vector')
        else
            INFO.asr_tag(vec, {'Vec'}, 'invalid vector')
        end

        -- info
        me.info = INFO.copy(vec.info)
        me.info.tag = 'Var'
        if vec.info.tag=='Var' and TYPES.check(vec.info.tp,'&&') then
            me.info.tp = TYPES.pop(vec.info.tp)
        end
    end,

-- PTR: *

    ['Exp_1*'] = function (me)
        local op,e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var','Pool'}, 'invalid operand to `'..op..'´')
--DBG('TODO: remove pool')

        -- tp
        local _,mod = unpack(e.info.tp)
        local is_ptr = TYPES.check(e.info.tp,'&&')
        local is_nat_ptr = TYPES.is_nat_not_plain(e.info.tp)
        ASR(is_ptr or is_nat_ptr, me,
            'invalid operand to `'..op..'´ : expected pointer type : got "'..
            TYPES.tostring(e.info.tp)..'"')

        -- info
        me.info = INFO.copy(e.info)
        if is_ptr then
            me.info.tp = TYPES.pop(e.info.tp)
        end
    end,

-- MEMBER: .

    ['Exp_.'] = function (me)
        local _, e, member = unpack(me)

        if e.tag == 'Outer' then
            F.ID_int(me)
            me.info.id = 'outer.'..member
        else
            ASR(TYPES.ID_plain(e.info.tp), me,
                'invalid operand to `.´ : expected plain type : got "'..
                TYPES.tostring(e.info.tp)..'"')

            local ID_abs = unpack(e.info.tp)
            if ID_abs and ID_abs.dcl.tag=='Data' then
                -- data.member
                local data = AST.asr(ID_abs.dcl,'Data')
                local Dcl = DCLS.asr(me,data,member,false,e.info.id)
                me.info = {
                    id  = e.info.id..'.'..member,
                    tag = Dcl.tag,
                    tp  = Dcl[2],
                    dcl = Dcl,
                    dcl_obj = e.info.dcl,
                }
            else
                me.info = INFO.copy(e.info)
                me.info.id = e.info.id..'.'..member
            end
        end
    end,

-- VECTOR LENGTH: $

    ['Exp_$'] = function (me)
        local op,vec = unpack(me)

        -- ctx
        INFO.asr_tag(vec, {'Vec'}, 'invalid operand to `'..op..'´')

        -- tp
        -- any

        -- info
        me.info = INFO.copy(vec.info)
        me.info.tp = TYPES.new(me, 'usize')
        me.info.tag = 'Var'
    end,
}

AST.visit(F)

end

    
do
EXPS = {}

function EXPS.check_tp (me, to_tp, fr_tp, err_msg, is_alias)
    local to_str = TYPES.tostring(to_tp)
    local fr_str = TYPES.tostring(fr_tp)
    ASR(TYPES.contains(to_tp,fr_tp,is_alias), me,
        err_msg..' : types mismatch : "'..to_str..'" <= "'..fr_str..'"')
end

function EXPS.check_tag (me, to_tag, fr_tag, err_msg)
    ASR(to_tag==fr_tag or (to_tag=='Var' and (fr_tag=='Val' or fr_tag=='Nat')), me,
        err_msg..' : types mismatch : "'..to_tag..'" <= "'..fr_tag..'"')
end

function EXPS.check_dim (to, fr)
    if to == '[]' then
        return true
    elseif AST.is_equal(fr,to) then
        return true
    else
        return false
    end
end

local F_Exp_as  = F.Exp_as
local F_Exp_len = F['Exp_$']

F = {
    Exp_Name = function (me)
        local e = unpack(me)
        me.info = e.info
    end,
    ID_int = function (me)
        if me.dcl.is_mid_idx then
            local Set_Alias = AST.get(me.__par.__par,'Set_Alias')
            local ok = Set_Alias and AST.get(Set_Alias,'',2,'Exp_Name',1,'ID_int')==me
            ok = ok or AST.par(me, 'List_Var')
            ASR(ok, me, 'invalid access to output variable "'..me.dcl.id..'"')
        end
    end,

-- PRIMITIVES

    NULL = function (me)
        me.info = INFO.new(me, 'Val', 'null', 'null', '&&')
    end,

    NUMBER = function (me)
        local v = unpack(me)
        if math.type(tonumber(v)) == 'float' then
            me.info = INFO.new(me, 'Val', v, 'float')
        else
            me.info = INFO.new(me, 'Val', v, 'int')
        end
    end,

    BOOL = function (me)
        me.info = INFO.new(me, 'Val', me[1], 'bool')
    end,

    STRING = function (me)
        me.info = INFO.new(me, 'Val', me[1], '_char', '&&')
    end,

-- SIZEOF

    SIZEOF = function (me)
        local e = unpack(me)

        -- ctx
        if e.tag ~= 'Type' then
            if e.info.dcl.tag~='Evt' and TYPES.is_nat(TYPES.get(e.info.tp,1)) then
                INFO.asr_tag(e, {'Val','Nat','Var','Vec'}, 'invalid operand to `sizeof´')
            else
                INFO.asr_tag(e, {'Val','Nat','Var'}, 'invalid operand to `sizeof´')
            end
        end

        -- tp
        -- any

        -- info
        me.info = INFO.new(me, 'Val', nil, 'usize')
    end,

-- CALL

    Exp_Call = function (me)
        local _, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var'}, 'invalid call')

        -- tp
        ASR(TYPES.is_nat(e.info.tp),
            'invalid call : expected native type')

        -- info
        me.info = e.info
    end,

    Abs_Call = function (me)
        local ID_abs = AST.asr(me,'', 2,'Abs_Cons', 1,'ID_abs')
        local _,mods_dcl  = unpack(ID_abs.dcl)
        local mods_call = unpack(me)

        if mods_dcl.dynamic then
            ASR(mods_call.dynamic or mods_call.static, me,
                'invalid call : expected `/dynamic´ or `/static´ modifier')
        else
            local mod = (mods_call.dynamic or mods_call.static)
            ASR(not mod, me, mod and
                'invalid call : unexpected `/'..mod..'´ modifier')
        end

        -- ctx
        ASR(ID_abs.dcl.tag=='Code', me,
                'invalid call : '..
                'unexpected context for '..AST.tag2id[ID_abs.dcl.tag]
                                         ..' "'..ID_abs.dcl.id..'"')
        ASR(mods_dcl.tight, me,
                'invalid call : '..
                'expected `code/tight´ : got `code/await´ ('..ID_abs.dcl.ln[1]..':'..ID_abs.ln[2]..')')

        -- info
        me.info = INFO.new(me, 'Val', nil,
                    AST.copy(AST.asr(ID_abs.dcl,'Code', 4,'Block', 1,'Stmts',
                                                        1,'Stmts', 3,'',
                                                                    -- TODO: HACK_5
                                                        2,'Type')))
    end,

    Abs_Cons = function (me)
        local ID_abs, Abslist = unpack(me)

        local err_str
        if ID_abs.dcl.tag == 'Data' then
            me.vars = AST.asr(ID_abs.dcl,'Data', 3,'Block').dcls
            err_str = 'invalid constructor'
        else
            me.vars = AST.asr(ID_abs.dcl,'Code', 4,'Block', 1,'Stmts',
                                                 1,'Stmts', 1,'Code_Pars')
            err_str = 'invalid call'
        end
        ASR(#me.vars == #Abslist, me, err_str..' : expected '..#me.vars..' argument(s)')

        -- check if dyn call is actually static (with "as")
        me.id = ID_abs.dcl.id
        local mods = (ID_abs.dcl.tag=='Code' and ID_abs.dcl[2])
        local is_dyn do
            if mods and mods.dynamic then
                is_dyn = false
            end
        end

        for i=1, #me.vars do
            local var = me.vars[i]
            local val = Abslist[i]

            local var_is_alias, var_tp, var_id, var_dim = unpack(var)

            if mods and mods.dynamic and var_tp[1].dcl.hier and (not is_dyn) then
                if var_tp.tag=='Type' and var_tp[1].tag == 'ID_abs' then
                    if val.tag == 'Exp_as' then
                        me.id = me.id..var.id_dyn
                    else
                        is_dyn = true
                        me.id = ID_abs.dcl.id
                    end
                end
            end

            if var_is_alias then
                INFO.asr_tag(val, {'Alias'},
                    err_str..' : invalid binding : argument #'..i)

                -- dim
                if var.tag=='Vec' or var[1]=='vector' then
                    local _,_,_,fr_dim = unpack(val.info.dcl)
                    ASR(EXPS.check_dim(var_dim,fr_dim), me,
                        err_str..' : invalid binding : argument #'..i..' : dimension mismatch')
                end
            else
                ASR(val.tag=='ID_any' or (not (val.info and val.info.tag=='Alias')), me,
                    'invalid binding : argument #'..i..' : expected declaration with `&´')
            end

            if val.tag == 'ID_any' then
                -- ok: ignore _

            elseif val.tag == 'Vec_Cons' then
assert(ID_abs.dcl.tag == 'Data', 'TODO')
error'TODO: remove below'
                F.__set_vec(val, var)

            else
                -- ctx
                INFO.asr_tag(val, {'Alias','Val','Nat','Var'}, err_str..' : argument #'..i)

                -- tp
                if var_is_alias then
                    EXPS.check_tag(me, var.tag, val.info.dcl.tag, 'invalid binding')
                end
                EXPS.check_tp(me, var_tp, val.info.tp, err_str..' : argument #'..i,var_is_alias)
            end
        end

        me.info = INFO.new(me, 'Val', nil, ID_abs[1])
    end,

-- BIND

    ['Exp_1&'] = function (me)
        local op, e = unpack(me)

        -- ctx
        local par = me.__par
        if par.tag == 'Exp_as' then
            -- &y as X; (y is X.Y)
            par = par.__par
        end
        ASR(par.tag=='Set_Alias' or par.tag=='List_Exp' or par.tag=='Abslist', me,
            'invalid expression : unexpected context for operation `&´')

        -- tp
        -- any

        -- info
        me.info = INFO.copy(e.info)
        me.info.tag = 'Alias'
    end,

-- INDEX ("idx" is Exp, not Exp_Name)

    ['Exp_idx'] = function (me)
        local _,_,idx = unpack(me)

        -- ctx
        INFO.asr_tag(idx, {'Val','Nat','Var'}, 'invalid index')

        -- tp
        ASR(TYPES.is_int(idx.info.tp), me,
            'invalid index : expected integer type')
    end,

-- POINTERS

    ['Exp_&&'] = function (me)
        local op, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var','Pool','Vec'}, 'invalid operand to `'..op..'´')

        -- tp
        ASR(not (e.info.dcl[1]=='&?' or TYPES.check(e.info.tp,'?')), me,
            'invalid operand to `'..op..'´ : unexpected option type')

        -- info
        me.info = INFO.copy(e.info)
        me.info.tag = 'Val'
        me.info.tp = TYPES.push(e.info.tp,'&&')
    end,

-- OPTION: ?

    ['Exp_?'] = function (me)
        local op,e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var','Evt'}, 'invalid operand to `'..op..'´')
        if e.info.dcl.tag == 'Evt' then
            ASR(e.info.dcl[1] == '&?', me,
                'invalid operand to `?´ : unexpected context for event "'..e.info.dcl.id..'"')
        end

        -- tp
        ASR((e.info.dcl[1]=='&?') or TYPES.check(e.info.tp,'?'), me,
            'invalid operand to `'..op..'´ : expected option type')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- VECTOR LENGTH: $$

    ['Exp_$$'] = F_Exp_len,

-- NOT

    ['Exp_not'] = function (me)
        local op, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')

        -- tp
        ASR(TYPES.check(e.info.tp,'bool'), me,
            'invalid operand to `'..op..'´ : expected boolean type')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- UNARY: +,-

    ['Exp_1+'] = 'Exp_num_num',
    ['Exp_1-'] = 'Exp_num_num',
    Exp_num_num = function (me)
        local op, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')

        -- tp
        ASR(TYPES.is_num(e.info.tp), me,
            'invalid operand to `'..op..'´ : expected numeric type')

        -- info
        me.info = INFO.copy(e.info)
        me.info.tag = 'Val'
    end,

-- NUMERIC: +, -, %, *, /, ^

    ['Exp_+']  = 'Exp_num_num_num',
    ['Exp_-']  = 'Exp_num_num_num',
    ['Exp_%']  = 'Exp_num_num_num',
    ['Exp_*']  = 'Exp_num_num_num',
    ['Exp_/']  = 'Exp_num_num_num',
    ['Exp_^']  = 'Exp_num_num_num',
    Exp_num_num_num = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')

        -- tp
        ASR(TYPES.is_num(e1.info.tp) and TYPES.is_num(e2.info.tp), me,
            'invalid operand to `'..op..'´ : expected numeric type')

        -- info
        local max = TYPES.max(e1.info.tp, e2.info.tp)
        ASR(max, me, 'invalid operands to `'..op..'´ : '..
                        'incompatible numeric types : "'..
                        TYPES.tostring(e1.info.tp)..'" vs "'..
                        TYPES.tostring(e2.info.tp)..'"')
        me.info = INFO.new(me, 'Val', nil, AST.copy(max))
    end,

-- BITWISE

    ['Exp_|']  = 'Exp_int_int_int',
    ['Exp_&']  = 'Exp_int_int_int',
    ['Exp_<<'] = 'Exp_int_int_int',
    ['Exp_>>'] = 'Exp_int_int_int',
    Exp_int_int_int = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')

        -- tp
        ASR(TYPES.is_int(e1.info.tp) and TYPES.is_int(e2.info.tp), me,
            'invalid operand to `'..op..'´ : expected integer type')

        -- info
        local max = TYPES.max(e1.info.tp, e2.info.tp)
        ASR(max, me, 'invalid operands to `'..op..'´ : '..
                        'incompatible integer types : "'..
                        TYPES.tostring(e1.info.tp)..'" vs "'..
                        TYPES.tostring(e2.info.tp)..'"')
        me.info = INFO.new(me, 'Val', nil, AST.copy(max))
    end,

    ['Exp_~'] = function (me)
        local op, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')

        -- tp
        ASR(TYPES.is_int(e.info.tp), me,
            'invalid operand to `'..op..'´ : expected integer type')

        -- info
error'TODO: luacov never executes this?'
        me.info = INFO.copy(e.info)
        me.info.tag = 'Val'
    end,

-- COMPARISON: >, >=, <, <=

    ['Exp_>='] = 'Exp_num_num_bool',
    ['Exp_<='] = 'Exp_num_num_bool',
    ['Exp_>']  = 'Exp_num_num_bool',
    ['Exp_<']  = 'Exp_num_num_bool',
    Exp_num_num_bool = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')

        -- tp
        ASR(TYPES.is_num(e1.info.tp) and TYPES.is_num(e2.info.tp), me,
            'invalid operand to `'..op..'´ : expected numeric type')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- EQUALITY: ==, !=

    ['Exp_!='] = 'Exp_eq_bool',
    ['Exp_=='] = 'Exp_eq_bool',
    Exp_eq_bool = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')

        -- tp

        local ID1 = TYPES.ID_plain(e1.info.tp)
        local ID2 = TYPES.ID_plain(e2.info.tp)
        ASR( (not (ID1 and ID1.tag=='ID_abs')) and
             (not (ID2 and ID2.tag=='ID_abs')), me,
            'invalid operands to `'..op..'´ : unexpected `data´ value' )

        ASR(TYPES.contains(e1.info.tp,e2.info.tp) or
            TYPES.contains(e2.info.tp,e1.info.tp), me,
            'invalid operands to `'..op..'´ : '..
            'incompatible types : "'..
                TYPES.tostring(e1.info.tp)..'" vs "'..
                TYPES.tostring(e2.info.tp)..'"')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- AND, OR

    ['Exp_or']  = 'Exp_bool_bool_bool',
    ['Exp_and'] = 'Exp_bool_bool_bool',
    Exp_bool_bool_bool = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'´')

        -- tp
        ASR(TYPES.check(e1.info.tp,'bool') and TYPES.check(e2.info.tp,'bool'), me,
            'invalid operand to `'..op..'´ : expected boolean type')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- IS, AS/CAST

    Exp_as = F_Exp_as,

    Exp_is = function (me)
        local op,e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Val','Nat','Var','Pool'}, 'invalid operand to `'..op..'´')

        -- tp
        local plain = TYPES.ID_plain(e.info.tp)
        ASR(plain and plain.dcl.tag=='Data', me,
            'invalid operand to `'..op..'´ : expected plain `data´ type : got "'..TYPES.tostring(e.info.tp)..'"')
        ASR(plain and plain.dcl.hier, me,
            'invalid operand to `'..op..'´ : expected `data´ type in some hierarchy : got "'..TYPES.tostring(e.info.tp)..'"')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,
}

AST.visit(F)

end

    
do
CONSTS = {
    t2n = {
         us = 10^0,
         ms = 10^3,
          s = 10^6,
        min = 60*10^6,
          h = 60*60*10^6,
    },
}

F = {
    NUMBER = function (me)
        me.is_const = (TYPES.is_int(me.info.tp) and 'int') or 'float'
    end,

    SIZEOF = function (me)
        me.is_const = 'int'
    end,

    ID_nat = function (me)
        local mod = unpack(me.dcl)
        me.is_const = (mod == 'const')
    end,

    ['Exp_|'] = '__Exp_num_num',
    ['Exp_&'] = '__Exp_num_num',
    ['Exp_*'] = '__Exp_num_num',
    ['Exp_+'] = '__Exp_num_num',
    ['Exp_-'] = '__Exp_num_num',
    __Exp_num_num = function (me)
        local _, e1, e2 = unpack(me)
        if e1.is_const and e2.is_const then
            if e1.is_const=='float' or e2.is_const=='float' then
                me.is_const = 'float'
            elseif e1.is_const=='int' or e2.is_const=='int' then
                me.is_const = 'int'
            else
                assert(e1.is_const==true and e2.is_const==true)
                me.is_const = true
            end
        end
    end,

    ['Exp_1~'] = '__Exp_num',
    ['Exp_1+'] = '__Exp_num',
    ['Exp_1-'] = '__Exp_num',
    __Exp_num = function (me)
        local _, e = unpack(me)
        me.is_const = e.is_const
    end,

    ['Exp_$$'] = function (me)
        local dcl = AST.asr(me,'', 2,'Exp_Name').info.dcl
        local _,_,_,len = unpack(dcl)
        me.is_const = (len ~= '[]' and 'int')
    end,

    Exp_as = function (me)
        local _,e = unpack(me)
        me.is_const = e.is_const
    end,

    Exp_Name = function (me)
        local e = unpack(me)
        me.is_const = e.is_const
    end,

    ---------------------------------------------------------------------------

    WCLOCKK = function (me)
        local h,min,s,ms,us = unpack(me)
        local T = CONSTS.t2n
        me.us = us*T.us + ms*T.ms + s*T.s + min*T.min + h*T.h
        ASR(me.us>0 and me.us<=2000000000, me,
            'invalid wall-clock time : constant is out of range')
    end,

    Vec = function (me)
        local is_alias,_,_,dim = unpack(me)
        if dim == '[]' then
            return
        end

        if is_alias or AST.par(me,'Data') then
            -- vector[n] int vec;
            ASR(dim.is_const=='int' or dim.is_const==true, dim,
                'invalid declaration : vector dimension must be an integer constant')
        else
            -- vector[1.5] int vec;
            ASR(TYPES.is_int(dim.info.tp), me,
                'invalid declaration : vector dimension must be an integer')
        end
    end,

    Loop_Num = 'Loop',
    Loop = function (me)
        local max = unpack(me)
        if max then
            ASR(max.is_const=='int' or max.is_const==true, max,
                'invalid `loop´ : limit must be an integer constant')
        end
    end,

    Data = function (me)
        local _, enum = unpack(me)
        if enum then
            ASR(enum.is_const=='int' or enum.is_const==true, enum,
                'invalid `data´ declaration : after `is´ : expected integer constant')
        end
    end,
}

AST.visit(F)

end

    
do
F = {

-- SETS

    Set_Exp = function (me)
        local fr, to = unpack(me)

        local err do
            if AST.get(me.__par,'Stmts', 2,'Escape') then
                err = 'invalid `escape´'
            else
                err = 'invalid assignment'
            end
        end

        if to.info.dcl.is_read_only then
            ASR(me.set_read_only, me,
                'invalid assignment : read-only variable "'..to.info.id..'"')
        end

        -- ctx
        INFO.asr_tag(to, {'Nat','Var','Pool'}, err)
        INFO.asr_tag(fr, {'Val','Nat','Var'}, err)
        ASR((not fr.info.dcl) or (fr.info.dcl[1]~='&?'), me,
            err..' : expected operator `!´')

        -- tp
        EXPS.check_tp(me, to.info.tp, fr.info.tp, err)

        if not TYPES.check(to.info.tp,'?') then
            ASR(not TYPES.check(fr.info.tp,'?'), me,
                'invalid assignment : expected operator `!´')
        end
    end,

    __set_vec = function (fr, to_info)
        AST.asr(fr, 'Vec_Cons')

        -- ctx
        for _, e in ipairs(fr) do
            if e.tag=='Vec_Tup' or e.tag=='STRING' or
               e.tag=='Exp_as'  or e.tag=='Lua'
            then
                -- ok
            else
                INFO.asr_tag(e, {'Vec'}, 'invalid constructor')
            end
        end

        -- tp
        for i, e in ipairs(fr) do
            if e.tag == 'Vec_Tup' then
                local ps = unpack(e)
                if ps then
                    AST.asr(ps,'List_Exp')
                    for j, p in ipairs(ps) do
                        EXPS.check_tp(fr, to_info.tp, p.info.tp,
                            'invalid constructor : item #'..i..' : '..
                            'invalid expression list : item #'..j)
                    end
                end
            elseif e.tag == 'STRING' then
                local tp = TYPES.new(e, 'byte')
                EXPS.check_tp(fr, to_info.tp, tp,
                    'invalid constructor : item #'..i)
            elseif e.tag == 'Lua' then
            elseif e.tag == 'Exp_as' then
            else
                assert(e.info and e.info.tag == 'Vec')
                EXPS.check_tp(fr, to_info.tp, e.info.tp,
                    'invalid constructor : item #'..i)
            end
        end
    end,
    Set_Vec = function (me)
        local fr, to = unpack(me)
        INFO.asr_tag(to, {'Vec'}, 'invalid constructor')
        F.__set_vec(fr, to.info)

        ASR(not TYPES.is_nat(TYPES.get(to.info.tp,1)), me,
            'invalid constructor : expected internal type : got "'..TYPES.tostring(to.info.tp)..'"')

        for i, e in ipairs(fr) do
            if e.tag == 'Exp_Name' then
                -- OK: v1 = v1 ..
                -- NO: v1 = v2 ..
                -- NO: v1 = .. v1
                if i == 1 then
                    ASR(AST.is_equal(to,e), me,
                            'invalid constructor : item #'..i..' : '..
                            'expected destination as source')
                else
                    ASR(not AST.is_equal(to,e), me,
                            'invalid constructor : item #'..i..' : '..
                            'unexpected destination as source')
                end
            end
        end
    end,

    Set_Alias = function (me)
        local fr, to = unpack(me)

        -- ctx
        INFO.asr_tag(to, {'Var','Vec','Pool','Evt'}, 'invalid binding')
        INFO.asr_tag(fr, {'Alias'}, 'invalid binding')

        -- NO: var int x = &...
        -- NO: d.x = &...
        -- NO: x! = &...
        local Exp_Name = AST.asr(to,'Exp_Name')
        local ID_int = AST.get(Exp_Name,'', 1,'ID_int')
        local op = unpack(Exp_Name[1])
        ASR(ID_int, me, 'invalid binding : unexpected context for operator `'..op..'´')
        ASR(ID_int.dcl[1], me, 'invalid binding : expected declaration with `&´')

        if to.__dcls_is_escape then
            ASR(to.info.dcl[1] == '&?', to, 'invalid binding : expected `&?´ modifier')
        end

        -- tp

        EXPS.check_tp(me, to.info.tp, fr.info.tp, 'invalid binding', true)

        local is_call = false
        if fr[2].tag=='Exp_Call' or fr[2].tag=='Abs_Call' then
            is_call = true
            if fr[2].tag == 'Exp_Call' then
                assert(fr.info.dcl and fr.info.dcl.tag=='Nat')
                ASR(TYPES.is_nat(to.info.tp), me,
                    'invalid binding : expected `native´ type')
            else
                local ID_abs = AST.asr(fr,'', 2,'Abs_Call', 2,'Abs_Cons',
                                              1,'ID_abs')
                local tp = AST.asr(ID_abs.dcl,'Code', 4,'Block', 1,'Stmts',
                                                      1,'Stmts', 3,'', 2,'Type')
                EXPS.check_tp(me, to.info.tp, tp, 'invalid binding', true)
            end
        else
            EXPS.check_tag(me, to.info.tag, fr.info.dcl.tag, 'invalid binding')

            -- NO: ... = &_V        // native ID
            ASR(fr.info.dcl.tag~='Nat', me,
                'invalid binding : unexpected native identifier')

            if fr.info.dcl[1] then
                ASR(to.info.dcl[1] == fr.info.dcl[1], me,
                    'invalid binding : unmatching alias `&´ declaration')
            end
        end

        -- option type
        if TYPES.check(to.info.tp,'?') then
            --if TYPES.check(fr.info.tp,'_') and
               --TYPES.is_nat(TYPES.pop(to.info.tp,'?'))
            --then
            if is_call and TYPES.is_nat(TYPES.pop(to.info.tp,'?')) then
                -- OK:
                --  var& _TP? = &_f();
                --  var& _TP? = &Ff();
            else
                -- NO:
                -- var  int  x;
                -- var& int? i = &x;
                ASR(TYPES.check(fr.info.tp,'?'), me,
                    'invalid binding : types mismatch : "'..TYPES.tostring(to.info.tp)..
                                                  '" <= "'..TYPES.tostring(fr.info.tp)..'"')
            end
        end

        -- dim
        if to.info.tag == 'Vec' then
            local _,_,_,to_dim = unpack(to.info.dcl)
            local _,_,_,fr_dim = unpack(fr.info.dcl)
            ASR(EXPS.check_dim(to_dim,fr_dim), me,
                'invalid binding : dimension mismatch')
        end
    end,

    Set_Lua = function (me)
        local _,to = unpack(me)
        INFO.asr_tag(to, {'Nat','Var'}, 'invalid Lua assignment')
    end,

    Set_Async_Thread = function (me)
        local _,to = unpack(me)

        -- ctx
        INFO.asr_tag(to, {'Nat','Var'}, 'invalid `async/thread´ assignment')

        -- tp
        ASR(TYPES.check(to.info.tp,'bool'), me,
            'invalid `async/thread´ assignment : expected `bool´ destination')
    end,

-- ABS

    Set_Abs_Val = function (me)
        local fr, to = unpack(me)
        local Abs_Cons = AST.asr(fr,'Abs_Val', 2,'Abs_Cons')
        local ID_abs = unpack(Abs_Cons)

        -- ctx
        INFO.asr_tag(to, {'Var'}, 'invalid constructor')
        ASR(ID_abs.dcl.tag == 'Data', me,
            'invalid constructor : expected `data´ abstraction : got `code´ "'..
            ID_abs.dcl.id..'" ('..ID_abs.dcl.ln[1]..':'..ID_abs.dcl.ln[2]..')')

        -- tp
        EXPS.check_tp(me, to.info.tp, Abs_Cons.info.tp, 'invalid constructor')

        -- exact match on constructor
        local to_str = TYPES.tostring(to.info.tp)
        local fr_str = TYPES.tostring(Abs_Cons.info.tp)
        if to_str ~= fr_str then
            local _,_,blk = unpack(ID_abs.dcl)
            -- or source has no extra fields
            local super = to.info.tp[1]
            ASR(#AST.asr(ID_abs.dcl,'Data',3,'Block').dcls ==
                #AST.asr(super.dcl ,'Data',3,'Block').dcls, me,
                'invalid constructor : types mismatch : "'..to_str..'" <= "'..fr_str..'"')
        end
    end,
    Set_Abs_New = function (me)
        local _, to = unpack(me)

        -- ctx
        INFO.asr_tag(to, {'Var','Pool'}, 'invalid constructor')
    end,
    Set_Abs_Spawn_Pool = function (me)
        local _, to = unpack(me)

        -- ctx
        INFO.asr_tag(to, {'Var'}, 'invalid constructor')

        -- tp
        ASR(TYPES.check(to.info.tp,'bool'), me,
            'invalid constructor : expected `bool´ destination')
    end,

-- EMIT

    Set_Emit_Ext_emit = function (me)
        local ID_ext = AST.asr(me,'', 1,'Emit_Ext_emit', 1,'ID_ext')
        local io,_ = unpack(ID_ext.dcl)
        ASR(io=='output', me,
            'invalid assignment : `input´')
    end,

    Set_Await_one = function (me)
        local fr, to = unpack(me)
        assert(fr.tag=='Await_Wclock' or fr.tag=='Abs_Await' or fr.tag=='Await_Int')

        if fr.tag == 'Abs_Await' then
            ASR(fr.tp, me,
                'invalid assignment : `code´ executes forever')
        end

        EXPS.check_tp(me, to.info.tp, fr.tp or fr.info.tp, 'invalid assignment')

        if me.__adjs_is_watching then
            -- var int? us = watching 1s do ... end
            ASR(TYPES.check(to.info.tp,'?'), me,
                'invalid `watching´ assignment : expected option type `?´ : got "'..TYPES.tostring(to.info.tp)..'"')
        end
    end,

    Set_Await_many = function (me)
        local fr, to = unpack(me)

        -- ctx
        for _, Exp_Name in ipairs(to) do
            if Exp_Name.tag ~= 'ID_any' then
                INFO.asr_tag(Exp_Name, {'Nat','Var'}, 'invalid assignment')
            end
        end

        -- tp
        EXPS.check_tp(me, to.tp, fr.tp, 'invalid assignment')

        if me.__adjs_is_watching then
            for _, e in ipairs(to) do
                -- var int? us = watching 1s do ... end
                ASR(TYPES.check(e.info.tp,'?'), me,
                    'invalid `watching´ assignment : expected option type `?´ : got "'..TYPES.tostring(e.info.tp)..'"')
            end
        end
    end,

-- AWAITS

    __await_ext_err = function (ID_ext, inout_expected)
        if ID_ext.tag ~= 'ID_ext' then
            return false, 'expected external identifier'
        end

        local inout_have = unpack(ID_ext.dcl)

        if inout_have == inout_expected then
            return true
        else
            return false, 'expected `'..inout_expected..'´ external identifier'
        end
    end,

    Await_Ext = function (me)
        local ID_ext = unpack(me)

        -- ctx
        local ok, msg = F.__await_ext_err(ID_ext, 'input')
        ASR(ok, me, msg and 'invalid `await´ : '..msg)

        me.tp = ID_ext.dcl[2]
    end,

    Await_Pause = function (me)
        me.tp = AST.node('Typelist', me.ln, TYPES.new(me, 'bool'))
    end,

    Await_Wclock = function (me)
        me.tp = TYPES.new(me, 'int')
    end,

    __check_watching_list = function (me, pars, list, must_be_opt)
        local tag = (me.tag=='Abs_Await' and 'Watching') or me.tag
        ASR(pars and #pars==#list, me,
            'invalid `'..AST.tag2id[tag]..'´ : expected '..#pars..' argument(s)')
        for i, par in ipairs(pars) do
            local par_alias,par_tp = unpack(par)
            assert(par_alias)
            local arg = list[i]
            if arg.tag ~= 'ID_any' then
                local arg_alias,arg_tp = unpack(arg.dcl)
                local err = 'invalid binding : argument #'..i
                ASR(arg_alias, me,
                    err..' : expected alias `&´ declaration')
                ASR(arg_alias == par_alias, me,
                    err..' : unmatching alias `&´ declaration')
                EXPS.check_tag(me, par.tag, arg.info.dcl.tag, err)
                EXPS.check_tp(me, par_tp, arg_tp, err)

                if must_be_opt then
                    ASR(arg_alias=='&?', me,
                        err..' : terminating `code´ : expected alias `&?´ declaration')
                end
            end
        end
    end,

    Abs_Spawn_Pool = function (me)
        local mods_call,Abs_Cons,list = unpack(me)
        local ID_abs = AST.asr(Abs_Cons,'Abs_Cons', 1,'ID_abs')
        me.__code = AST.asr(ID_abs.dcl,'Code')

        local _,mods_dcl = unpack(me.__code)
        ASR(mods_dcl.await, me,
            'invalid `'..AST.tag2id[me.tag]..'´ : expected `code/await´ declaration '..
                '('..me.__code.ln[1]..':'..me.__code.ln[2]..')')

        if mods_dcl.dynamic then
            ASR(mods_call.dynamic or mods_call.static, me,
                'invalid `'..AST.tag2id[me.tag]..'´ : expected `/dynamic´ or `/static´ modifier')
        else
            local mod = (mods_call.dynamic or mods_call.static)
            ASR(not mod, me, mod and
                'invalid `'..AST.tag2id[me.tag]..'´ : unexpected `/'..mod..'´ modifier')
        end

        if list then
            local must_be_opt = (me.tag ~= 'Abs_Await') and
                                 AST.get(me.__code,'', 4,'Block', 1,'Stmts',
                                                       1,'Stmts', 3,'', 2,'Type')

            local pars = AST.asr(me.__code,'', 4,'Block', 1,'Stmts',
                                               1,'Stmts', 2,'Code_Pars')
            F.__check_watching_list(me, pars, list, must_be_opt)
        end
    end,

    Abs_Spawn_Single = function (me)
        F.Abs_Spawn_Pool(me)
        ASR(AST.par(me,'Code') ~= me.__code, me,
            'invalid `'..AST.tag2id[me.tag]..'´ : unexpected recursive invocation')
     end,

    Abs_Await = function (me)
        F.Abs_Spawn_Single(me)
        local ret = AST.get(me.__code,'', 4,'Block', 1,'Stmts',
                                          1,'Stmts', 3,'', 2,'Type')
        me.tp = ret and AST.copy(ret)

        local watch = AST.par(me, 'Watching')
        local me1 = AST.get(watch,'', 1,'Par_Or', 1,'Block', 1,'Stmts', 1,'Abs_Await')
        if me1 == me then
            ASR(ret, watch, 'invalid `watching´ : `code´ executes forever')
        end
     end,

    Await_Int = function (me, tag)
        local e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Var','Evt','Pool'}, 'invalid `await´')
        if e.info.tag == 'Var' then
            ASR(e.info.dcl[1] == '&?', me,
                'invalid `await´ : expected `var´ with `&?´ modifier')
        end

        -- tp
        me.tp = e.info.tp
    end,

-- STATEMENTS

    Await_Until = function (me)
        local _, cond = unpack(me)
        if cond then
            ASR(TYPES.check(cond.info.tp,'bool'), me,
                'invalid expression : `until´ condition must be of boolean type')
        end
    end,

    Pause_If = function (me)
        local e = unpack(me)

        -- ctx
        local ok, msg = F.__await_ext_err(e, 'input')
        if not ok then
            INFO.asr_tag(e, {'Evt'}, 'invalid `pause/if´')
        end

        -- tp
        local Typelist = AST.asr((e.dcl and e.dcl[2]) or e.info.tp,'Typelist')
        ASR(#Typelist==1 and TYPES.check(Typelist[1],'bool'), me,
            'invalid `pause/if´ : expected event of type `bool´')
    end,

    Do = function (me)
        local _,_,e = unpack(me)
        if e then
            INFO.asr_tag(e, {'Nat','Var'}, 'invalid assignment')
        end
    end,

    If = function (me)
        local cnd = unpack(me)
        ASR(TYPES.check(cnd.info.tp,'bool'), me,
            'invalid `if´ condition : expected boolean type')
    end,

    Loop_Num = function (me)
        local _, i, range = unpack(me)
        local fr,_,to,step = unpack(range)
        local i_tp, fr_tp, to_tp, s_tp = i.info.tp,
                                         fr.info.tp,
                                         (to.info and to.info.tp or step.info.tp),
                                         step.info.tp
        ASR(TYPES.is_num(i_tp), me, 'invalid `loop´ : expected numeric variable')
        ASR(TYPES.contains(i_tp,fr_tp), me,
            'invalid control variable : types mismatch : "'..TYPES.tostring(i_tp)..'" <= "'..TYPES.tostring(fr_tp)..'"')
        ASR(TYPES.contains(i_tp,to_tp), me,
            'invalid control variable : types mismatch : "'..TYPES.tostring(i_tp)..'" <= "'..TYPES.tostring(to_tp)..'"')
        ASR(TYPES.contains(i_tp,s_tp), me,
            'invalid control variable : types mismatch : "'..TYPES.tostring(i_tp)..'" <= "'..TYPES.tostring(s_tp)..'"')
    end,

    Loop_Pool = function (me)
        local _,list,pool = unpack(me)

        -- ctx
        INFO.asr_tag(pool, {'Pool'}, 'invalid `pool´ iterator')

        if list then
            local Code = AST.asr(pool.info.tp[1].dcl, 'Code')
            local pars = AST.asr(Code,'', 4,'Block', 1,'Stmts',
                                          1,'Stmts', 2,'Code_Pars')
            F.__check_watching_list(me, pars, list)
        end
    end,

-- CALL, EMIT

    Emit_Evt = function (me)
        local e, ps = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Evt'}, 'invalid `emit´')

        -- tp
        EXPS.check_tp(me, e.info.tp, ps.tp, 'invalid `emit´')

        ASR(e.info.dcl[1] ~= '&?', me,
            'invalid `emit´ : unexpected `event´ with `&?´ modifier')
    end,

    Emit_Ext_emit = function (me)
        local ID_ext, ps = unpack(me)

        -- ctx
        local have = unpack(ID_ext.dcl)
        local expects do
            if ID_ext.dcl.tag ~= 'Ext' then
                expects = 'error'
            elseif AST.par(me,'Async') or AST.par(me,'_Async_Isr') then
--TODO: _Async_Isr
                expects = 'input'
            else
                expects = 'output'
            end
        end

        ASR(have==expects, me,
            'invalid `emit´ : '..
            'unexpected context for '..AST.tag2id[ID_ext.dcl.tag]..' `'..
            have..'´ "'..ID_ext.dcl.id..'"')

        -- tp
        EXPS.check_tp(me, ID_ext.dcl[2], ps.tp, 'invalid `emit´')
    end,

    Emit_Ext_call = function (me)
        local ID_ext, ps = unpack(me)

        -- tp
        local _,_,_,ins = unpack(ID_ext.dcl)
        local Typelist = AST.node('Typelist', me)
        for i, item in ipairs(ins) do
            local Type = AST.asr(item,'', 4,'Type')
            Typelist[i] = Type
        end
        EXPS.check_tp(me, Typelist, ps.tp, 'invalid call')
    end,

    Exp_Call = function (me)
        local _, e, ps = unpack(me)

        -- tp
        for _,p in ipairs(ps) do
            -- tp
            local is_opt = (p.info.dcl and p.info.dcl[1]=='&?')
            ASR(not (is_opt or TYPES.check(p.info.tp,'?')), me,
                'invalid call : unexpected context for operator `?´')

            if p.info.tag ~= 'Nat' then
                local is_alias = unpack(p.info)
                ASR(not is_alias, me,
                    'invalid call : unexpected context for operator `&´')
            end
        end
    end,

-- VARLIST, EXPLIST

    List_Exp = function (me)
        local Typelist = AST.node('Typelist', me.ln)
        for i, e in ipairs(me) do
            -- ctx
-- TODO: call/emit, argument
            INFO.asr_tag(e, {'Val','Nat','Var'},
                'invalid expression list : item #'..i)

            -- info
            Typelist[i] = AST.copy(e.info.tp)
        end
        me.tp = Typelist
    end,

    List_Name = function (me)
        -- ctx
        for _, var in ipairs(me) do
            if var.tag ~= 'ID_any' then
                INFO.asr_tag(var, {'Nat','Var'}, 'invalid variable')
            end
        end

        -- info
        local Typelist = AST.node('Typelist', me.ln)
        for i, var in ipairs(me) do
            if var.tag == 'ID_any' then
                Typelist[i] = true
            else
                Typelist[i] = AST.copy(var.info.tp)
            end
        end
        me.tp = Typelist
    end,

    List_Var = function (me)
        -- ctx
        for _, var in ipairs(me) do
            if var.tag ~= 'ID_any' then
                INFO.asr_tag(var, {'Var','Vec','Evt'}, 'invalid variable')
            end
        end

        -- info
        local Typelist = AST.node('Typelist', me.ln)
        for i, var in ipairs(me) do
            if var.tag ~= 'ID_any' then
                Typelist[i] = AST.copy(var.info.tp)
            end
        end
        me.tp = Typelist
    end,
}

AST.visit(F)

end

    
do
--local __detect_cycles = {}

local function run_watch (par, i, stop)
    local me = par[i]
    if me == nil then
        if par == stop then
            return true -- no yield found
        else
            return run_watch(par.__par, par.__i+1, stop)
        end
    elseif not AST.is_node(me) then
        return run_watch(par, i+1, stop)
    elseif me == stop then
        return true
    end

    if me.tag == 'Escape' then
        local blk = AST.asr(me.outer,'',2,'Block')
        if AST.depth(blk) <= AST.depth(stop) then
            return true
        end
        if stop.__par.tag=='Code' and
           AST.par(AST.par(me.outer,'Block'),'Block')==stop
        then
            return true     -- both are top-level in the "code"
        end
    end

    if (me.tag == 'Y') then
        return false, me

    elseif me.tag == 'If' then
        local c, t, f = unpack(me)

        local ok1, yield1 = run_watch(t, 1, t)
        if not ok1 then
            return false, yield1
        end

        local ok2, yield2 = run_watch(f, 1, f)
        if not ok2 then
            return false, yield2
        end

        return run_watch(me, #me, stop)   -- continue with pointer accesses
    end

    return run_watch(me, 1, stop)
end

local function is_loop (me)
    return me.tag=='Loop' or me.tag=='Loop_Num'
end

local function run_inits (par, i, Dcl, stop)
    local me = par[i]
    if me == nil then
        if par == stop then
            return false                        -- stop, not found
        else
            return run_inits(par.__par, par.__i+1, Dcl, stop)
        end
    elseif not AST.is_node(me) then
        return run_inits(par, i+1, Dcl, stop)
    end
    --assert(not __detect_cycles[me], me.n)
    --__detect_cycles[me] = true

    if me.tag == 'Escape' then
        local blk = AST.asr(me.outer,'',2,'Block')
        local depth = AST.depth(Dcl.blk)
        if Dcl.is_mid_idx then
            depth = depth + 5
        end
        if AST.depth(blk) <= depth then
            return false
        else
            return run_inits(blk, #blk+1, Dcl, stop)
        end
    end

    local is_alias = unpack(Dcl)

    if is_alias then
        local stmt
        if me.tag == 'Watching' then
            stmt = AST.get(me,'',1,'Par_Or',1,'Block',1,'Stmts',
                                 1,'Set_Await_one', 1,'Abs_Await')
                or AST.get(me,'',1,'Par_Or',1,'Block',1,'Stmts',
                                 1,'Abs_Await')

            local ok, yield = run_watch(me, #me+1, Dcl.blk)
            ASR(ok, me, yield and
                'invalid binding : active scope reached yielding statement '..
                '('..yield.ln[1]..':'..yield.ln[2]..')')

        elseif me.tag=='Abs_Await' or me.tag=='Abs_Spawn_Single'
                                   or me.tag=='Abs_Spawn_Pool'
        then
            stmt = me
        end

        if stmt then
local Y = stmt[4]
stmt[4] = nil
            local ok = run_inits(stmt, 1, Dcl)
stmt[4] = Y
            ASR(ok, Dcl,
                'uninitialized '..AST.tag2id[Dcl.tag]..' "'..Dcl.id..'" : '..
                'reached `'..AST.tag2id[me.tag]..'´ '..
                '('..me.ln[1]..':'..me.ln[2]..')')
            return true
        end
    end

    -- error: yielding statement
    if (me.tag == 'Y') or (is_loop(me) and is_alias) then
        local tag = unpack(me)
        ASR(false, Dcl,
            'uninitialized '..AST.tag2id[Dcl.tag]..' "'..Dcl.id..'" : '..
            'reached yielding statement '..
            --'reached `'..AST.tag2id[me.tag]..'´ '..
            '('..me.ln[1]..':'..me.ln[2]..')')

    -- error: access to Dcl
    elseif me.tag == 'ID_int' then
        if me.__par.tag == 'Do' then
            -- ok: do/a end
        elseif me.dcl == Dcl then
            ASR(false, Dcl,
                'uninitialized '..AST.tag2id[Dcl.tag]..' "'..Dcl.id..'" : '..
                'reached read access '..
                '('..me.ln[1]..':'..me.ln[2]..')')
        end

    elseif me.tag == 'If' then
        local _, t, f = unpack(me)
        local ok1 = run_inits(t, 1, Dcl, t)
        local ok2 = run_inits(f, 1, Dcl, f)
        if ok1 or ok2 then
            ASR(ok1 and ok2, Dcl,
                'uninitialized '..AST.tag2id[Dcl.tag]..' "'..Dcl.id..'" : '..
                'reached end of `if´ '..
                '('..me.ln[1]..':'..me.ln[2]..')')
            return true                         -- stop, found init
        end
        return run_inits(me, #me, Dcl, stop)

    -- ok: found assignment
    elseif me.tag == 'List_Var' then
        for _,ID_int in ipairs(me) do
            if ID_int.dcl == Dcl then
                ID_int.dcl.inits = {me}
                ID_int.is_init = true       -- refuse all others
                return true
            end
        end

    -- ok: found assignment
    elseif me.tag == 'Loop_Num' then
        local _, i = unpack(me)
        if i.dcl.inits then
            i.dcl.inits[#i.dcl.inits+1] = me
        else
            i.dcl.inits = {me}
        end
        return true

    -- ok: found assignment
    elseif string.sub(me.tag,1,4)=='Set_' then
        local fr, to = unpack(me)
        if me.tag == 'Set_Exp' then
            -- var int a = a+1;
            run_inits(fr, 1, Dcl, fr)
        end

        -- some assertions
        do
            if me.tag == 'Set_Emit_Ext_emit' then
                -- input would be inside async, which is catched elsewhere
                local ID_ext = AST.asr(fr,'Emit_Ext_emit', 1,'ID_ext')
                local dcl = AST.asr(ID_ext.dcl,'Ext')
                assert(dcl[1] == 'output')
            end
        end

        -- equalize all with Set_Await_many
        if to.tag ~= 'List_Name' then
            to = { to }
        end

        for _, sub in ipairs(to) do
            if sub.tag ~= 'ID_any' then
                -- NO: var& int x = ... (w/o &)
                local is_alias = unpack(sub.info.dcl)
                if is_alias and (me.tag~='Set_Alias') then
                    if me.tag == 'Set_Exp' then
                        ASR(false, me,
                            'invalid binding : expected operator `&´ in the right side')
                    else
                        ASR(false, me,
                            'invalid binding : unexpected statement in the right side')
                    end
                end

                if sub[1].tag ~= 'ID_int' then
                    -- ID.field = ...;  // ERR: counts as read, not write
                    if sub.info.dcl == Dcl then
                        ASR(false, Dcl,
                            'uninitialized '..AST.tag2id[Dcl.tag]..' "'..Dcl.id..'" : '..
                            'reached read access '..
                            '('..sub.ln[1]..':'..sub.ln[2]..')')
                    end
                else
                    -- ID = ...;
                    local ID_int = AST.asr(sub,'Exp_Name', 1,'ID_int')
                    if ID_int.dcl == Dcl then
                        if me.tag == 'Set_Any' then
                            local f = WRN
                            if CEU.opts.ceu_err_uninitialized then
                                f = ASR_WRN_PASS(CEU.opts.ceu_err_uninitialized)
                            end
                            f(false, Dcl,
                              'uninitialized '..AST.tag2id[Dcl.tag]..' "'..Dcl.id..'"')
                        end
                        if me.tag == 'Set_Alias' then
                            me.is_init = true       -- refuse all others
                            if ID_int.dcl.inits then
                                ID_int.dcl.inits[#ID_int.dcl.inits+1] = me
                            else
                                ID_int.dcl.inits = {me}
                            end
                        end
                        return true                 -- stop, found init
                    end
                end
            end
        end
    elseif me.tag == 'Do' then
        -- a = do ... end
        local _,body,Exp_Name = unpack(me)
        if Exp_Name then
            local ID_int = AST.asr(Exp_Name,'Exp_Name', 1,'ID_int')
            if ID_int.dcl == Dcl then
--[[
-- TODO-DO:
should run_inits inside the `do´, but the check is different b/c
it can cross yielding stmts w/o problems
                local ok = run_inits(body, 1, Dcl, body)
                ASR(ok, Dcl,
                    'uninitialized '..AST.tag2id[Dcl.tag]..' "'..Dcl.id..'" : '..
                    'reached end of `do´ '..
                    '('..me.ln[1]..':'..me.ln[2]..')')
]]
                return true                     -- stop, found init
            end
        end
    end
    return run_inits(me, 1, Dcl, stop)
end

local __is_set = function (me) return string.sub(me.tag,1,4)=='Set_' end

local function run_ptrs (par, i, Dcl, stop)
    local me = par[i]
    if me == nil then
        if par == stop then
            return true                     -- no stop found, continue with pointer accesses
        else
            return run_ptrs(par.__par, par.__i+1, Dcl, stop)
        end
    elseif not AST.is_node(me) then
        return run_ptrs(par, i+1, Dcl, stop)
    end

    -- yielding statement: stop?
    if me.tag == 'Y' then
        local set = AST.par(me,__is_set)
        local ok = false
        if set then
            local _,to = unpack(set)
            if to.tag ~= 'List_Name' then
                to = { to }
            end
            for _, v in ipairs(to) do
                if v.info.dcl == Dcl then
                    ok = true
                    break
                end
            end
        end
        if ok then
            -- continue: this is a Set on me
        else
            -- stop
            Dcl.__run_ptrs_yield = me
            return false                    -- stop with pointer acesses
        end

    -- If: take the two branches independently
    elseif me.tag == 'If' then
        local c, t, f = unpack(me)
        local ok = run_ptrs(c, 1, Dcl, c)
        assert(ok)
        local ok1 = run_ptrs(t, 1, Dcl, t)
        local ok2 = run_ptrs(f, 1, Dcl, f)
        if ok1 and ok2 then
            return run_ptrs(me, #me, Dcl, stop)   -- continue with pointer accesses
        else
            return false                    -- stopped in one of the branches
        end

    -- access to Dcl: mark as safe
    elseif me.tag=='ID_int' and me.dcl==Dcl then
        me.__run_ptrs_ok = true

    -- skip all |a = do ... end|
    elseif me.tag == 'Do' then
        local _,_,Exp_Name = unpack(me)
        if Exp_Name then
            assert(Exp_Name.info.dcl, 'bug found')
            if Exp_Name.info.dcl == Dcl then
                return run_ptrs(me, #me, Dcl, stop)   -- skip
            end
        end
    end

    return run_ptrs(me, 1, Dcl, stop)
end

F = {
    Pool = 'Var',
    Vec  = 'Var',
    Evt  = 'Var',
    Var  = function (me)
        local is_alias,tp = unpack(me)

        local Code = AST.par(me, 'Code')
        if Code and (not Code.is_impl) then
            return
        end

        -- RUN_INITS
        if me.is_implicit       or                  -- compiler defined
           me.is_param          or                  -- "code" parameter
           AST.par(me,'Data')   or                  -- "data" member
           TYPES.check(tp,'?') and (not is_alias)   -- optional initialization
        then
            -- ok: don't need initialization
        else
            if me.tag=='Var' or     -- all vars must be inited
               is_alias      or     -- all aliases must be bound
               tp.tag=='Type' and TYPES.is_nat(tp) and assert(me.tag=='Vec')
            then
                -- var x = ...
                -- event& e = ...
                --__detect_cycles = {}
                run_inits(me, #me+1, me)
            end
        end

        -- RUN_PTRS

        if me.tag=='Evt' or me.tag=='Pool' then
            return
        end

        local is_ptr = TYPES.check(tp,'&&') or TYPES.is_nat_not_plain(tp)
        if not is_ptr then
            local ID = TYPES.ID_plain(tp)
            is_ptr = ID and ID.tag=='ID_abs' and
                        ID.dcl.tag=='Data' and ID.dcl.weaker=='pointer'
        end

        if is_ptr then
            local stmts = AST.get(me,2,'Stmts') or AST.asr(me,1,'Stmts')
            local Var,Do = unpack(stmts)
            if me==Var and Do and Do.tag=='Do' and
               AST.asr(Do,'',3,'Exp_Name').dcl==me
            then
                -- start "run_ptrs" after the "do"
                --  var int x = do ... end;
error'TODO: luacov never executes this?'
                run_ptrs(Do, 3, me)
            else
                run_ptrs(me, #me+1, me)
            end
        end
    end,

    -- skiped by run_ptrs with tag=='Do'
    Stmts__PRE = function (me)
        local Set_Exp, Escape = unpack(me)
        if #me==2 and Set_Exp.tag=='Set_Exp' and Escape.tag=='Escape' then
            local ID_int = AST.get(Set_Exp,'', 2,'Exp_Name', 1,'ID_int')
            if ID_int then
                ID_int.__run_ptrs_ok = true
            end
        end
    end,

    ID_int = function (me)
        if me.dcl.tag=='Evt' or me.dcl.tag=='Pool' then
            return
        end
        local is_alias = unpack(me.dcl)
        if is_alias then
            return
        end

        -- loop <NO> in <OK> do <NO> end
        if AST.par(me, 'Loop_Num_Range') then
            return
        end

        local tp = me.dcl[2]
        local is_ptr = TYPES.check(tp,'&&') or TYPES.is_nat_not_plain(tp)
        if not is_ptr then
            local ID = TYPES.ID_plain(tp)
            is_ptr = ID and ID.tag=='ID_abs' and
                        ID.dcl.tag=='Data' and ID.dcl.weaker=='pointer'
        end

        if is_ptr then
            local yield = me.dcl.__run_ptrs_yield
            ASR(me.__run_ptrs_ok, me,
                'invalid pointer access : crossed '..
                'yielding statement '..
                --AST.tag2id[yield.tag]..'´ '..
                '('..yield.ln[1]..':'..yield.ln[2]..')')
        end
    end,

    Set_Alias = function (me)
        local fr,to = unpack(me)
        if me.is_init or to.__dcls_is_escape then
            return  -- I'm the one who created the binding
        end

        ASR(not AST.par(me,'Code'), me,
            'invalid binding : '..AST.tag2id[to.info.dcl.tag]..
            ' "'..to.info.dcl.id..'" is already bound')

        -- NO: multiple bindings
        --  x=&a; x=&b
        local inits do
            inits = {}
            for i, init in ipairs(to.info.dcl.inits) do
                inits[i] = init.ln[1]..':'..init.ln[2]
            end
            inits = table.concat(inits,',')
        end
        ASR(false, me,
            'invalid binding : '..
            AST.tag2id[to.info.dcl.tag]..
            ' "'..to.info.dcl.id..'" is already bound ('..
            inits..')')
    end,
    List_Var = function (me)
        if not (AST.par(me,'Abs_Await') or AST.par(me,'Abs_Spawn_Single')) then
            return  -- only in watching
        end

        for _, to in ipairs(me) do
            if to.is_init then
                -- I'm the one who created the binding
            elseif to.tag ~= 'ID_any' then
                -- NO: multiple bindings
                --  x=&a; x=&b
                local inits do
                    inits = {}
                    for i, init in ipairs(to.dcl.inits) do
                        inits[i] = init.ln[1]..':'..init.ln[2]
                    end
                    inits = table.concat(inits,',')
                end
                ASR(me.is_init, me,
                    'invalid binding : '..
                    AST.tag2id[to.dcl.tag]..
                    ' "'..to.dcl.id..'" is already bound ('..
                    inits..')')
            end
        end
    end,

    -- NO: a = do ... a ... end
    Exp_Name = function (me)
        -- OK
        do
            -- a = do escape 1 end  // a=1
            if me.__dcls_is_escape then
                return
            end
            -- 3rd field of Do
            local do_ = AST.par(me, 'Do')
            if do_ and do_[3]==me then
                return
            end
        end


        -- NO
        for par in AST.iter() do
            if par.tag == 'Do' then
                local _,_,Exp_Name = unpack(par)
                if Exp_Name then
                    --ASR(not AST.is_equal(Exp_Name.dcl,me.dcl), me,
                    ASR(Exp_Name.info.dcl ~= me.info.dcl, me,
                        'invalid access to '..AST.tag2id[me.info.dcl.tag]
                            ..' "'..me.info.dcl.id..'" : '
                            ..'assignment in enclosing `do` ('
                            ..Exp_Name.ln[1]..':'..Exp_Name.ln[2]..')')
                end
            end
        end
    end,
}

AST.visit(F)

end

    
do
--  NO: big = &&small
local function check_blk (to_blk, fr_blk)
    local Code = AST.par(fr_blk,'Code')
    local Stmts = Code and AST.get(Code,'',4,'Block',1,'Stmts',2,'Block',1,'Stmts')
    if AST.depth(to_blk) >= AST.depth(fr_blk) then
        assert(AST.is_par(fr_blk,to_blk), 'bug found')
        return true
    elseif Stmts and (
                AST.get(Stmts,'',1,'Do', 2,'Block')==fr_blk -- code ... => ...
            or
                AST.get(Stmts,'',1,'Block')==fr_blk         -- code ... => FOREVER
            ) then
        return 'maybe'
    else
        assert(AST.is_par(to_blk,fr_blk), 'bug found')
        return false
    end
end

local function f2mod (f)
    local Exp_Name = AST.asr(f,'Exp_Name')
    local Node = unpack(Exp_Name)
    if Node.tag == 'Exp_as' then
        local _,_,mod = unpack(Node)
        return mod
    else
        local nat = AST.get(Exp_Name.info.dcl,'Nat')
        if nat then
            local mod = unpack(AST.asr(Exp_Name.info.dcl,'Nat'))
            return mod
        else
            return nil
        end
    end
end

F = {
    Set_Exp = function (me)
        local fr, to = unpack(me)

        local fr_ptr = TYPES.check(fr.info.tp,'&&')
        local to_ptr = TYPES.check(TYPES.pop(to.info.tp,'?'),'&&')
        local to_nat = TYPES.is_nat(TYPES.pop(to.info.tp,'?'))

        -- NO:
        --  d1; do d2=d1 end;   // d1>d2 and d1-has-pointers
        local ID = TYPES.ID_plain(fr.info.tp)
        local fr_data_ptr = ID and ID.tag=='ID_abs' and
                                ID.dcl.tag=='Data' and ID.dcl.weaker~='plain'

        -- ptr = _f()
        if fr.tag=='Exp_Call' and (to_ptr or to_nat) then
            local mod = f2mod(AST.asr(fr,'',2,'Exp_Name'))
            ASR(mod=='nohold' or mod=='pure' or mod=='plain', me,
                'invalid assignment : expected binding for "'..fr.info.dcl.id..'"')
        end

        if to_ptr or fr_ptr or fr_data_ptr then
            local fr_nat = TYPES.is_nat(fr.info.tp)
            assert((to_ptr or to_nat) and (fr_ptr or fr_nat) or fr_data_ptr, 'bug found')

            local to_blk, fr_blk
            local ok do
                if (not fr.info.dcl) or (fr.info.dcl.tag=='Nat') then
                    ok = true   -- var int&& x = _X/null/""/...;
                else
                    fr_blk = fr.info.dcl_obj and fr.info.dcl_obj.blk or
                                fr.info.dcl.blk
                    if to_nat then
                        ok = false  -- _X = &&x;
                    else
                        to_blk = to.info.dcl_obj and to.info.dcl_obj.blk or
                                    to.info.dcl.blk
                        ok = check_blk(to_blk, fr_blk)
                        if to.info.dcl.id=='_ret' and ok=='maybe' then
                            ok = false
                        end
                    end
                end
            end 
            if not ok then
                if AST.get(me.__par,'Stmts', 2,'Escape') then
                    ASR(false, me, 'invalid `escape´ : incompatible scopes')
                elseif fr_data_ptr then
                    ASR(false, me,
                        'invalid assignment : incompatible scopes : `data´ "'..
                            ID.dcl.id..'" is not plain')
                else
                    local fin = AST.par(me, 'Finalize')
                    ASR(fin and fin[1]==me, me,
                        'invalid pointer assignment : expected `finalize´ for variable "'..fr.info.id..'"')
                    assert(not fin.__fin_vars, 'TODO')
                    fin.__fin_vars = {
                        blk = assert(fr_blk),
                        assert(fr.info.dcl_obj or fr.info.dcl)
                    }
                end
            end
        end
    end,

    Set_Alias = function (me)
        local fr, to = unpack(me)

        local _, call = unpack(fr)
        if (call.tag=='Exp_Call' or call.tag=='Abs_Call') then
            ASR(to.info.dcl[1] == '&?', me,
                'invalid binding : expected option alias `&?´ as destination : got "'
                ..TYPES.tostring(to.info.tp)..'"')

            local fin = AST.par(me, 'Finalize')
            ASR(fin, me,
                'invalid binding : expected `finalize´')

            -- all finalization vars must be in the same block
            local blk = to.info.dcl_obj and to.info.dcl_obj.blk or
                            to.info.dcl.blk
            blk.needs_clear = true

            if fin.__fin_vars then
                ASR(blk == fin.__fin_vars.blk, me,
                    'invalid `finalize´ : incompatible scopes')
                fin.__fin_vars[#fin.__fin_vars+1] = assert(to.info.dcl)
            else
                fin.__fin_vars = { blk=blk, assert(to.info.dcl) }
            end
        else
            local ok = is_call or check_blk(to.info.dcl.blk, fr.info.dcl.blk)
            if not ok then
                if to.info.dcl.is_mid_idx then
                    local watch = AST.par(me, 'Watching')
                    if watch then
                        --  code/await Ff (void) => (Dcl) => void do
                        --      watching Gg(1) => (y1) do
                        --          var int v = ...
                        --          Dcl = &v;   // OK
                        ok = (fr.info.dcl.blk == AST.asr(watch,'',1,'Par_Or',2,'Block'))
                    end
                end
            end
            if to.info.dcl[1] == '&?' then
                ok = true
                to.info.dcl.is_local_set_alias = true
                fr.info.dcl.blk.needs_clear = true
                assert(AST.par(to.info.dcl,'Code') == AST.par(fr.info.dcl,'Code'), 'not implemented')
            end
            ASR(ok, me, 'invalid binding : incompatible scopes')
        end
    end,

    Exp_Call = function (me)
        local _,f,ps = unpack(me)

        -- ignore if "f" is "nohold" or "pure"
        local mod = f2mod(f)
        if mod=='nohold' or mod=='pure' then
            return
        end

        for _, p in ipairs(ps) do
            if p.info.dcl and (p.info.dcl.tag ~= 'Nat') -- OK: _f(&&_V)
                and (TYPES.check(p.info.tp,'&&') or     -- NO: _f(&&v)
                     TYPES.is_nat_not_plain(p.info.tp)) -- NO: _f(_ptr)
            then
                local fin = AST.par(me, 'Finalize')
                local ok = fin and (
                            (AST.get(fin,'',1,'Stmt_Call',1,'')            == me) or
                            (AST.get(fin,'',1,'Set_Alias',1,'Exp_1&',2,'') == me) or
                            (AST.get(fin,'',1,'Set_Exp',1,'')              == me) )

                    -- _f(...);
                    -- x = &_f(...);
                    -- x = _f(...);
                ASR(ok, me,
                    'invalid `call´ : expected `finalize´ for variable "'..p.info.id..'"')
                -- all finalization vars must be in the same block
                local blk = p.info.dcl_obj and p.info.dcl_obj.blk or
                                p.info.dcl.blk
                if fin.__fin_vars then
                    ASR(blk == fin.__fin_vars.blk, me,
                        'invalid `finalize´ : incompatible scopes')
                    fin.__fin_vars[#fin.__fin_vars+1] = assert(p.info.dcl)
                else
                    fin.__fin_vars = { blk=blk, p.info.dcl }
                end
            end
        end
    end,

    --------------------------------------------------------------------------

    __stmts = { Set_Exp=true, Set_Alias=true,
                Emit_Ext_emit=true, Emit_Ext_call=true,
                Stmt_Call=true },

    Block__PRE = function (me)
        me.fins_n = 0
    end,
    Finalize = function (me)
        local Stmt, List_Name, Block = unpack(me)
        if not Stmt then
            ASR(List_Name==false, me,
                'invalid `finalize´ : unexpected `varlist´')
            me.blk = AST.par(me, 'Block')
            me.blk.fins_n = me.blk.fins_n + 1
            me.blk.needs_clear = true
            return
        end
        assert(Stmt)

        -- NO: |do r=await... finalize...end|
        local tag_id = AST.tag2id[Stmt.tag]
        ASR(F.__stmts[Stmt.tag], Stmt,
            'invalid `finalize´ : unexpected '..
            (tag_id and '`'..tag_id..'´' or 'statement'))

        ASR(me.__fin_vars, me,
            'invalid `finalize´ : nothing to finalize')
        ASR(List_Name and List_Name.tag=='List_Name', List_Name or me,
            'invalid `finalize´ : expected `varlist´')

        for _, v1 in ipairs(me.__fin_vars) do
            ASR(v1.tag=='Nat' or v1.tag=='Var', Stmt,
                'invalid `finalize´ : expected identifier : got "'..v1.id..'"')

            local ok = false
            for _, v2 in ipairs(List_Name) do
                if v2.info.dcl==v1 or v2.info.dcl==v1.orig then
                                        -- TODO: HACK_3
                    ok = true
                    break
                end
            end
            ASR(ok, List_Name,
                'invalid `finalize´ : unmatching identifiers : expected "'..
                v1.id..'" (vs. '..Stmt.ln[1]..':'..Stmt.ln[2]..')')
        end

        me.blk = assert(me.__fin_vars.blk)
        me.blk.fins_n = me.blk.fins_n + 1
        me.blk.needs_clear = true
    end,
}

AST.visit(F)

end

    
do
local awaits = {
    Par           = true,
    Async         = true,
    Async_Thread  = true,
    _Async_Isr    = true,
    Await_Ext     = true,
    Await_Wclock  = true,
    Await_Forever = true,
}

local function run (me, Loop)
    assert(AST.is_node(me))

    local int_await do
        if me.tag == 'Await_Int' then
            local parand = AST.par(me, 'Par_And')
            local paror  = AST.par(me, 'Par_Or')
            if parand and AST.depth(parand)>AST.depth(Loop) or
               paror  and AST.depth(paror)>AST.depth(Loop)
            then
                -- TIGHT
                --  loop do
                --      par/and do
                --          await int;
                --      with
                --          ... // possibly "emit int"
                --      end
                --  end
                int_await = false
            else
                int_await = true
            end
        end
    end

    if awaits[me.tag] or int_await or (me.tag=='Loop' and me.tight=='awaits') then
        return 'awaits'

    elseif me.tag=='Break' or me.tag=='Escape' then
        if AST.depth(Loop) >= AST.depth(me.outer) then
            return 'breaks'
else
error'TODO'
        end

    elseif me.tag=='If' or me.tag=='Par_Or' then
        local T do
            if me.tag == 'If' then
                local _,t,f = unpack(me)
                T = { t, f }
            else
                T = me
            end
        end
        local awaits = true
        for _,sub in ipairs(T) do
            local ret = run(sub, Loop)
            if ret == 'tight' then
                return 'tight'              -- "tight" if found at least one tight
            elseif ret == 'breaks' then
                awaits = false
            else
                assert(ret == 'awaits')
            end
        end
        if awaits then
            return 'awaits'                 -- "awaits" if all await
        else
            return 'breaks'                 -- "breaks" otherwise
        end

    elseif me.tag == 'Loop' then
        if me.tight == 'breaks' then
            return 'tight'
        else
            return 'awaits'
        end

    else
        for _, child in ipairs(me) do
            if AST.is_node(child) then
                local ret = run(child, Loop)
                if ret ~= 'tight' then
                    return ret
                end
            end
        end
        return 'tight'
    end
end

F = {
    __loop = function (me, body, is_bounded)
        me.tight = run(body, me)

        if me.tight == 'tight' then
            if is_bounded or max then
                me.tight = 'bounded'
            end
        end
        if me.tight ~= 'tight' then
            return
        end

        local in_async = AST.par(me,'Async') or AST.par(me,'Async_Thread')
                            or AST.par(me,'Async_Isr')
        WRN(in_async, me,
            'invalid tight `loop´ : unbounded number of non-awaiting iterations')
    end,

    Loop = function (me)
        local max, body = unpack(me)
        F.__loop(me, body, max)
    end,

    Loop_Num = function (me)
        local max, _, range, body = unpack(me)
        local fr,_,to,_ = unpack(range)
        F.__loop(me, body, max or (fr.is_const and to.is_const))
    end,
}

AST.visit(F)

local impls = {}

G = {
    Code = function (me)
        if not me.is_impl then
            return
        end
        local _,_,id = unpack(me)
        local blk = AST.par(me, 'Block')
        local old = DCLS.get(blk, id)
        impls[old] = true
    end,

    Abs_Call = function (me)
        local mods_call, Abs_Cons = unpack(me)
        local Code = AST.asr(Abs_Cons,'', 1,'ID_abs').dcl
        local _,mods_dcl = unpack(Code)

        -- calling known Code
        if impls[Code] then
            if mods_call.recursive then
                ASR(mods_dcl.recursive, me,
                    'invalid `call´ : unexpected `/recursive´')
            else
                ASR(not mods_dcl.recursive, me,
                    'invalid `call´ : expected `/recursive´')
            end

        -- calling unknown Code
        else
            -- Code must be '/recursive'
            ASR(mods_dcl.recursive, Code,
                'invalid `code´ declaration : expected `/recursive´ : `call´ to unknown body ('..me.ln[1]..':'..me.ln[2]..')')

            -- Call must be '/recursive'
            ASR(mods_call.recursive, me,
                'invalid `call´ : expected `/recursive´ : `call´ to unknown body')
        end

        -- calling from Par code with '/recursive'
        local Par = AST.par(me,'Code')
        if Par and mods_call.recursive then
            -- Par must be '/recursive'
            local _,mods_dcl = unpack(Par)
            ASR(mods_dcl.recursive, Par,
                'invalid `code´ declaration : expected `/recursive´ : nested `call/recursive´ ('..me.ln[1]..':'..me.ln[2]..')')
        end
    end,
}

AST.visit(G)

end

    
do
local NO = {
    Every = {
        Await_Forever=true, Await_Ext=true, Await_Int=true, Await_Wclock=true,
        Abs_Await=true, Every=true, Finalize=true,
    },
    Loop_Pool = {
        Await_Forever=true, Await_Ext=true, Await_Int=true, Await_Wclock=true,
        Abs_Await=true, Every=true, Finalize=true,
    },
    Async = {
        Await_Forever=true, Await_Ext=true, Await_Int=true, Await_Wclock=true,
        Abs_Await=true, Every=true, Finalize=true,
    },
}

F = {
    Node = function (me)
        for k, t in pairs(NO) do
            local par = AST.par(me,k)
            if par and t[me.tag] then
                local sub = par
                if par.tag == 'Every' then
                    local _,Await = unpack(AST.asr(par,'', 1,'Loop', 2,'Block', 1,'Stmts'))
                    if AST.is_par(Await,me) then
                        return -- ok
                    end
                end
                ASR(false, me,
                    'invalid `'..AST.tag2id[me.tag]..
                    '´ : unexpected enclosing `'..AST.tag2id[par.tag]..'´')
            end
        end
    end,

    Emit_Wclock = function (me)
        ASR(AST.par(me,'Async') or AST.par(me,'Isr'), me,
            'invalid `emit´ : expected enclosing `async´ or `async/isr´')
    end,

    __escape = function (me)
-- TODO: join all possibilities (thread/isr tb)
        local Async = AST.par(me,'Async')
        if Async then
            ASR(AST.depth(me.outer) > AST.depth(Async), me,
                'invalid `'..AST.tag2id[me.tag]..'´ : unexpected enclosing `async´')
        end

--[[
        local Every = AST.par(me,'Every')
        if Every then
            ASR(me.outer.__depth > Every.__depth, me,
                'invalid `'..AST.tag2id[me.tag]..'´ : unexpected enclosing `every´')
        end
]]

        local Finalize = AST.par(me,'Finalize')
        if Finalize then
            local _,_,later = unpack(Finalize)
            if AST.is_par(later,me) then
                ASR(AST.depth(me.outer) > AST.depth(Finalize), me,
                    'invalid `'..AST.tag2id[me.tag]..'´ : unexpected enclosing `finalize´')
            end
        end
    end,
    Break = function (me)
        F.__escape(me)
        if me.outer then
            me.outer.has_break = true       -- avoids unnecessary CLEAR
        end
    end,
    Continue = function (me)
        F.__escape(me)
        if me.outer then
            me.outer.has_continue = true    -- avoids unnecessary CLEAR
        end
    end,
    Escape = function (me)
        F.__escape(me)
        if me.outer then
            me.outer.has_escape = true      -- avoids unnecessary CLEAR
        end
    end,

    List_Var = function (me)
        local watch = AST.par(me,'Loop_Pool') or AST.par(me,'Watching')
        for _, ID in ipairs(me) do
            if ID.tag ~= 'ID_any' then
                ID.dcl.__no_access = watch  -- no access outside watch
            end
        end
    end,
    Set_Alias = function (me)
        local fr, to = unpack(me)
        local watch = AST.par(me,'Loop_Pool') or AST.par(me,'Watching')
        if watch then
            to.info.dcl.__no_access = watch -- no access outside watch
        end
    end,
    ID_int = function (me)
        local no = me.dcl[1]~='&?' and me.dcl.__no_access
        if no then
            ASR(AST.is_par(no, me), me,
                'invalid access to internal identifier "'..me.dcl.id..'"'..
                ' : crossed `'..AST.tag2id[no.tag]..'´'..
                ' ('..no.ln[1]..':'..no.ln[2]..')')
        end
    end,

    --------------------------------------------------------------------------

    Code = function (me)
        local _,mods,_,body = unpack(me)
        if mods.dynamic and body then
            local Code_Pars = AST.asr(body,'', 1,'Stmts', 1,'Stmts', 1,'Code_Pars')
            for i, dcl in ipairs(Code_Pars) do
                if dcl.mods.dynamic then
                    local _,Type,id = unpack(dcl)
                    local data = AST.get(Type,'',1,'ID_abs')
                    ASR(data and data.dcl.hier, me,
                        'invalid `dynamic´ declaration : parameter #'..i..
                        ' : expected `data´ in hierarchy')
                end
            end
        end
    end,

    __check = function (me)
        local _,num = unpack(me)
        ASR(num, me, 'invalid `data´ declaration : missing `is´')
        for _, sub in ipairs(me.hier.down) do
            F.__check(sub)
        end
    end,

    Data = function (me)
        local _,num = unpack(me)
        if num then
            ASR(me.hier, me, 'invalid `is´ declaration : expected `data´ hierarchy')
            F.__check(DCLS.base(me))
        end
    end,

    --------------------------------------------------------------------------

    Abs_Spawn_Single = '_in_loop_pool',
    Abs_Spawn_Pool   = '_in_loop_pool',
    Emit_Evt         = '_in_loop_pool',
    _in_loop_pool = function (me)
        for n in AST.iter() do
            if n.tag == 'Loop_Pool' then
                n.yields = true
            end
        end
    end,

    Loop_Pool = function (me)
        local _,list,pool = unpack(me)
        local Code = AST.asr(pool.info.dcl,'Pool', 2,'Type', 1,'ID_abs').dcl
        local ret = AST.get(Code,'Code', 4,'Block', 1,'Stmts',
                                         1,'Stmts', 3,'', 2,'Type')
        me.yields = me.yields and ret
            -- if "=>FOREVER" counts as not yielding

        if list and me.yields then
            for _,ID in ipairs(list) do
                if ID.tag ~= 'ID_any' then
                    ASR(ID.dcl[1] == '&?', me,
                        'invalid declaration : expected `&?´ modifier : yielding `loop´')
                end
            end
        end
    end,

    --------------------------------------------------------------------------

    Lua_Do = 'Lua',
    Lua = function (me)
        ASR(CEU.opts.ceu_features_lua, me, '`lua´ support is disabled')
    end,

    Async_Thread = function (me)
        ASR(CEU.opts.ceu_features_thread, me, '`async/thread´ support is disabled')
    end,
}

AST.visit(F)

end

    
do
local function MAX (v1, v2)
    return (v1 > v2) and v1 or v2
end

local function MAX_all (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if AST.is_node(sub) then
            me.trails_n = MAX(me.trails_n, sub.trails_n)
        end
    end
end

F = {
    Node__PRE = function (me)
        me.trails_n = 1
    end,
    Node__POS = function (me)
        if not F[me.tag] then
            MAX_all(me)
        end

        if me.tag=='Code' and me[2].await then
            me.trails_n = me.trails_n + 1   -- TODO-NOW
        end
    end,

    Block__PRE = function (me)
        me.spawns = {}
    end,
    Block = function (me)
        MAX_all(me)

        for _, dcl in ipairs(me.dcls) do
            local alias, Type = unpack(dcl)

            local abs = AST.get(Type,'Type') and TYPES.abs_dcl(Type,'Data')
            if dcl.tag=='Var' and abs then
                me.has_fin = me.has_fin or abs.has_fin
                local data = AST.par(me,'Data')
                if data then
                    data.has_fin = me.has_fin
                end
            end

            -- +1 for each "var/event&? ..."
            if (alias == '&?') and (not (dcl.tag=='Var' and TYPES.is_nat(Type))) then
                if not AST.par(dcl, 'Code_Pars') then
                    dcl.has_trail = true
                    me.trails_n = me.trails_n + 1
                end

            -- +1 for each pool
            elseif dcl.tag == 'Pool' then
                if (not alias) and Type[1].dcl.tag=='Code' then
                    dcl.has_trail = true
                    me.trails_n = me.trails_n + 1
                end
            end
        end

        if me.has_fin then
            me.trails_n = me.trails_n + 1
        end
        if me.fins_n > 0 then
            me.trails_n = me.trails_n + 3*me.fins_n
        end
        me.trails_n = me.trails_n + #me.spawns
    end,

    Vec = function (me)
        local is_alias, tp, _, dim = unpack(me)
        if (not TYPES.is_nat(TYPES.get(tp,1))) then
            if not (is_alias or dim.is_const) then
                AST.par(me,'Block').has_fin = true
                local data = AST.par(me,'Data')
                if data then
                    data.has_fin = true
                end
            end
        end
    end,
    Pool = function (me)
        local is_alias, _, _, dim = unpack(me)
        if not (is_alias or dim~='[]') then
            AST.par(me,'Block').has_fin = true
        end
    end,

    Abs_Spawn_Single = function (me)
        local blk = AST.par(me,'Block')
        blk.spawns[#blk.spawns+1] = me
    end,

    Loop_Pool = function (me)
        local _, _, _, body = unpack(me)
        if me.yields then
            me.trails_n = body.trails_n + 1
        end
    end,

    Pause_If = function (me)
        local _, body = unpack(me)
        me.trails_n = 1 + body.trails_n
    end,

    Async_Thread = function (me)
        local body = unpack(me)
        me.trails_n = 1 + body.trails_n
    end,

    If = function (me)
        local c, t, f = unpack(me)
        MAX_all(me, {t,f})
    end,

    Par_And = 'Par',
    Par_Or  = 'Par',
    Par = function (me)
        me.trails_n = 0
        for _, sub in ipairs(me) do
            me.trails_n = me.trails_n + sub.trails_n
        end
    end,
}

AST.visit(F)

-------------------------------------------------------------------------------

G = {
    ROOT__PRE = function (me)
        me.trails = { 0, me.trails_n-1 }     -- [0, N]
    end,
    Code__PRE = 'ROOT__PRE',

    Node__PRE = function (me)
        if (not me.trails) and me.__par then
            me.trails = { unpack(me.__par.trails) }
        end

-- TODO-NOW
if me.tag == 'Block' then
    local Code = AST.get(AST.par(me,'Code'),'')
    if Code and Code[2].await and AST.get(Code,'',4,'Block')==me then
        me.trails[2] = me.trails[2] - 1
    end
end
    end,

    Node__POS = function (me)
        --DBG(me.ln[2], me.tag, unpack(me.trails))
    end,

    Stmts__BEF = function (me, sub, i)
        if i == 1 then
            me._trails = { unpack(me.trails) }
            if me.__par.tag=='Block' and me.__par.has_fin then
                me._trails[1] = me._trails[1]+1
            end
        end
        if sub.tag == 'Code' then
            return
        end

        sub.trails = { unpack(me._trails) }

        local spawn = AST.get(sub, 'Abs_Spawn_Single')
        local pool  = AST.get(sub, 'Pool')
        local var   = AST.get(sub, 'Var')
        local evt   = AST.get(sub, 'Evt')

        if sub.tag=='Finalize' or spawn
            or (sub.tag == 'Async_Thread')
            or (pool and pool.has_trail) or (var and var.has_trail)
            or (evt and evt.has_trail)
        then
            local n = (sub.tag=='Finalize' and 3) or 1
            for stmts in AST.iter() do
                if stmts.tag == 'Stmts' then
                    stmts._trails[1] = stmts._trails[1] + n
                else
                    break
                end
            end
        end
    end,

    Loop_Pool__PRE = function (me)
        local _, _, _, body = unpack(me)
        body.trails = { unpack(me.trails) }
        if me.yields then
            body.trails[1] = body.trails[1] + 1
        end
    end,

    Pause_If__PRE = function (me)
        local _,body = unpack(me)
        body.trails = { unpack(me.trails) }
        body.trails[1] = body.trails[1] + 1
    end,

    Par_Or__PRE  = 'Par__PRE',
    Par_And__PRE = 'Par__PRE',
    Par__PRE = function (me)
        for i, sub in ipairs(me) do
            sub.trails = {}
            if i == 1 then
                sub.trails[1] = me.trails[1]
            else
                local pre = me[i-1]
                sub.trails[1] = pre.trails[1] + pre.trails_n
            end
            sub.trails[2] = sub.trails[1] + sub.trails_n-1
        end
    end,
}

AST.visit(G)


end

    
do
LABELS = {
    list = {},      -- { [lbl]={}, [i]=lbl }
}

local function new (lbl)
    if lbl[2] then
        lbl.id = 'CEU_LABEL_'..lbl[1]
    else
        local Code = AST.iter'Code'()
        Code = (Code and Code.id..'_') or ''
        lbl.id = 'CEU_LABEL_'..Code..lbl[1]..'_'..(#LABELS.list+1)
    end
    if not LABELS.list[lbl.id] then
        LABELS.list[lbl.id] = true
        LABELS.list[#LABELS.list+1] = lbl
        lbl.n = #LABELS.list+1                   -- starts from 2
    end

    return lbl
end

F = {
    ROOT__PRE = function (me)
        me.lbl_in = new{'ROOT', true}
    end,

    Do = function (me)
        local _,_,set = unpack(me)
        me.lbl_out = new{'Do__OUT'}
    end,

    Block = function (me)
        if me.has_fin then
            me.lbl_fin = new{'Block__FIN'}
        end
    end,

    Finalize = function (me)
        me.lbl_in = {
            new{'Finalize__IN'},
            new{'Pause__IN'},
            new{'Resume__IN'},
        }
    end,

    Loop_Pool = function (me)
        F.Loop(me)
        me.lbl_clr = new{'Loop_Pool__CLR'}
    end,
    Loop = function (me)
        me.lbl_cnt = new{'Loop_Continue__CNT'}
        me.lbl_out = new{'Loop_Break__OUT'}
        if AST.par(me,'Async') then
            me.lbl_asy = new{'Loop_Async__CNT'}
        end
    end,
    Loop_Num = 'Loop',

    Code = function (me)
        me.lbl_in = new{'Code_'..me.id, true}
    end,

    Evt = 'Var',
    Var = function (me)
        if me.has_trail then
            me.lbl = new{'Var_'..me.id}
        end
    end,

    ---------------------------------------------------------------------------

    Par_Or__PRE  = 'Par__PRE',
    Par_And__PRE = 'Par__PRE',
    Par__PRE = function (me)
        me.lbls_in = {}
        for i, sub in ipairs(me) do
            me.lbls_in[i] = new{me.tag..'_sub_'..i..'_IN'}
        end
        if me.tag ~= 'Par' then
            me.lbl_out = new{me.tag..'__OUT'}
        end
    end,

    ---------------------------------------------------------------------------

    Abs_Await = function (me)
        me.lbl_out = new{'Await_Abs__OUT'}
    end,
    Await_Wclock = function (me)
        me.lbl_out = new{'Await_Wclock__OUT'}
    end,
    Await_Pause = function (me)
        me.lbl_out = new{'Await_Pause__OUT'}
    end,
    Await_Resume = function (me)
        me.lbl_out = new{'Await_Resume__OUT'}
    end,
    Await_Ext = function (me)
        local ID_ext = unpack(me)
        me.lbl_out = new{'Await_'..ID_ext.dcl.id..'__OUT'}
    end,
    Await_Int = function (me)
        local Exp_Name = unpack(me)
        me.lbl_out = new{'Await_'..Exp_Name.info.dcl.id..'__OUT'}
    end,

    Emit_Wclock = function (me)
        me.lbl_out = new{'Emit_Wclock__OUT'}
    end,
    Emit_Ext_emit = function (me)
        local ID_ext = unpack(me)
        me.lbl_out = new{'Emit_Ext_emit'..ID_ext.dcl.id..'__OUT'}
    end,

    Async = function (me)
        me.lbl_in = new{'Async__IN'}
    end,

    Async_Thread = function (me)
        me.lbl_fin = new{'Async_Thread__FIN'}
        me.lbl_abt = new{'Async_Thread__ABT'}
        me.lbl_out = new{'Async_Thread__OUT'}
    end,
}

AST.visit(F)

end

    
do
local _ceu2c = { ['&&']='&', ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

local F

function CUR (field, ctx)
    ctx = ctx or {}
    local Code = AST.iter'Code'()
    local data do
        if Code and (not ctx.is_outer) then
            data = '(*((tceu_code_mem_'..Code.id..'*)_ceu_mem))'
        else
            data = 'CEU_APP.root'
        end
    end
    local base = (ctx.base and ctx.base..'.') or ''
    return '('..data..'.'..base..field..')'
end

function V (me, ctx)
    ctx = ctx or {}
    local f = assert(F[me.tag], 'bug found : V('..me.tag..')')
    while type(f) == 'string' do
        f = assert(F[f], 'bug found : V('..me.tag..')')
    end

    local ret = f(me, ctx)

    if type(ret) == 'string' then
        return string.gsub(ret, '%(%&%(%*', '((')
    end

    return ret
end

F = {
    Exp_Name = function (me, ctx)
        local e = unpack(me)
        return V(e, ctx)
    end,

-- PRIMITIVES

    NULL = function (me)
        return 'NULL'
    end,

    NUMBER = function (me)
        return me[1]
    end,

    BOOL = function (me)
        return me[1]
    end,

    STRING = function (me)
        return me[1]
    end,

-- WCLOCK

    WCLOCKK = function (me)
        return me.us
    end,

    WCLOCKE = function (me)
        local e, unit = unpack(me)
        return '('.. V(e) .. ')*' .. CONSTS.t2n[unit]
    end,

-- SIZEOF

    SIZEOF = function (me)
        local e = unpack(me)
        if e.tag == 'Type' then
            return '(sizeof('..TYPES.toc(e)..'))'
        else
            return '(sizeof('..V(e)..'))'
        end
    end,

-- CALL

    Exp_Call = function (me)
        local _, e, ps = unpack(me)
        return V(e)..'('..table.concat(V(ps),',')..')'
    end,

    Abs_Call = function (me)
        local _, Abs_Cons = unpack(me)
        local ID_abs, _ = unpack(Abs_Cons)
        local _,mods,_,Code_Pars = unpack(ID_abs.dcl)
        assert(mods.tight)
        if CEU.opts.ceu_features_lua then
            return [[
CEU_CODE_]]..ID_abs.dcl.id..[[(_ceu_stk, _ceu_trlK,
                            ]]..V(Abs_Cons)..[[, ]]..LUA(me)..[[)
]]
        else
            return [[
CEU_CODE_]]..ID_abs.dcl.id..[[(_ceu_stk, _ceu_trlK,
                            ]]..V(Abs_Cons)..[[)
]]
        end
    end,

    Abs_Cons = function (me, ctx)
        local ID_abs, Abslist = unpack(me)

        local id_struct do
            if ID_abs.dcl.tag == 'Data' then
                id_struct = 'tceu_data_'..ID_abs.dcl.id_
            else
                id_struct = 'tceu_code_args_'..ID_abs.dcl.id
            end
            if ctx.to_tp then
                id_struct = ctx.to_tp
            end
        end

        local ps = {}

        if ID_abs.dcl.tag == 'Data' then
            if ID_abs.dcl.hier then
                ps[1] = '._enum = CEU_DATA_'..ID_abs.dcl.id_
            end
        end

        local mods = (ID_abs.dcl.tag=='Code' and ID_abs.dcl[2])

        assert(#me.vars == #Abslist)
        for i=1, #me.vars do
            local var = me.vars[i]
            local val = Abslist[i]

            local var_is_alias, var_tp, var_id, var_dim = unpack(var)
            if ID_abs.dcl.tag == 'Code' then
                var_id = '_'..i
            end

            -- var Ee.Xx ex = ...;
            -- code Ff (var& Ee e)
            -- Ff(&ex)
            local cast = ''
            if var_tp.tag=='Type' and var_tp[1].tag=='ID_abs' and var_tp[1].dcl.tag=='Data' then
                if TYPES.check(var_tp,'&&') then
                    cast = '('..TYPES.toc(var_tp)..')'
                elseif var_is_alias then
                    cast = '('..TYPES.toc(var_tp)..'*)'
                end

                if mods and mods.dynamic and var_tp[1].dcl.hier then
                    if val.tag == 'Exp_as' then
                        ps[#ps+1] = '._data_'..i..' = CEU_DATA_'..val.info.tp[1].dcl.id
                    else
                        ps[#ps+1] = '._data_'..i..' = '..V(val,ctx)..'->_enum'
                    end
                end
            end

            if TYPES.check(var_tp,'?') and (not var_is_alias) and
               (not (val.info and TYPES.check(val.info.tp,'?')))
            then
                if val.tag == 'ID_any' then
                    ps[#ps+1] = '.'..var_id..' = { .is_set=0 }'
                else
                    ps[#ps+1] = '.'..var_id..' = { .is_set=1, .value='..V(val)..'}'
                end
            else
                local to_val = ctx.to_val
                if val.tag == 'ID_any' then
                    -- HACK_09: keep what is there
                    --  data Dd with
                    --      vector[] int x;
                    --  end
                    --  var Dd d = val Dd(_);   // x is implicitly init'd
                    if to_val then  -- only set for Set_Abs_Val ("data")
                        if var.tag=='Evt' or var.tag=='Vec' and TYPES.is_nat(var_tp) then
                            -- don't initialize
                            --  event ...;
                            --  vector[] _int x;
                        else
                            ps[#ps+1] = '.'..var_id..' = '..to_val..'.'..var_id
                        end
                    end
                else
                    local ctx = {}
                    if val.tag == 'Abs_Cons' then
                        -- typecast: "val Xx = val Xx.Yy();"
                        ctx.to_tp  = TYPES.toc(var_tp)
                        if to_val then  -- only set for Set_Abs_Val ("data")
                            ctx.to_val = '('..to_val..'.'..var_id..')'
                        end
                    end
                    ps[#ps+1] = '.'..var_id..' = '..cast..V(val,ctx)
                end
            end
        end

        if ctx.mid then
            for i, var in ipairs(ctx.mid) do
                -- extra indirection for mid's
                if var.tag == 'ID_any' then
                    ps[#ps+1] = '._'..(i+#me.vars)..' = NULL'
                else
                    ps[#ps+1] = '._'..(i+#me.vars)..' = &'..V(var,{is_bind=true})
                end
            end
        end

        return '(struct '..id_struct..')'..
                    '{\n'..table.concat(ps,',\n')..'\n}'
    end,

    List_Exp = function (me)
        local vs = {}
        for i, p in ipairs(me) do
            vs[i] = V(p)
        end
        return vs
    end,

    ---------------------------------------------------------------------------

    ID_ext = function (me)
        return '((tceu_evt){'..me.dcl.id_..',{NULL}})'
    end,

    ID_nat = function (me)
        local v1,v2 = unpack(me)
        if v1 == '_{}' then
            -- { nat }
            return v2
        else
            -- _nat
            return string.sub(v1, 2)
        end
    end,

    Evt = function (me, ctx)
        local is_alias = unpack(me)
        if is_alias then
            return CUR(me.id_,ctx)
        else
            return '((tceu_evt){'..me.id_..',{_ceu_mem}})'
        end
    end,

    Pool = 'Var',
    Vec = 'Var',
    Var = function (me, ctx)
        local id_suf = (ctx and ctx.id_suf) or ''
        local alias, tp = unpack(me)
        local ptr = ''
        if alias=='&' and (not ctx.is_bind) then
            --  var&? _t_ptr x = &_f(); ... x!
            --  var& _t_ptr xx = &x!;   ... xx
            ptr = '*'
        end
        return '('..ptr..CUR(me.id_..id_suf,ctx)..')'
    end,

    ID_int = function (me, ctx)
        local f = F[me.dcl.tag]
        if type(f) == 'string' then
            f = F[f]
        end
        return f(me.dcl, ctx)
    end,

    ---------------------------------------------------------------------------

-- MEMBER: .

    ['Exp_.'] = function (me)
        local _, e, member = unpack(me)
        member = string.gsub(member, '^_', '')  -- _nat._data (data is a keyword)

        local is_alias = unpack(me.info.dcl)

        if me.info.dcl.tag=='Evt' and (not is_alias) then
            if e.tag == 'Outer' then
                return '((tceu_evt){ '..me.info.dcl.id_..', {&CEU_APP.root} })'
            else
                return '((tceu_evt){ '..me.info.dcl.id_..', {&'..V(e)..'} })'
            end
        elseif e.tag == 'Outer' then
            return F.ID_int(me,{is_outer=true})
        else
            local ptr = ''
            if not TYPES.is_nat(e.info.tp) then
                if is_alias and me.info.dcl.tag~='Evt' then
                    ptr = '*'
                end
            end

            return '('..ptr..'('..V(e)..'.'..member..'))'
        end
    end,

-- BIND

    ['Exp_1&'] = function (me)
        local _, e = unpack(me)
        local dcl = e.info.dcl
        if dcl and dcl.tag == 'Evt' then
            return V(e)
        elseif e.tag=='Exp_Call' or e.tag=='Abs_Call' then
            -- x = &_f();
            return V(e)
        elseif dcl[1] == '&?' then
            return V(e)
        else
            return '(&'..V(e)..')'
        end
    end,

-- INDEX

    ['Exp_idx'] = function (me)
        local _,arr,idx = unpack(me)
        if TYPES.is_nat(TYPES.get(arr.info.tp,1)) then
            return '('..V(arr)..'['..V(idx)..'])'
        elseif AST.get(me,2,'Exp_&&',2,'Exp_Name',1,'')==me then
            return [[
(*(]]..TYPES.toc(me.info.tp)..[[*) ceu_vector_buf_get(&]]..V(arr)..','..V(idx)..[[))
]]
        else
            return [[
(*(]]..TYPES.toc(me.info.tp)..[[*) ceu_vector_geti(&]]..V(arr)..','..V(idx)..[[))
]]
        end
    end,

-- OPTION: ?, !

    ['Exp_?'] = function (me)
        local _, e = unpack(me)
        local alias, tp = unpack(e.info.dcl)
        if alias == '&?' then
            if e.info.dcl.tag=='Var' and TYPES.is_nat(tp) then
                return '('..V(e)..' != NULL)'
            else
                return '('..V(e)..'.alias != NULL)'
            end
        else
            return '('..V(e)..'.is_set)'
        end
    end,

    ['Exp_!'] = function (me)
        local _, e = unpack(me)
        local alias, tp = unpack(e.info.dcl)
        if alias == '&?' then
            if e.info.dcl.tag == 'Var' then
                if TYPES.is_nat(tp) then
                    return '(*CEU_OPTION_'..TYPES.toc(e.info.tp)..'('..V(e,{is_bind=true})..', __FILE__, __LINE__))'
                else
                    return '(*CEU_OPTION_'..TYPES.toc(e.info.tp)..'('..V(e)..'.alias, __FILE__, __LINE__))'
                end
            elseif e.info.dcl.tag == 'Evt' then
                return '(*CEU_OPTION_EVT('..V(e)..'.alias, __FILE__, __LINE__))'
            else
                error 'not implemented'
            end
        else
            return '(CEU_OPTION_'..TYPES.toc(e.info.tp)..'(&'..V(e)..', __FILE__, __LINE__)->value)'
        end
    end,

-- VECTOR LENGTH: $, $$

    ['Exp_$$'] = function (me)
        local _, e = unpack(me)
        return '('..V(e)..'.max)'
    end,
    ['Exp_$'] = function (me)
        local _, e = unpack(me)
        return '('..V(e)..'.len)'
    end,

-- UNARY

    ['Exp_1*']  = 'Exp_1',
    ['Exp_&&']  = 'Exp_1',
    ['Exp_1+']  = 'Exp_1',
    ['Exp_1-']  = 'Exp_1',
    ['Exp_not'] = 'Exp_1',
    Exp_1 = function (me)
        local op,e = unpack(me)
        return '('..ceu2c(op)..V(e)..')'
    end,

-- BINARY

    ['Exp_+']   = 'Exp_2',
    ['Exp_-']   = 'Exp_2',
    ['Exp_*']   = 'Exp_2',
    ['Exp_/']   = 'Exp_2',
    ['Exp_%']   = 'Exp_2',
    ['Exp_|']   = 'Exp_2',
    ['Exp_&']   = 'Exp_2',
    ['Exp_==']  = 'Exp_2',
    ['Exp_!=']  = 'Exp_2',
    ['Exp_or']  = 'Exp_2',
    ['Exp_and'] = 'Exp_2',
    ['Exp_>']   = 'Exp_2',
    ['Exp_<']   = 'Exp_2',
    ['Exp_<=']  = 'Exp_2',
    ['Exp_>=']  = 'Exp_2',
    Exp_2 = function (me)
        local op,e1,e2 = unpack(me)
        return '('..V(e1)..ceu2c(op)..V(e2)..')'
    end,

-- IS, AS/CAST

    Exp_is = function (me)
        local _, e, Type = unpack(me)
        local base = DCLS.base(Type[1].dcl)
        return 'ceu_data_is(CEU_DATA_SUPERS_'..base.id_..','..
                            V(e)..'._enum, CEU_DATA_'..Type[1].dcl.id_..')'
    end,

    Exp_as = function (me)
        local _, e, Type = unpack(me)

        if Type.tag ~= 'Type' then
            return V(e)
        end

        -- data Xx=1; (x as int);
        local plain = TYPES.ID_plain(e.info.tp)
        if plain and plain.dcl and plain.dcl.tag=='Data'
            and TYPES.check(Type,'int')
        then

            return '(CEU_DATA_NUMS_'..plain.dcl.id_..'['..V(e)..'._enum])'
        end

        local ret do
            if Type[1].tag=='ID_abs' and Type[1].dcl.tag=='Data' then
                local ptr1,ptr2,ptr3 = '*', '*', '&'
                if TYPES.check(Type,'&&') then
                    ptr1, ptr2, ptr3 = '', '', ''
                elseif e.info.tag == 'Alias' then
                    ptr1, ptr2, ptr3 = '', '*', ''
                end

                local base = DCLS.base(Type[1].dcl)
                ret = [[
(]]..ptr1..[[(
(]]..TYPES.toc(Type)..ptr2..[[)
ceu_data_as(CEU_DATA_SUPERS_]]..base.id_..[[,
            (tceu_ndata*)]]..ptr3..V(e)..', CEU_DATA_'..Type[1].dcl.id_..[[,
            __FILE__, (__LINE__-4))
))
]]
            else
                ret = [[
((]]..TYPES.toc(Type)..')'..V(e)..[[)
]]
            end
        end
        if TYPES.check(Type,'bool') then
            ret = '('..ret..'? 1 : 0)'
        end
        return ret
    end,
}

end

    
do
MULTIS = {}

local function down (T, i, sup, ret)
    local t = T[i]
    local dyn = unpack(T[i])
    local up = ret[#ret]
    for _, dcl in ipairs(sup.hier.down) do
        local me = {
            data = 'CEU_DATA_'..TYPES.noc(dcl.id),
            dyn  = string.gsub(t.dyn, '_'..t.base.id,
                                      '_'..TYPES.noc(dcl.id)),
            id   = dcl.id,

            idx  = #ret+1,
            left = ret,
            up   = up,
        }
        ret[#ret+1] = me
        down(T, i, dcl, ret)
        fff(T, i+1, me)
    end
end

function fff (T , i, ret)
    if i > #T then
        return
    end
    assert(#ret == 0)

    local t = T[i]
    local me = {
        data = 'CEU_DATA_'..TYPES.noc(t.base.id),
        dyn  = t.dyn,
        id   = t.base.id,

        idx  = #ret+1,
        left = ret,
        up   = nil,
    }
    ret[#ret+1] = me
    down(T, i, t.base, ret)
    fff(T, i+1, me)
end

--[[
function dump (ret, spc)
    spc = spc or ''
    if #ret == 0 then
        local dyn = ret.dyn
        while ret.left.dyn do
            dyn = ret.left.dyn..dyn
            ret = ret.left
        end
        local has = DCLS.get(AST.par(AST.iter()(),'Block'), dyn)
        print(spc..dyn)
        print(spc..'('..tostring(has)..')')
    else
        for i, t in ipairs(ret) do
            local spc = spc..'  '
            --print(spc..'{ id='..t.id..',')
            print(spc..'['..i..'] = { data='..t.data..', id='..t.id..
                                    ', up='..(t.up and t.up.id or '')..
                                    ', left='..(t.left.id or '')..',')
            dump(t, spc..' ')
            print(spc..'}')
        end
    end
end
]]

function get (Code, ret, goleft)
    local dyn = ret.dyn
    local cur = ret
    while cur.left.dyn do
        dyn = cur.left.dyn..dyn
        cur = cur.left
    end
    dyn = Code.id..dyn

    local dcl = DCLS.get(AST.par(Code,'Block'), dyn)
    if dcl then
        return dcl
    end

    if ret.up then
--DBG'up'
        dcl = get(Code, ret.up, false)
        if dcl then
            return dcl
        end
    end
--DBG('>>>', dyn)

    if goleft then
--DBG'left'
        local idxs = { ret.idx }
        local left = assert(ret.left)
        while not left.up do
--DBG('>>>', left.id, left, left.left)
            left = assert(left.left)
            idxs[#idxs+1] = 1
        end
        local t = left.up
        for i=#idxs,1,-1 do
            t = t[ idxs[i] ]
        end
--DBG'---'
        dcl = get(Code, t, true)
--DBG'<<<'
        return assert(dcl)
    end
end

--[[
function dump2 (Code, ret, spc)
    spc = spc or ''
    if #ret == 0 then
        return (spc..get(Code,ret,true).id)..'\n'
    else
        local str = ''
        for i, t in ipairs(ret) do
            local spc = spc..'  '
            --print(spc..'{ id='..t.id..',')
            str = str .. (spc..'['..i..'] = { data='..t.data..', id='..t.id..
                            --', me='..string.sub(tostring(t),8)..
                            --', left='..string.sub(tostring(t),8)..
                            ', up='..(t.up and t.up.id or '')..
                            ', left='..(t.left.id or '')..',') .. '\n'
            str = str .. dump2(Code, t, spc..' ')
            str = str .. (spc..'}') .. '\n'
        end
        return str
    end
end
]]

function dump3 (Code, ret, spc)
    spc = spc or ''
    if #ret == 0 then
        return spc..'CEU_LABEL_Code_'..get(Code,ret,true).id..',\n'
    else
        local str = ''
        for i, t in ipairs(ret) do
            local spc = spc..' '
            if #t > 0 then
                str = str..spc..'{\n'..dump3(Code,t,spc..' ')..spc..'},\n'
            else
                str = str..dump3(Code,t,spc)
            end
        end
        return str
    end
end

function dims (ret)
    if #ret > 0 then
        return '['..#ret..']'..dims(ret[1])
    else
        return ''
    end
end

function MULTIS.tostring (Code, T)
    local ret = {}
    fff(T, 1, ret)
    return dims(ret), dump3(Code, ret)
end

end

    
do
MEMS = {
    exts = {
        types       = '',
        enum_input  = '',
        enum_output = '',
        defines_input_output = '',
    },
    evts = {
        types = '',
        enum  = '',
    },
    codes = {
        mems     = '',
        wrappers = '',
        args     = '',
--[[
        [1] = {
            mem     = '',
            wrapper = '',
            args    = '',
        }
]]
    },
    datas = {
        id    = 1,
        mems  = '',
        hiers = '',
        bases = {},
    },
    opts = {
        -- avoids duplications
        --[TYPES.tostring(tp)] = true,
    },
}

local EVENT_SUFIX_EXISTS = {}

local function CUR ()
    return (AST.iter'Code'() or AST.iter'Data'() or AST.root).mems
end

F = {
    ROOT__PRE = function (me)
        me.mems = { mem='' }
    end,
    ROOT__POS = function (me)
        me.mems.mem = [[
typedef struct tceu_code_mem_ROOT {
    tceu_code_mem mem;
    tceu_trl      trails[]]..me.trails_n..[[];
    ]]..me.mems.mem..[[
} tceu_code_mem_ROOT;
]]..'\n'
        MEMS.codes[#MEMS.codes+1] = me.mems
    end,

    ---------------------------------------------------------------------------

    Code__PRE = function (me)
        me.mems = { me=me, mem='', watch='' }
    end,
    Code__POS = function (me)
        local _,mods,id = unpack(me)

        if me.is_dyn_base then
            me.dyns = {}
            me.mems.mem = ''
        else
            if not me.is_impl then
                return
            end
            if mods.dynamic then
                local t = me.dyn_base.dyns
                t[#t+1] = me.id
            end

            me.mems.mem = [[
typedef struct tceu_code_mem_]]..me.id..[[ {
    tceu_code_mem mem;
    tceu_trl      trails[]]..me.trails_n..[[];
    ]]..me.mems.mem..[[
} tceu_code_mem_]]..me.id..[[;
]]
        end

        MEMS.codes[#MEMS.codes+1] = me.mems
    end,

    Code = function (me)
        local _, mods, _, body = unpack(me)

        if (not me.is_dyn_base) and ((not me.is_impl) or mods.dynamic) then
            me.mems.args = ''
            me.mems.wrapper = ''
            return
        end

        -- args
        me.mems.args = 'typedef struct tceu_code_args_'..me.id..' {\n'

        for i,dcl in ipairs(body.dcls) do
            local alias,Type,id2,dim = unpack(dcl)
            if id2 ~= '_ret' then
                id2 = '_'..i
            end

            local ptr = '' do
                if alias then
                    if (dcl.tag ~= 'Evt') and alias=='&' then
                        ptr = ptr..'*'
                    end
                    if dcl.is_mid_idx then
                        ptr = ptr..'*'  -- extra indirection for mid's
                    end
                end
            end

            -- &?
            if (alias == '&?') and (not (dcl.tag=='Var' and TYPES.is_nat(Type))) then
                    me.mems.args = me.mems.args..[[
tceu_opt_alias]]..ptr..' '..id2..[[;
]]

            -- VAR
            elseif dcl.tag == 'Var' then
                if dcl.id~='_ret' or mods.tight then
                    me.mems.args = me.mems.args..[[
]]..TYPES.toc(Type)..ptr..' '..id2..[[;
]]
                end

            -- EVT
            elseif dcl.tag == 'Evt' then
                assert(alias)
-- TODO: per Code evts
                me.mems.args = me.mems.args .. [[
tceu_evt]]..ptr..' '..id2..[[;
]]

            -- VEC
            elseif dcl.tag == 'Vec' then
                assert(alias)
                if TYPES.is_nat(TYPES.get(Type,1)) then
                    me.mems.args = me.mems.args .. [[
]]..TYPES.toc(Type)..' ('..ptr..id2..')['..V(dim)..[[];
]]
                else
                    me.mems.args = me.mems.args .. [[
tceu_vector]]..ptr..' '..id2..[[;
]]
                end

            -- POOL
            elseif dcl.tag == 'Pool' then
                assert(alias)
                me.mems.args = me.mems.args .. [[
tceu_pool_pak]]..ptr..' '..id2..[[;
]]

            else
                error'bug found'
            end
        end

        local multis = {}
        if mods.dynamic then
            local Code_Pars = AST.asr(body,'', 1,'Stmts', 1,'Stmts', 1,'Code_Pars')
            for i, dcl in ipairs(Code_Pars) do
                if dcl.mods.dynamic then
                    local _,Type,id = unpack(dcl)
                    local data = AST.asr(Type,'',1,'ID_abs')
                    assert(data.dcl.hier and (not data.dcl.hier.up))
                    me.mems.args = me.mems.args .. [[
tceu_ndata _data_]]..i..[[;     /* force multimethod arg data id */
]]

                    -- arg "i" is dynamic:
                    multis[#multis+1] = {
                        base = data.dcl,    -- datatype for the argument
                        dyn  = dcl.id_dyn,  -- identifier considering the "base" value
                        id   = id,          -- argument identifier
                        i    = i,           -- position in the parameter list
                    }
                end
            end
            assert(#multis > 0)

            local dims, constr = MULTIS.tostring(me, multis);
            multis.code = [[
static tceu_ndata multis]]..dims..[[ = {
]] .. constr .. [[
};
tceu_nlbl lbl = multis
]]
            for _, t in ipairs(multis) do
                multis.code = multis.code..'[ ps._data_'..t.i..' ]'
            end
            multis.code = multis.code..';\n'
        end

        me.mems.args = me.mems.args..'} tceu_code_args_'..me.id..';\n'

        me.mems.wrapper = ''

        -- CEU_CODE_WATCH_xxx
        if me.mems.watch ~= '' then
            me.mems.wrapper = me.mems.wrapper .. [[
static void CEU_CODE_WATCH_]]..me.id..[[ (tceu_code_mem* _ceu_mem,
                                          tceu_code_args_]]..me.id..[[* args)
{
    ]]..me.mems.watch..[[
}
]]
        end

        -- CEU_CODE_xxx

        local Type = AST.get(body,'Block', 1,'Stmts', 1,'Stmts', 3,'', 2,'Type')
        if mods.tight then
            me.mems.wrapper = me.mems.wrapper .. [[
static ]]..TYPES.toc(assert(Type))..[[ /* space */
CEU_CODE_]]..me.id..[[ (tceu_stk* stk, tceu_ntrl trlK,
                        tceu_code_args_]]..me.id..[[ ps
#ifdef CEU_FEATURES_LUA
                        , lua_State* lua
#endif
                       )
{
    tceu_code_mem_]]..me.id..[[ mem;
#ifdef CEU_FEATURES_LUA
    mem.mem.lua = lua;
#endif
]]
            if mods.dynamic then
                me.mems.wrapper = me.mems.wrapper .. multis.code
            else
                me.mems.wrapper = me.mems.wrapper .. [[
    tceu_nlbl lbl = ]]..me.lbl_in.id..[[;
]]
            end
            me.mems.wrapper = me.mems.wrapper .. [[
    ceu_lbl((tceu_evt_occ*)&ps, stk, (tceu_code_mem*)&mem, trlK, lbl);
]]
            if Type and (not TYPES.check(Type,'void')) then
                me.mems.wrapper = me.mems.wrapper..[[
    return ps._ret;
]]
        end
            me.mems.wrapper = me.mems.wrapper..[[
}
]]
        else
            me.mems.wrapper = me.mems.wrapper .. [[
static void CEU_CODE_]]..me.id..[[ (tceu_stk* stk, tceu_ntrl trlK,
                                       tceu_code_args_]]..me.id..[[ ps,
                                       tceu_code_mem* mem)
{
]]
            if mods.dynamic then
                me.mems.wrapper = me.mems.wrapper .. multis.code
            else
                me.mems.wrapper = me.mems.wrapper .. [[
    tceu_nlbl lbl = ]]..me.lbl_in.id..[[;
]]
            end
            me.mems.wrapper = me.mems.wrapper .. [[
    tceu_stk __ceu_stk = { 1, stk, {mem,]]..me.trails[1]..','..me.trails[2]..[[} };
    ceu_lbl((tceu_evt_occ*)&ps, &__ceu_stk, mem, trlK, lbl);
    if (!__ceu_stk.is_alive) {
        return; /* skips WATCH below */
    }
]]
            if me.mems.watch ~= '' then
                me.mems.wrapper = me.mems.wrapper .. [[
    CEU_CODE_WATCH_]]..me.id..[[(mem, &ps);
]]
            end
            me.mems.wrapper = me.mems.wrapper .. [[
}
]]
        end
    end,

    Set_Alias = function (me)
        local fr, to = unpack(me)

        local idx = to.info.dcl.is_mid_idx
        if idx then
            local Code = AST.par(me,'Code')
            if to.info.dcl[1] == '&' then
                Code.mems.watch = Code.mems.watch .. [[
if (args->_]]..idx..[[ != NULL) {
    *(args->_]]..idx..[[) = ]]..V(to, {is_bind=true})..[[;
}
]]
            else
                assert(to.info.dcl[1] == '&?')
                Code.mems.watch = Code.mems.watch .. [[
if (args->_]]..idx..[[ != NULL) {
    tceu_trl* trl = (tceu_trl*) args->_]]..idx..[[->range.mem;
    *(args->_]]..idx..[[) = ]]..V(to, {is_bind=true})..[[;

    /* HACK_4 */
    trl->evt.id    = CEU_INPUT__CLEAR;
    trl->clr_range = args->_]]..idx..[[->range;
}
]]
            end
        end
    end,

    ---------------------------------------------------------------------------

    Data__PRE = function (me)
        me.id_ = TYPES.noc(me.id)
        me.mems = {
            mem  = '',
            hier = nil, -- only for base class
        }
    end,
    Data__POS = function (me)
        local _,num = unpack(me)
        local mem = me.mems.mem
        me.mems.mem = [[
typedef struct tceu_data_]]..me.id_..[[ {
]]
        if me.hier or num then
assert(me.hier)
            me.mems.mem = me.mems.mem..[[
    tceu_ndata _enum;
]]
        end
        me.mems.mem = me.mems.mem..[[
    ]]..mem..[[
} tceu_data_]]..me.id_..[[;
]]..'\n'

        MEMS.datas.mems = MEMS.datas.mems..me.mems.mem

        if me.hier and (not me.hier.up) then
            MEMS.datas.bases[#MEMS.datas.bases+1] = me
        end
    end,

    Var = function (me)
        -- new `?´ type
        local alias,tp = unpack(me)
        if not (alias=='&?' or TYPES.check(tp,'?')) then
            return
        end

        local str = TYPES.tostring(tp)
        if not MEMS.opts[str] then
            MEMS.opts[str] = true
            local cc = TYPES.toc(tp)
            local c = TYPES.toc(TYPES.pop(tp,'?'))
            if alias == '&?' then
                MEMS.datas.mems = MEMS.datas.mems..[[
static ]]..cc..'* CEU_OPTION_'..cc..[[ (]]..cc..[[* alias, char* file, int line) {
    ceu_callback_assert_msg_ex(alias != NULL, "value is not set", file, line);
    return alias;
}
]]
            else
                MEMS.datas.mems = MEMS.datas.mems..[[
typedef struct ]]..cc..[[ {
    bool      is_set;
    ]]..c..[[ value;
} ]]..cc..[[;

static ]]..cc..'* CEU_OPTION_'..cc..' ('..cc..[[* opt, char* file, int line) {
    ceu_callback_assert_msg_ex(opt->is_set, "value is not set", file, line);
    return opt;
}
]]
            end
        end
    end,

    ---------------------------------------------------------------------------

    Block__PRE = function (me)
        local mem = {}

        for _, spw in ipairs(me.spawns) do
            local _,Abs_Cons = unpack(spw)
            mem[#mem+1] = 'tceu_code_mem_'..Abs_Cons.id..' __mem_'..spw.n..';\n'
        end

        for _, dcl in ipairs(me.dcls) do
if dcl.tag ~= 'Prim' then
            local alias, Type = unpack(dcl)

            if dcl.ln then
                if CEU.opts.ceu_line_directives then
                    mem[#mem+1] = [[
#line ]]..dcl.ln[2]..' "'..dcl.ln[1]..[["
]]
                end
            end

            if dcl.tag=='Var' or dcl.tag=='Evt' then
                dcl.id_ = dcl.id

                local ok = (not dcl.__dcls_dup)
                if ok then
                    local blk = AST.par(dcl, 'Block')
                    blk = AST.par(blk,'Block') or blk
                    if AST.par(me,'Data') then
                        --ok = true
                    elseif blk.__par.tag == 'ROOT' then
                        --ok = true
                    else
                        blk = AST.par(blk,'Block') or blk
                        if blk.__par.tag == 'Code' then
                            --ok = true
                        else
                            ok = false
                        end
                    end
                end
                if not ok then
                    dcl.id_ = dcl.id_..'_'..dcl.n
                end
            end

            -- &?
            if (alias == '&?') and (not (dcl.tag=='Var' and TYPES.is_nat(Type))) then
                mem[#mem+1] = 'tceu_opt_alias '..dcl.id_..';\n'
                if dcl.tag == 'Evt' then
                    MEMS.evts[#MEMS.evts+1] = dcl
                end

            -- VAR
            elseif dcl.tag == 'Var' then
                if dcl.id == '_ret' then
                    dcl.id_ = dcl.id
                else
                    local alias, tp = unpack(dcl)
                    if alias then
                        mem[#mem+1] = TYPES.toc(tp)..'* '..dcl.id_..';\n'
                    else
                        mem[#mem+1] = TYPES.toc(tp)..'  '..dcl.id_..';\n'
                    end
                end

            -- EVT
            elseif dcl.tag == 'Evt' then
                if alias then
-- TODO: per Code evts
                    MEMS.evts[#MEMS.evts+1] = dcl
                    dcl.id_ = dcl.id
                    mem[#mem+1] = 'tceu_evt '..dcl.id_..';\n'
                else
                    local data = AST.par(me,'Data')
                    if data then
                        -- same name for all class hierarchy
                        if data.hier then
                            data = DCLS.base(data)
                        end
                        dcl.id_ = string.upper('CEU_EVENT'..'_'..data.id..'_'..dcl.id)
                        if data == AST.par(me,'Data') then
                            -- avoids duplication with super
                            MEMS.evts[#MEMS.evts+1] = dcl
                        end
                    else
                        dcl.id_ = string.upper('CEU_EVENT_'..dcl.id..'_'..dcl.n)
                        MEMS.evts[#MEMS.evts+1] = dcl
                    end
                end

            -- VEC
            elseif dcl.tag == 'Vec' then
                local is_alias, tp, _, dim = unpack(dcl)
                local ptr = (is_alias and '*' or '')
                dcl.id_ = dcl.id
                if not AST.par(me,'Data') then
                    dcl.id_ = dcl.id..'_'..dcl.n
                end
                if TYPES.is_nat(TYPES.get(tp,1)) then
                    mem[#mem+1] = [[
]]..TYPES.toc(tp)..' ('..ptr..dcl.id_..')['..V(dim)..[[];
]]
                else
                    if dim.is_const and (not is_alias) then
                        mem[#mem+1] = [[
]]..TYPES.toc(tp)..' '..dcl.id_..'_buf['..V(dim)..[[];
]]
                    end
                    mem[#mem+1] = [[
tceu_vector]]..ptr..' '..dcl.id_..[[;
]]
                end

            -- POOL
            elseif dcl.tag == 'Pool' then
                local is_alias, tp, _, dim = unpack(dcl)
                local ptr = (is_alias and '*' or '')
                dcl.id_ = dcl.id
                if not AST.par(me,'Data') then
                    dcl.id_ = dcl.id..'_'..dcl.n
                end
                if dim.is_const and (not is_alias) then
                    mem[#mem+1] = [[
tceu_code_mem_dyn* ]]..dcl.id_..'_queue['..V(dim)..[[];
byte ]]..dcl.id_..[[_buf[
    (sizeof(tceu_code_mem_dyn)+sizeof(]]..TYPES.toc(tp)..')) * '..V(dim)..[[
];
]]
                end
                mem[#mem+1] = [[
tceu_pool_pak]]..ptr..' '..dcl.id_..[[;
]]

            -- EXT
            elseif dcl.tag == 'Ext' then
                local inout, _, id = unpack(dcl)
                MEMS.exts[#MEMS.exts+1] = dcl
                dcl.id_ = string.upper('CEU_'..inout..'_'..id)
            end
end
        end
        if AST.par(me,'Data') then
            CUR().mem = CUR().mem..table.concat(mem)
        else
            CUR().mem = CUR().mem..'struct {\n'..table.concat(mem)
        end
    end,
    Block__POS = function (me)
        if not AST.par(me,'Data') then
            CUR().mem = CUR().mem..'};\n'
        end
    end,

    ---------------------------------------------------------------------------

    Stmts__PRE = function (me)
        if not AST.par(me,'Data') then
            CUR().mem = CUR().mem..'union {\n'
        end
    end,
    Stmts__POS = function (me)
        if not AST.par(me,'Data') then
            CUR().mem = CUR().mem..'};\n'
        end
    end,

    Await_Wclock = function (me)
        CUR().mem = CUR().mem..'s32 __wclk_'..me.n..';\n'
    end,

    Abs_Await = function (me)
        local _,Abs_Cons = unpack(me)
        CUR().mem = CUR().mem..'tceu_code_mem_'..Abs_Cons.id..' __mem_'..me.n..';\n'
    end,

    ---------------------------------------------------------------------------

    Par_Or__PRE  = 'Par__PRE',
    Par_And__PRE = 'Par__PRE',
    Par__PRE = function (me)
        CUR().mem = CUR().mem..'struct {\n'
    end,
    Par_Or__POS  = 'Par__POS',
    Par_And__POS = 'Par__POS',
    Par__POS = function (me)
        CUR().mem = CUR().mem..'};\n'
    end,

    Par_And = function (me)
        for i=1, #me do
            CUR().mem = CUR().mem..'u8 __and_'..me.n..'_'..i..': 1;\n'
        end
    end,

    ---------------------------------------------------------------------------

    Loop__PRE = function (me)
        CUR().mem = CUR().mem..'struct {\n'
    end,
    Loop__POS = function (me)
        CUR().mem = CUR().mem..'};\n'
    end,
    Loop = function (me)
        local max = unpack(me)
        if max then
            CUR().mem = CUR().mem..'int __max_'..me.n..';\n'
        end
    end,

    Loop_Num__PRE = 'Loop__PRE',
    Loop_Num__POS = 'Loop__POS',
    Loop_Num = function (me)
        local max, i, range, body = unpack(me)
        local fr, dir, to, step = unpack(range)
        F.Loop(me)  -- max
        CUR().mem = CUR().mem..TYPES.toc(fr.info.tp)..' __fr_'..me.n..';\n'
        if to.tag ~= 'ID_any' then
            CUR().mem = CUR().mem..TYPES.toc(i.info.tp)..' __lim_'..me.n..';\n'
        end
    end,

    Loop_Pool__PRE = 'Loop__PRE',
    Loop_Pool__POS = 'Loop__POS',
    Loop_Pool = function (me)
        CUR().mem = CUR().mem..'tceu_code_mem_dyn* __cur_'..me.n..';\n'
        if me.yields then
            CUR().mem = CUR().mem..'tceu_code_mem_dyn* __dyn_'..me.n..';\n'
        end
    end,

    ---------------------------------------------------------------------------

    Async_Thread__PRE = function (me)
        CUR().mem = CUR().mem..'struct {\n'
    end,
    Async_Thread = function (me)
        CUR().mem = CUR().mem..'tceu_threads_data* __thread_'..me.n..';\n'
    end,
    Async_Thread__POS = function (me)
        CUR().mem = CUR().mem..'};\n'
    end,

    ---------------------------------------------------------------------------

    Lua_Do__PRE = function (me)
        CUR().mem = CUR().mem..'struct {\n'
    end,
    Lua_Do = function (me)
        CUR().mem = CUR().mem..'lua_State* __lua_'..me.n..';\n'
    end,
    Lua_Do__POS = function (me)
        CUR().mem = CUR().mem..'};\n'
    end,
}

AST.visit(F)

for _, dcl in ipairs(MEMS.exts) do
    local inout, Typelist = unpack(dcl)

    -- enum
    if inout == 'input' then
        MEMS.exts.enum_input  = MEMS.exts.enum_input..dcl.id_..',\n'
    else
        MEMS.exts.enum_output = MEMS.exts.enum_output..dcl.id_..',\n'
    end
    MEMS.exts.defines_input_output = MEMS.exts.defines_input_output..
                                        '#define _'..dcl.id_..'_\n'

    -- type
    local mem = 'typedef struct tceu_'..inout..'_'..dcl.id..' {\n'
    for i,Type in ipairs(Typelist) do
        mem = mem..'    '..TYPES.toc(Type)..' _'..i..';\n'
    end
    mem = mem..'} tceu_'..inout..'_'..dcl.id..';\n'

    MEMS.exts.types = MEMS.exts.types..mem
end

for _, dcl in ipairs(MEMS.evts) do
    local is_alias,Typelist = unpack(dcl)

    -- enum
    if not is_alias then
        MEMS.evts.enum = MEMS.evts.enum..dcl.id_..',\n'
    end

    -- type
    local sufix = TYPES.noc(TYPES.tostring(Typelist))
    if not EVENT_SUFIX_EXISTS[sufix] then
        EVENT_SUFIX_EXISTS[sufix] = true
        local mem = [[
typedef struct tceu_event_]]..sufix..[[ {
]]
        for i,Type in ipairs(Typelist) do
            mem = mem..'    '..TYPES.toc(Type)..' _'..i..';\n'
        end
        mem = mem..[[
} tceu_event_]]..sufix..[[;
]]
        MEMS.evts.types = MEMS.evts.types..mem
    end
end

for i, code in ipairs(MEMS.codes) do
    local me = code.me
    local mods = me and unpack(me)

    MEMS.codes.mems = MEMS.codes.mems..code.mem
    if i < #MEMS.codes then
        MEMS.codes.args = MEMS.codes.args..code.args
        if code.wrapper then
            MEMS.codes.wrappers = MEMS.codes.wrappers..code.wrapper
        end
    end

    if code.me and code.me.dyn_base and code.me.dyn_base.dyn_last==code.me then
        MEMS.codes.mems = MEMS.codes.mems..[[
typedef union {
    tceu_code_mem mem;
]]
        for i, id2 in ipairs(code.me.dyn_base.dyns) do
            MEMS.codes.mems = MEMS.codes.mems..[[
    struct tceu_code_mem_]]..id2..' _'..i..[[;
]]
        end
        MEMS.codes.mems = MEMS.codes.mems..[[
} tceu_code_mem_]]..code.me.dyn_base.id..[[;
]]
    end
end

local function ids_supers_enums (dcl)
    local _, num = unpack(dcl)
    local t = {
        ids    = '',
        supers = '',
        nums  = '',
    }

    if dcl.hier.up then
        t.ids = t.ids .. [[
    CEU_DATA_]]..dcl.id_..[[,
]]
        t.supers = t.supers .. [[
    CEU_DATA_]]..dcl.hier.up.id_..[[,
]]
    else
        t.ids = t.ids .. [[
    CEU_DATA_]]..dcl.id_..[[ = 0,
]]
        t.supers = t.supers .. [[
    0,
]]
    end

    if num then
        t.nums = t.nums .. [[
    ]]..V(num)..[[,
]]
    end

    for _, sub in ipairs(dcl.hier.down) do
        local tt = ids_supers_enums(sub)
        t.ids    = t.ids    .. tt.ids
        t.supers = t.supers .. tt.supers
        t.nums   = t.nums   .. tt.nums
    end

    return t
end

for _, base in ipairs(MEMS.datas.bases) do
    local t = ids_supers_enums(base)
    MEMS.datas.hiers = MEMS.datas.hiers .. [[
enum {
    ]]..t.ids..[[
};

tceu_ndata CEU_DATA_SUPERS_]]..base.id_..[[ [] = {
    ]]..t.supers..[[
};
]]
    if t.nums ~= '' then
        MEMS.datas.hiers = MEMS.datas.hiers .. [[
tceu_ndata CEU_DATA_NUMS_]]..base.id_..[[ [] = {
    ]]..t.nums..[[
};
]]
    end
end

end

    
do
CODES = {
    native  = { pre='', pos='' },
    threads = '',
}

local function LINE_DIRECTIVE (me)
    if CEU.opts.ceu_line_directives then
        return [[
#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]]
    else
        return ''
    end
end

local function LINE (me, line)
    me.code = me.code..'\n'..[[
/* ]]..me.tag..' (n='..me.n..', ln='..me.ln[2]..[[) */
]]
    if CEU.opts.ceu_line_directives then
        me.code = me.code..'\n'..LINE_DIRECTIVE(me)
    end
    me.code = me.code..line
end

local function CONC (me, sub)
    me.code = me.code..sub.code
end

local function CONC_ALL (me)
    for _, sub in ipairs(me) do
        if AST.is_node(sub) then
            CONC(me, sub)
        end
    end
end

local function CASE (me, lbl)
    if AST.par(me, 'Async_Thread') then
        LINE(me, lbl.id..':;\n')
    else
        LINE(me, 'case '..lbl.id..':;\n')
    end
end

local function CLEAR (me)
    LINE(me, [[
{
    ceu_stack_clear(_ceu_stk, _ceu_mem,
                    ]]..me.trails[1]..[[, ]]..me.trails[2]..[[);
    tceu_evt_range __ceu_range = { _ceu_mem, ]]..me.trails[1]..', '..me.trails[2]..[[ };

    /* HACK_8: _ceu_occ holds __ceu_ret */
    tceu_evt_occ __ceu_occ = { {CEU_INPUT__CLEAR,{_ceu_occ}}, CEU_APP.seq+1, &__ceu_range,
                               {(tceu_code_mem*)&CEU_APP.root,
                                0, (tceu_ntrl)(CEU_APP.root.mem.trails_n-1)}
                             };
    tceu_stk __ceu_stk = { 1, _ceu_stk, {_ceu_mem,_ceu_trlK,_ceu_trlK} };
    ceu_bcast(&__ceu_occ, &__ceu_stk);
    if (!__ceu_stk.is_alive) {
        return;
    }
}
]])
end

local function HALT (me, T)
    T = T or {}
    for _, t in ipairs(T) do
        local id, val = next(t)
        LINE(me, [[
_ceu_mem->trails[]]..(T.trail or me.trails[1])..'].'..id..' = '..val..[[;
]])
    end
    if T.exec then
        LINE(me, [[
]]..T.exec..[[
]])
    end
    LINE(me, [[
return;
]])
    if T.lbl then
        LINE(me, [[
case ]]..T.lbl..[[:;
]])
    end
end

function SET (me, to, fr, fr_ok, fr_ctx)
    local fr_val = fr
    if not fr_ok then
        -- var Ee.Xx ex = ...;
        -- var&& Ee = &&ex;
        local cast = ''
        if to.info.tp[1].tag == 'ID_abs' then
            if TYPES.check(to.info.tp,'&&') then
                cast = '('..TYPES.toc(to.info.tp)..')'
            end
        end
        fr_val = cast..V(fr,fr_ctx)
    end

    if TYPES.check(to.info.tp,'?') and (not (fr.info and TYPES.check(fr.info.tp,'?'))) then
        LINE(me, [[
]]..V(to)..[[.is_set = 1;
]]..V(to)..'.value  = '..fr_val..[[;
]])
    else
        LINE(me, [[
]]..V(to)..' = '..fr_val..[[;
]])
    end
end

function LUA (me)
    assert(CEU.opts.ceu_features_lua, 'bug found')
    local code = AST.par(me, 'Code')
    local lua = AST.par(me, 'Lua_Do')
    if (not code) or (AST.depth(lua) > AST.depth(code)) then
        return CUR('__lua_'..lua.n)
    else
        return '(_ceu_mem->lua)'
    end
end

F = {
    ROOT     = CONC_ALL,
    Stmts    = CONC_ALL,
    Watching = CONC_ALL,
    Every    = CONC_ALL,

    Node__PRE = function (me)
        me.code = ''
    end,

    ROOT__PRE = function (me)
        CASE(me, me.lbl_in)
        LINE(me, [[
_ceu_mem->up_mem   = NULL;
#ifdef CEU_FEATURES_LUA
_ceu_mem->lua      = NULL;
#endif
_ceu_mem->trails_n = ]]..AST.root.trails_n..[[;
memset(&_ceu_mem->trails, 0, ]]..AST.root.trails_n..[[*sizeof(tceu_trl));
]])
    end,

    Nat_Block = function (me)
        local pre_pos, code = unpack(me)
        pre_pos = string.sub(pre_pos,2)

        -- unescape `##´ => `#´
        code = string.gsub(code, '^%s*##',  '#')
        code = string.gsub(code, '\n%s*##', '\n#')

        CODES.native[pre_pos] = CODES.native[pre_pos]..code..'\n'
    end,
    Nat_Stmt = function (me)
        LINE(me, unpack(me))
    end,

    If = function (me)
        local c, t, f = unpack(me)
        LINE(me, [[
if (]]..V(c)..[[) {
    ]]..t.code..[[
} else {
    ]]..f.code..[[
}
]])
    end,

    Block = function (me)
        CONC_ALL(me)
        if me.needs_clear or me.has_fin then
            CLEAR(me)
        end
    end,
    Block__PRE = function (me, par,base)
        par = par or me
        me.code_fin = ''
        local ctx = { base=base }

        -- recurse for "data" var
        for _, dcl in ipairs(me.dcls) do
            local alias, tp = unpack(dcl)
            local ID_abs = AST.get(tp,'Type',1,'ID_abs')
            if (not alias) and dcl.tag=='Var' and ID_abs and
               TYPES.check(tp,ID_abs[1]) and ID_abs.dcl.tag=='Data'
            then
                local blk = AST.asr(ID_abs.dcl,'Data', 3,'Block')
                F.Block__PRE(blk, par, (base and base..'.' or '')..dcl.id_)
                par.code_fin = par.code_fin .. blk.code_fin
            end
        end

        -- initialize opts
        for _, dcl in ipairs(me.dcls) do
            if dcl.tag == 'Var' then
                local is_alias, tp = unpack(dcl)
                if TYPES.check(tp,'?') and (not is_alias) and (not dcl.is_param) then
                    LINE(par, [[
]]..V(dcl,ctx)..[[.is_set = 0;
]])
                end
            end
        end

        -- initialize vectors
        for _, dcl in ipairs(me.dcls) do
            local _,tp = unpack(dcl)
            if dcl.tag=='Vec' and (not TYPES.is_nat(TYPES.get(tp,1))) then
                local is_alias, tp, _, dim = unpack(dcl)
                if not is_alias then
                    if dim.is_const then
                        LINE(par, [[
ceu_vector_init(&]]..V(dcl,ctx)..','..V(dim)..', 0, sizeof('..TYPES.toc(tp)..[[),
                (byte*)&]]..V(dcl,{base=ctx.base,id_suf='_buf'})..[[);
]])
                    else
                        LINE(par, [[
ceu_vector_init(&]]..V(dcl,ctx)..', 0, 1, sizeof('..TYPES.toc(tp)..[[), NULL);
]])
                    end
                end
            end
        end

        -- free vectors/pools
        if me.has_fin then
            if me == par then
                LINE(me, [[
_ceu_mem->trails[]]..me.trails[1]..[[].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->trails[]]..me.trails[1]..[[].lbl    = ]]..me.lbl_fin.id..[[;

if (0) {
]])
                CASE(me, me.lbl_fin)
                LINE(me, me.code_fin)   -- all nested "data"
            end

            local fin = ''
            for _, dcl in ipairs(me.dcls) do
                local is_alias,tp,_,dim = unpack(dcl)
                if dcl.tag=='Vec' and (not TYPES.is_nat(TYPES.get(tp,1))) then
                    if not (is_alias or dim.is_const) then
                        fin = fin..[[
    ceu_vector_setmax(&]]..V(dcl,ctx)..[[, 0, 0);
]]
                    end
                elseif dcl.tag=='Pool' and (not (is_alias or dim~='[]')) then
                    fin = fin..[[
    ceu_dbg_assert(]]..V(dcl,ctx)..[[.pool.queue == NULL);
    {
        tceu_code_mem_dyn* __ceu_cur = ]]..V(dcl,ctx)..[[.first.nxt;
        while (__ceu_cur != &]]..V(dcl,ctx)..[[.first) {
            tceu_code_mem_dyn* __ceu_nxt = __ceu_cur->nxt;
            ceu_callback_ptr_num(CEU_CALLBACK_REALLOC, __ceu_cur, 0);
            __ceu_cur = __ceu_nxt;
        }
    }
]]
                end
            end
            me.code_fin = fin

            if me == par then
                LINE(me, fin)
                LINE(me, [[
    return;
}
]])
            end
        end
    end,

    Vec = function (me)
        -- setmax (n)
        -- vector[n] int vec;
        local is_alias, tp, _, dim = unpack(me)
        if (not TYPES.is_nat(TYPES.get(tp,1))) then
            if not (is_alias or dim.is_const) then
                if dim ~= '[]' then
                    LINE(me, [[
ceu_vector_setmax(&]]..V(me)..', '..V(dim)..[[, 1);
]])
                end
            end
        end
    end,

    Pool = function (me)
        local _, tp, _, dim = unpack(me)
        if not me.has_trail then
            return
        end
        LINE(me, [[
{
    /* first.nxt = first.prv = &first; */
    tceu_code_mem_dyn* __ceu_dyn = &]]..V(me)..[[.first;
    ]]..V(me)..[[.first = (tceu_code_mem_dyn) { __ceu_dyn, __ceu_dyn,
                                                CEU_CODE_MEM_DYN_STATE_NONE, {} };
};
]]..V(me)..[[.up_mem = _ceu_mem;
]]..V(me)..[[.up_trl = ]]..me.trails[1]..[[;
]])
        if dim == '[]' then
            LINE(me, [[
]]..V(me)..[[.pool.queue = NULL;
]])
        else
            LINE(me, [[
ceu_pool_init(&]]..V(me)..'.pool, '..V(dim)..[[,
              sizeof(tceu_code_mem_dyn)+sizeof(]]..TYPES.toc(tp)..[[),
              (byte**)&]]..CUR(me.id_..'_queue')..', (byte*)&'..CUR(me.id_..'_buf')..[[);
]])
        end
        LINE(me, [[
_ceu_mem->trails[]]..me.trails[1]..[[].evt.id         = CEU_INPUT__CODE_POOL;
_ceu_mem->trails[]]..me.trails[1]..[[].evt.pool_first = &]]..V(me)..[[.first;
]])
    end,

    Evt = 'Var',
    Var = function (me)
        local alias, tp, _, dim = unpack(me)
        if not me.has_trail then
            return
        end
        LINE(me, [[
]]..V(me)..[[.alias = NULL;
_ceu_mem->trails[]]..me.trails[1]..[[].lbl = ]]..me.lbl.id..[[;

/* do not enter from outside */
if (0)
{
]])
        CASE(me, me.lbl)
        LINE(me, [[
    ]]..V(me)..[[.alias = NULL;   /* set it to null when alias goes out of scope */
    return;
}
]])
    end,

    List_Var = function (me)
        for _,ID_int in ipairs(me) do
            if ID_int.tag~='ID_any' and ID_int.dcl.has_trail then
                -- HACK_4
                LINE(me, [[
_ceu_mem->trails[]]..ID_int.dcl.trails[1]..[[].evt.id = CEU_INPUT__NONE;
]]..V(ID_int.dcl)..[[.range.mem = (void*) &_ceu_mem->trails[]]..ID_int.dcl.trails[1]..[[];
]])
            end
        end
    end,

    ---------------------------------------------------------------------------

    Code = function (me)
        local _,mods,_,body = unpack(me)
        if not me.is_impl then return end
        if me.is_dyn_base then return end

LINE(me, [[
/* do not enter from outside */
if (0)
{
]])
        CASE(me, me.lbl_in)

        -- CODE/DELAYED
        if mods.await then
            LINE(me, [[
    _ceu_mem->trails_n = ]]..me.trails_n..[[;
    memset(&_ceu_mem->trails, 0, ]]..me.trails_n..[[*sizeof(tceu_trl));
    int __ceu_ret_]]..me.n..[[;
]])
        end

        local args_id        = me.id
        local args_Code_Pars = AST.asr(body,'', 1,'Stmts', 1,'Stmts', 1,'Code_Pars')
        if me.dyn_base then
            args_id = me.dyn_base.id
            args_Code_Pars = AST.asr(me.dyn_base,'Code', 4,'Block', 1,'Stmts',
                                                         1,'Stmts', 1,'Code_Pars')
        end

        for i,dcl in ipairs(body.dcls) do
            if dcl.is_param then
                local _,Type1,_ = unpack(dcl)

                local cast = ''
                if me.dyn_base then
                    local is_alias2,Type2,_ = unpack(args_Code_Pars[i])
                    if not AST.is_equal(Type1,Type2) then
                        cast = '('..TYPES.toc(Type1)..(is_alias2 and '*' or '')..')'
                    end
                end

                LINE(me, [[
]]..V(dcl,{is_bind=true})..[[ =
    ]]..cast..[[((tceu_code_args_]]..args_id..[[*)_ceu_occ)->_]]..i..[[;
]])
            end
        end

        CONC(me, body)

        local Type = AST.get(body,'Block', 1,'Stmts', 1,'Stmts', 3,'', 2,'Type')
        if not Type then
            LINE(me, [[
ceu_callback_assert_msg(0, "reached end of `code´");
]])
        end

        -- CODE/DELAYED
        if mods.await then
CLEAR(me) -- TODO-NOW
            LINE(me, [[
    /* free */
    if (_ceu_mem->pak != NULL) {
        tceu_code_mem_dyn* __ceu_dyn =
            (tceu_code_mem_dyn*)(((byte*)(_ceu_mem)) - sizeof(tceu_code_mem_dyn));

        ceu_dbg_assert(__ceu_dyn->state != CEU_CODE_MEM_DYN_STATE_DELETE);
        if (__ceu_dyn->state == CEU_CODE_MEM_DYN_STATE_TRAVERSING) {
           __ceu_dyn->state = CEU_CODE_MEM_DYN_STATE_DELETE;
        } else {
            ceu_code_mem_dyn_free(&_ceu_mem->pak->pool, __ceu_dyn);
        }
    }
]])
        end
        LINE(me, [[
    return; /* HALT(me) */
}
]])
    end,

    --------------------------------------------------------------------------

    __abs = function (me, mem, pak)
        local _, Abs_Cons, mid = unpack(me)
        local ID_abs, Abslist = unpack(Abs_Cons)

        local ret = (mid and mid.code) or ''

        ret = ret .. [[
{
    tceu_code_args_]]..ID_abs.dcl.id..[[ __ceu_ps = ]]..V(Abs_Cons,{mid=mid})..[[;

    ]]..mem..[[->pak    = ]]..pak..[[;
    ]]..mem..[[->up_mem = ]]..((pak=='NULL' and '_ceu_mem')   or (pak..'->up_mem'))..[[;
    ]]..mem..[[->up_trl = ]]..((pak=='NULL' and me.trails[1]) or (pak..'->up_trl'))..[[;
]]
        if CEU.opts.ceu_features_lua then
            ret = ret .. [[
    ]]..mem..[[->lua    = ]]..LUA(me)..[[;
]]
        end
        ret = ret .. [[
    tceu_stk __ceu_stk  = { 1, _ceu_stk, {_ceu_mem,_ceu_trlK,_ceu_trlK} };
    CEU_CODE_]]..ID_abs.dcl.id..[[(&__ceu_stk, 0, __ceu_ps,
                                   (tceu_code_mem*)]]..mem..[[);
    if (!__ceu_stk.is_alive) {
        return;
    }
}
]]

        -- Passing "x" from "code" mid to "spawn":
        --  code Ff (...) => (var& int x) => ... do
        if mid then
            for _, ID_int in ipairs(mid) do
                if ID_int.tag~='ID_any' and ID_int.dcl.is_mid_idx then
                    local Code = AST.par(me,'Code')
                    ret = ret .. [[
if (((tceu_code_args_]]..Code.id..[[*)_ceu_occ)->_]]..ID_int.dcl.is_mid_idx..[[ != NULL) {
    *(((tceu_code_args_]]..Code.id..[[*)_ceu_occ)->_]]..ID_int.dcl.is_mid_idx..[[) = ]]..V(ID_int, {is_bind=true})..[[;
}
]]
                end
            end
        end

        return ret
    end,

    Abs_Await = function (me)
        HALT(me, {
            { ['evt.id']  = 'CEU_INPUT__CODE' },
            { ['evt.mem'] = '(tceu_code_mem*) &'..CUR('__mem_'..me.n) },
            { lbl = me.lbl_out.id },
            lbl = me.lbl_out.id,
            exec = F.__abs(me, '(&'..CUR(' __mem_'..me.n)..'.mem)', 'NULL'),
        })

        LINE(me, [[
ceu_stack_clear(_ceu_stk, _ceu_mem,
                ]]..me.trails[1]..[[, ]]..me.trails[2]..[[);
]])
    end,

    Abs_Spawn_Single = function (me)
        LINE(me, [[
_ceu_mem->trails[]]..me.trails[1]..[[].evt.id  = CEU_INPUT__CODE;
_ceu_mem->trails[]]..me.trails[1]..[[].evt.mem = (tceu_code_mem*) &]]..CUR('__mem_'..me.n)..[[;
_ceu_mem->trails[]]..me.trails[1]..[[].lbl     = CEU_LABEL_NONE;  /* no awake in spawn */
]])
        LINE(me, F.__abs(me, '(&'..CUR(' __mem_'..me.n)..'.mem)', 'NULL'))
        LINE(me, [[
if (!_ceu_stk->is_alive) {
    return;
}
]])
    end,

    Abs_Spawn_Pool = function (me)
        local _, Abs_Cons, _, _, pool = unpack(me)
        local ID_abs, Abslist = unpack(Abs_Cons)
        local alias,tp,_,dim = unpack(pool.info.dcl)

        local code = F.__abs(me, '__ceu_new_mem', '(&'..V(pool)..')')
        LINE(me, [[
{
    tceu_code_mem_dyn* __ceu_new;
]])
        if alias then
            LINE(me, [[
    if (]]..V(pool)..[[.pool.queue == NULL) {
        __ceu_new = (tceu_code_mem_dyn*) ceu_callback_ptr_num(
                                            CEU_CALLBACK_REALLOC,
                                            NULL,
                                            sizeof(tceu_code_mem_dyn) + sizeof(]]..TYPES.toc(tp)..[[)
                                         ).value.ptr;
    } else {
        __ceu_new = (tceu_code_mem_dyn*) ceu_pool_alloc(&]]..V(pool)..[[.pool);
    }
]])
        elseif dim == '[]' then
            LINE(me, [[
    __ceu_new = (tceu_code_mem_dyn*) ceu_callback_ptr_num(
                                        CEU_CALLBACK_REALLOC,
                                        NULL,
                                        sizeof(tceu_code_mem_dyn) + sizeof(]]..TYPES.toc(tp)..[[)
                                     ).value.ptr;
]])
        else
            LINE(me, [[
    __ceu_new = (tceu_code_mem_dyn*) ceu_pool_alloc(&]]..V(pool)..[[.pool);
]])
        end

        local set = AST.par(me,'Set_Abs_Spawn_Pool')
        if set then
            local _, to = unpack(set)
            SET(me, to, '(__ceu_new != NULL)', true)
        end

        LINE(me, [[
    if (__ceu_new != NULL) {
        __ceu_new->state = CEU_CODE_MEM_DYN_STATE_NONE;
        __ceu_new->nxt = &]]..V(pool)..[[.first;
        ]]..V(pool)..[[.first.prv->nxt = __ceu_new;
        __ceu_new->prv = ]]..V(pool)..[[.first.prv;
        ]]..V(pool)..[[.first.prv = __ceu_new;

        tceu_code_mem* __ceu_new_mem = &__ceu_new->mem[0];
        ]]..code..[[
        if (!_ceu_stk->is_alive) {
            return;
        }
    }
}
]])
    end,

    --------------------------------------------------------------------------

    Loop_Pool = function (me)
        local _,list,pool,body = unpack(me)
        local Code = AST.asr(pool.info.dcl,'Pool', 2,'Type', 1,'ID_abs').dcl

        local cur = CUR('__cur_'..me.n)
        local dyn = CUR('__dyn_'..me.n)

        if me.yields then
            LINE(me, [[
_ceu_mem->trails[]]..me.trails[1]..[[].evt.id    = CEU_INPUT__FINALIZE;
_ceu_mem->trails[]]..me.trails[1]..[[].evt.mem   = _ceu_mem;
_ceu_mem->trails[]]..me.trails[1]..[[].lbl       = ]]..me.lbl_clr.id..[[;
_ceu_mem->trails[]]..me.trails[1]..[[].clr_range =
    (tceu_evt_range) { _ceu_mem, ]]..me.trails[1]..','..me.trails[1]..[[ };

]]..dyn..[[ = NULL;
if (0) {
    case ]]..me.lbl_clr.id..[[:
        if (]]..dyn..[[ != NULL) {
            if (]]..dyn..[[->state==CEU_CODE_MEM_DYN_STATE_DELETE) {
                ceu_code_mem_dyn_free(&]]..V(pool)..[[.pool, ]]..dyn..[[);
            } else {
               ]]..dyn..[[->state = CEU_CODE_MEM_DYN_STATE_NONE;
            }
        }
        return;
}
]])
        end

        LINE(me, [[
{
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
    ]]..cur..[[ = ]]..V(pool)..[[.first.nxt;
    while (]]..cur..[[ != &]]..V(pool)..[[.first)
    {
]])

        if me.yields then
            LINE(me, [[
        if (]]..cur..[[->state == CEU_CODE_MEM_DYN_STATE_NONE) {
            ]]..cur..[[->state = CEU_CODE_MEM_DYN_STATE_TRAVERSING;
            ]]..dyn..[[ = ]]..cur..[[;
        } else if (]]..cur..[[->state == CEU_CODE_MEM_DYN_STATE_DELETE) {
            ]]..cur..[[ = ]]..cur..[[->nxt;
            continue;
        } else {
            ]]..dyn..[[ = NULL;
        }
]])
        end

        if list then
            CONC(me, list)
            local mids = AST.asr(Code,'Code', 4,'Block', 1,'Stmts',
                                              1,'Stmts', 2,'Code_Pars')
            local ps = {}
            for i, arg in ipairs(list) do
                if arg.tag ~= 'ID_any' then
                    local par = mids[i]
                    ps[#ps+1] = '._'..par.is_mid_idx..' = &'..V(arg,{is_bind=true})
                end
            end
            LINE(me, [[
        tceu_code_args_]]..Code.id..[[ __ceu_ps = { ]]..table.concat(ps,',').. [[};
        CEU_CODE_WATCH_]]..Code.id..[[(]]..cur..[[->mem, &__ceu_ps);
]])
        end

        CONC(me, body)
        CASE(me, me.lbl_cnt)

        if me.yields then
            LINE(me, [[
        {
            tceu_code_mem_dyn* __ceu_nxt = ]]..cur..[[->nxt;

            ceu_dbg_assert(]]..cur..[[->state != CEU_CODE_MEM_DYN_STATE_NONE);
            if (]]..dyn..[[ != NULL) {
                ceu_dbg_assert(]]..cur..[[ == ]]..dyn..[[);
                if (]]..cur..[[->state==CEU_CODE_MEM_DYN_STATE_DELETE) {
                    ceu_code_mem_dyn_free(&]]..V(pool)..[[.pool, ]]..cur..[[);
                } else {
                   ]]..cur..[[->state = CEU_CODE_MEM_DYN_STATE_NONE;
                }
                ]]..dyn..[[ = NULL;
            }

            ]]..cur..[[ = __ceu_nxt;
        }
]])
        else
            LINE(me, [[
            ]]..cur..[[ = ]]..cur..[[->nxt;
]])
        end

        LINE(me, [[
    }
}
]])
        CASE(me, me.lbl_out)
    end,

    ---------------------------------------------------------------------------

    __fin = function (me, evt, inc, lbl)
        LINE(me, [[
_ceu_mem->trails[]]..(me.trails[1]+inc)..[[].evt.id = ]]..evt..[[;
_ceu_mem->trails[]]..(me.trails[1]+inc)..[[].lbl    = ]]..me.lbl_in[lbl].id..[[;
_ceu_mem->trails[]]..(me.trails[1]+inc)..[[].clr_range =
    (tceu_evt_range) { _ceu_mem, ]]..me.trails[1]..','..me.trails[2]..[[ };
]])
    end,

    Finalize = function (me)
        local now,_,fin,pse,res = unpack(me)
        F.__fin(me, 'CEU_INPUT__FINALIZE', 0, 1)
        if pse then
            F.__fin(me, 'CEU_INPUT__PAUSE', 1, 2)
        end
        if res then
            F.__fin(me, 'CEU_INPUT__RESUME', 2, 3)
        end
        LINE(me, [[
if (0) {
]])
        CASE(me, me.lbl_in[1])
        CONC(me, fin)
        HALT(me)
        if pse then
            CASE(me, me.lbl_in[2])
            CONC(me, pse)
            F.__fin(me, 'CEU_INPUT__PAUSE', 1, 2)
            HALT(me)
        end
        if res then
            CASE(me, me.lbl_in[3])
            CONC(me, res)
            F.__fin(me, 'CEU_INPUT__RESUME', 2, 3)
            HALT(me)
        end
        LINE(me, [[
}
]])
        if now then
            CONC(me, now)
        end
    end,

    Pause_If = function (me)
        local e, body = unpack(me)
        LINE(me, [[
_ceu_mem->trails[]]..me.trails[1]..[[].evt.id     = CEU_INPUT__PAUSE_BLOCK;
_ceu_mem->trails[]]..me.trails[1]..[[].pse_evt    = ]]..V(e)..[[;
_ceu_mem->trails[]]..me.trails[1]..[[].pse_skip   = ]]..body.trails_n..[[;
_ceu_mem->trails[]]..me.trails[1]..[[].pse_paused = 0;
]])
        CONC(me, body)
    end,

    ---------------------------------------------------------------------------

    Do = function (me)
        CONC_ALL(me)

        local _,blk,set = unpack(me)
        if set and set.info.dcl[1]~='&?' and (not TYPES.check(set.info.tp,'?')) then
            LINE(me, [[
ceu_callback_assert_msg(0, "reached end of `do´");
]])
        end
        CASE(me, me.lbl_out)

        if me.has_escape and (me.trails_n>1 or blk.needs_clear)
        or #blk.spawns > 0
        then
            CLEAR(me)
        end
    end,

    Escape = function (me)
        local code = AST.par(me, 'Code')
        local mods = code and code[2]
        local evt do
            if code and mods.await then
                -- HACK_8
                evt = '(tceu_evt_occ*) &__ceu_ret_'..code.n
            else
                evt = 'NULL'
            end
        end
        if AST.par(me, 'Async_Thread') then
            LINE(me, [[
goto ]]..me.outer.lbl_out.id..[[;
]])
        else
            LINE(me, [[
ceu_lbl(]]..evt..[[, _ceu_stk,
        _ceu_mem, ]]..me.outer.trails[1]..','..me.outer.lbl_out.id..[[);
]])
            HALT(me)
        end
    end,

    ---------------------------------------------------------------------------

    __loop_max = function (me)
        local max = unpack(me)
        if max then
            return {
                -- ensures that max is constant
                ini = [[
{ char __]]..me.n..'['..V(max)..'/'..V(max)..[[ ] = {0}; }
]]..CUR('__max_'..me.n)..[[ = 0;
]],
                chk = [[
ceu_callback_assert_msg(]]..CUR('__max_'..me.n)..' < '..V(max)..[[, "`loop´ overflow");
]],
                inc = [[
]]..CUR('__max_'..me.n)..[[++;
]],
            }
        else
            return {
                ini = '',
                chk = '',
                inc = '',
            }
        end
    end,

    __loop_async = function (me)
        local async = AST.par(me, 'Async')
        if async then
            LINE(me, [[
ceu_callback_num_ptr(CEU_CALLBACK_ASYNC_PENDING, 0, NULL);
]])
            HALT(me, {
                { ['evt.id'] = 'CEU_INPUT__ASYNC' },
                { seq        = 'CEU_APP.seq+1' },
                { lbl        = me.lbl_asy.id },
                lbl = me.lbl_asy.id,
            })
        end
    end,

    Loop = function (me)
        local _, body = unpack(me)
        local max = F.__loop_max(me)

        LINE(me, [[
]]..max.ini..[[
while (1) {
    ]]..max.chk..[[
    ]]..body.code..[[
]])
        CASE(me, me.lbl_cnt)

        if me.has_continue and me.trails_n>1 then
            CLEAR(me)
        end

        assert(body.trails[1]==me.trails[1] and body.trails[2]==me.trails[2])

        F.__loop_async(me)
        LINE(me, [[
    ]]..max.inc..[[
}
]])
        CASE(me, me.lbl_out)

        if me.has_break and me.trails_n>1 then
            CLEAR(me)
        end
    end,

    Loop_Num = function (me)
        local _, i, range, body = unpack(me)
        local fr, dir, to, step = unpack(range)
        local max = F.__loop_max(me)

        -- check if step is positive (static)
        if step then
            local f = load('return '..V(step))
            if f then
                local ok, num = pcall(f)
                num = tonumber(num)
                if ok and num then
                    if dir == '<-' then
                        num = -num
                    end
                    ASR(num>0, me,
                        'invalid `loop´ step : expected positive number : got "'..num..'"')
                end
            end
        end


        if to.tag ~= 'ID_any' then
            LINE(me, [[
]]..CUR('__lim_'..me.n)..' = '..V(to)..' + ('..V(step)..'*'..to.__adj_step_mul..[[*-1);
]])
        end

        local sig = (dir=='->' and '' or '-')
        LINE(me, [[
]]..max.ini..[[
ceu_callback_assert_msg(]]..sig..V(step)..[[> 0, "invalid `loop´ step : expected positive number");
]])
        local op = (dir=='->' and '>' or '<')
        LINE(me, [[
]]..CUR('__fr_'..me.n)..' = '..V(fr)..[[;
]]..V(i)..' = '..V(fr)..' + '..V(step)..' * '..fr.__adj_step_mul..[[;
ceu_callback_assert_msg_ex(]]..V(i)..(op..'=')..'('..TYPES.toc(i.info.tp)..')'..CUR('__fr_'..me.n)..[[,
    "control variable overflow", __FILE__, __LINE__-3);
while (1) {
]])
        if to.tag ~= 'ID_any' then
            local op = (dir=='->' and '>' or '<')
            LINE(me, [[
    if (]]..V(i)..' '..op..' '..CUR('__lim_'..me.n)..[[) {
        break;
    }
]])
        end
        LINE(me, [[
    ]]..max.chk..[[
    ]]..body.code..[[
]])
        CASE(me, me.lbl_cnt)
            assert(body.trails[1]==me.trails[1] and body.trails[2]==me.trails[2])
        F.__loop_async(me)
        LINE(me, [[
    ]]..V(i)..' = '..V(i)..' + '..V(step)..[[;
    ceu_callback_assert_msg_ex(]]..V(i)..op..'('..TYPES.toc(i.info.tp)..')'..CUR('__fr_'..me.n)..[[,
        "control variable overflow", __FILE__, __LINE__-2);
    ]]..max.inc..[[
}
]])
        CASE(me, me.lbl_out)
    end,

    Break = function (me)
        if AST.par(me, 'Async_Thread') then
            LINE(me, [[
goto ]]..me.outer.lbl_out.id..[[;
]])
        else
            LINE(me, [[
ceu_lbl(NULL, _ceu_stk,
        _ceu_mem, ]]..me.outer.trails[1]..','..me.outer.lbl_out.id..[[);
]])
            HALT(me)
        end
    end,
    Continue = function (me)
        if AST.par(me, 'Async_Thread') then
            LINE(me, [[
goto ]]..me.outer.lbl_out.id..[[;
]])
        else
            LINE(me, [[
ceu_lbl(NULL, _ceu_stk,
        _ceu_mem, ]]..me.outer.trails[1]..','..me.outer.lbl_cnt.id..[[);
]])
            HALT(me)
        end
    end,

    Stmt_Call = function (me)
        local call = unpack(me)
        LINE(me, [[
]]..V(call)..[[;
]])
    end,

    ---------------------------------------------------------------------------

    __par_and = function (me, i)
        return CUR('__and_'..me.n..'_'..i)
    end,
    Par_Or  = 'Par',
    Par_And = 'Par',
    Par = function (me)
        -- Par_And: close gates
        if me.tag == 'Par_And' then
            for i, sub in ipairs(me) do
                LINE(me, [[
]]..CUR('__and_'..me.n..'_'..i)..[[ = 0;
]])
            end
        end

        -- call each branch
        for i, sub in ipairs(me) do
            if i < #me then
                local abt = me[i+1].trails[1]
                LINE(me, [[
{
    tceu_stk __ceu_stk = { 1, _ceu_stk, {_ceu_mem,]]..abt..','..abt..[[} };
    ceu_lbl(_ceu_occ, &__ceu_stk,
            _ceu_mem, ]]..sub.trails[1]..[[, ]]..me.lbls_in[i].id..[[);
    if (!__ceu_stk.is_alive) {
        return;
    }
}
]])
            else
                -- no need to abort since there's a "return" below
                LINE(me, [[
ceu_lbl(_ceu_occ, _ceu_stk,
        _ceu_mem, ]]..sub.trails[1]..','..me.lbls_in[i].id..[[);
]])
            end
        end
        HALT(me)

        -- code for each branch
        for i, sub in ipairs(me) do
            CASE(me, me.lbls_in[i])
            CONC(me, sub)

            if me.tag == 'Par' then
                HALT(me)
            else
                -- Par_And: open gates
                if me.tag == 'Par_And' then
                    LINE(me, [[
]]..CUR('__and_'..me.n..'_'..i)..[[ = 1;
]])
                end
                LINE(me, [[
/*
HACK_8
ceu_lbl(NULL, _ceu_stk,
*/
ceu_lbl(_ceu_occ, _ceu_stk,
        _ceu_mem, ]]..me.trails[1]..','..me.lbl_out.id..[[);
]])
                HALT(me)
            end
        end

        -- rejoin
        if me.lbl_out then
            CASE(me, me.lbl_out)
        end

        -- Par_And: test gates
        if me.tag == 'Par_And' then
            for i, sub in ipairs(me) do
                LINE(me, [[
if (! ]]..CUR('__and_'..me.n..'_'..i)..[[) {
]])
                HALT(me)
                LINE(me, [[
}
]])
            end

        -- Par_Or: clear trails
        elseif me.tag == 'Par_Or' then
            CLEAR(me)
        end
    end,

    ---------------------------------------------------------------------------

    Set_Exp = function (me)
        local fr, to = unpack(me)

        if to.info.dcl.id == '_ret' then
            local code = AST.par(me, 'Code')
            if code then
                local _,mods = unpack(code)
                if mods.tight then
                    if code.dyn_base then
                        code = code.dyn_base
                    end
                    LINE(me, [[
((tceu_code_args_]]..code.id..[[*) _ceu_occ)->_ret = ]]..V(fr)..[[;
]])
                else
                    LINE(me, [[
__ceu_ret_]]..code.n..' = '..V(fr)..[[;
]])
                end
            else
                LINE(me, [[
{   int __ceu_ret = ]]..V(fr)..[[;
    ceu_callback_num_ptr(CEU_CALLBACK_TERMINATING, __ceu_ret, NULL);
}
]])
            end
        elseif AST.get(to,'Exp_Name',1,'Exp_$') then
            -- $vec = ...
            local _,vec = unpack(to[1])
            LINE(me, [[
ceu_vector_setlen(&]]..V(vec)..','..V(fr)..[[, 0);
]])

        else
            SET(me, to, fr)
        end
    end,

    Set_Alias = function (me)
        local fr, to = unpack(me)

        local alias, tp = unpack(to.info.dcl)
        if (alias == '&?') and (not (to.info.dcl.tag=='Var' and TYPES.is_nat(tp))) then
            if fr.info.dcl[1] == '&?' then
                LINE(me, [[
]]..V(to)..' = '..V(fr)..[[;
]])
            else
                local trails = fr.info.dcl.blk.trails
                if to.info.dcl.tag == 'Evt' then
                    LINE(me, [[
]]..V(to)..[[ = (tceu_opt_alias)
    { &]]..V(to)..'.evt, '..V(fr)..[[, {_ceu_mem,]]..trails[1]..','..trails[2]..[[} };
]])
                else
                    LINE(me, [[
]]..V(to)..[[ = (tceu_opt_alias)
    { ]]..V(fr)..[[, {}, {_ceu_mem,]]..trails[1]..','..trails[2]..[[} };
]])
                end
            end
            if not AST.par(to.info.dcl, 'Code_Pars') then
                if to.info.dcl.is_local_set_alias then
                    local trails = to.info.dcl.trails
                    LINE(me, [[
_ceu_mem->trails[]]..trails[1]..[[].evt.id = CEU_INPUT__CLEAR;
_ceu_mem->trails[]]..trails[1]..[[].clr_range = ]]..V(to)..[[.range;
]])
                end
            end
        else
            -- var Ee.Xx ex = ...;
            -- var& Ee = &ex;
            local cast = ''
            if to.info.dcl.tag=='Var' and to.info.tp.tag=='Type'
                and to.info.tp[1].tag == 'ID_abs'
            then
                cast = '('..TYPES.toc(to.info.tp)..'*)'
            end
            LINE(me, [[
]]..V(to, {is_bind=true})..' = '..cast..V(fr)..[[;
]])
        end
    end,

    Set_Await_one = function (me)
        local fr, to = unpack(me)
        CONC_ALL(me)
        if fr.tag == 'Await_Wclock' then
            SET(me, to, 'CEU_APP.wclk_late', true)
        else
            assert(fr.tag == 'Abs_Await')
            -- see "Set_Exp: _ret"
            -- HACK_8
            SET(me, to, '*((int*)_ceu_occ->evt.mem)' ,true)
        end
    end,
    Set_Await_many = function (me)
        local Await, List = unpack(me)
        local id do
            local ID_ext = AST.get(Await,'Await_Ext', 1,'ID_ext')
            if ID_ext then
                id = 'tceu_input_'..ID_ext.dcl.id
            else
                local Exp_Name = AST.asr(Await,'Await_Int', 1,'Exp_Name')
                local sufix = TYPES.noc(TYPES.tostring(Exp_Name.info.dcl[2]))
                id = 'tceu_event_'..sufix
            end
        end
        CONC(me, Await)
        for i, name in ipairs(List) do
            if name.tag ~= 'ID_any' then
                local ps = '(('..id..'*)(_ceu_occ->params))'
                SET(me, name, ps..'->_'..i, true)
            end
        end
    end,

    Set_Emit_Ext_emit  = CONC_ALL,   -- see Emit_Ext_emit
    Set_Abs_Spawn_Pool = CONC_ALL,   -- see Abs_Spawn_Pool

    Set_Abs_Val = function (me)
        local fr, to = unpack(me)
        local _,Abs_Cons = unpack(fr)

        -- typecast: "val Xx = val Xx.Yy();"
        local to_tp = TYPES.toc(TYPES.pop(to.info.tp,'?'))
        SET(me, to, Abs_Cons, nil, {to_tp=to_tp, to_val=V(to)})
    end,

    Set_Vec = function (me)
        local Vec_Cons, to = unpack(me)

        LINE(me, [[
{
    usize __ceu_nxt;
]])

        for i, fr in ipairs(Vec_Cons) do
            -- concat or set?
            if i == 1 then
                if fr.tag == 'Exp_Name' then
                    -- vec = vec..
                    LINE(me, [[
    __ceu_nxt = ]]..V(to)..[[.len;
]])
                else
                    -- vec = []..
                    LINE(me, [[
    ceu_vector_setlen(&]]..V(to)..[[, 0, 0);
    __ceu_nxt = 0;
]])
                end
            end

            -- vec1 = ..vec2
            if fr.tag == 'Exp_Name' then
                if i > 1 then
                    -- NO:
                    -- vector&[] v2 = &v1;
                    -- v1 = []..v2;
                    LINE(me, [[
    ceu_callback_assert_msg(&]]..V(fr)..' != &'..V(to)..[[, "source is the same as destination");
]])
                    LINE_DIRECTIVE(me)
                    LINE(me, [[
    ceu_vector_setlen(&]]..V(to)..', ('..V(to)..'.len + '..V(fr)..[[.len), 1);
    ceu_vector_buf_set(&]]..V(to)..[[,
                       __ceu_nxt,
                       ]]..V(fr)..[[.buf,
                       ceu_vector_buf_len(&]]..V(fr)..[[));
]])
                else
                    -- v1 = v1....
                    -- nothing to to
                end
                LINE(me, [[
    __ceu_nxt = ]]..V(to)..[[.len;
]])

            -- vec1 = ..[a,b,c]
            elseif fr.tag == 'Vec_Tup' then
                local List_Exp = unpack(fr)
                if List_Exp then
                    LINE(me, [[
    ceu_vector_setlen(&]]..V(to)..', ('..V(to)..'.len + '..#List_Exp..[[), 1);
]])
                    for _, e in ipairs(List_Exp) do
                        LINE(me, [[
    *((]]..TYPES.toc(to.info.tp)..[[*)
        ceu_vector_buf_get(&]]..V(to)..[[, __ceu_nxt++)) = ]]..V(e)..[[;
]])
                    end
                    LINE(me, [[
]])
                end

            -- vec1 = ..[[lua]]
            elseif fr.tag == 'Lua' then
                CONC(me, fr)
                LINE(me, [[
    if (lua_isstring(]]..LUA(me)..[[,-1)) {
        const char* __ceu_str = lua_tostring(]]..LUA(me)..[[, -1);
        usize __ceu_len = lua_rawlen(]]..LUA(me)..[[, -1);
        ceu_vector_setlen_ex(&]]..V(to)..', ('..V(to)..[[.len + __ceu_len), 1,
                             __FILE__, __LINE__-4);
        ceu_vector_buf_set(&]]..V(to)..[[,
                           __ceu_nxt,
                           __ceu_str,
                           __ceu_len);
        __ceu_nxt += __ceu_len;
    } else {
        lua_pop(]]..LUA(me)..[[,1);
        lua_pushstring(]]..LUA(me)..[[, "not implemented [2]");
        goto _CEU_LUA_ERR_]]..fr.n..[[;
    }
]])
                LINE(me, fr.code_after)

            -- vec1 = .."string"
            elseif TYPES.check(fr.info.tp, '_char', '&&') then
                LINE(me, [[
    {
        char* __ceu_str = ]]..V(fr)..[[;
        usize __ceu_len = strlen(__ceu_str);
        ceu_vector_setlen(&]]..V(to)..', ('..V(to)..[[.len + __ceu_len), 1);
        ceu_vector_buf_set(&]]..V(to)..[[,
                           __ceu_nxt,
                           __ceu_str,
                           __ceu_len);
        __ceu_nxt += __ceu_len;
    }
]])
            else
                error'bug found'
            end
        end

        LINE(me, [[
}
]])
    end,

    ---------------------------------------------------------------------------

    Await_Forever = function (me)
        HALT(me)
    end,

    Await_Until = function (me)
        local awt, cnd = unpack(me)
        if cnd then
            LINE(me, [[
do {
]])
            CONC(me, awt)
            LINE(me, [[
} while (!]]..V(cnd)..[[);
]])
        else
            CONC(me, awt)
        end
    end,

    ---------------------------------------------------------------------------

    Await_Pause = function (me)
        HALT(me, {
            { evt = '((tceu_evt){CEU_INPUT__PAUSE,{NULL}})' },
            { lbl = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
    end,
    Await_Resume = function (me)
        HALT(me, {
            { evt =  '((tceu_evt){CEU_INPUT__RESUME,{NULL}})' },
            { lbl = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
    end,

    Await_Ext = function (me)
        local ID_ext = unpack(me)
        HALT(me, {
            { evt = V(ID_ext) },
            { seq = 'CEU_APP.seq+1' },
            { lbl = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
    end,

    Emit_Ext_emit = function (me)
        local ID_ext, List_Exp = unpack(me)
        local inout, Typelist = unpack(ID_ext.dcl)
        LINE(me, [[
{
]])
        local ps = 'NULL'
        if #List_Exp > 0 then
            LINE(me, [[
tceu_]]..inout..'_'..ID_ext.dcl.id..' __ceu_ps = { '..table.concat(V(List_Exp),',')..[[ };
]])
            ps = '&__ceu_ps'
        end

        if inout == 'output' then
            local set = AST.par(me,'Set_Emit_Ext_emit')
            local cb = [[
ceu_callback_num_ptr(CEU_CALLBACK_OUTPUT, ]]..V(ID_ext)..'.id, '..ps..[[).value.num;
]]
            if set then
                local _, to = unpack(set)
                SET(me, to, cb, true)
            else
                LINE(me, cb)
            end
            LINE(me, [[
}
]])
        else
            LINE(me, [[
ceu_callback_num_ptr(CEU_CALLBACK_ASYNC_PENDING, 0, NULL);
_ceu_mem->trails[]]..me.trails[1]..[[].evt.id = CEU_INPUT__ASYNC;
_ceu_mem->trails[]]..me.trails[1]..[[].seq    = CEU_APP.seq+1;
_ceu_mem->trails[]]..me.trails[1]..[[].lbl    = ]]..me.lbl_out.id..[[;
]])
            LINE(me, [[
    ceu_input(]]..V(ID_ext)..'.id, '..ps..[[);
}
]])
            HALT(me, {
                lbl = me.lbl_out.id,
            })
        end
    end,

    ---------------------------------------------------------------------------

    Await_Int = function (me)
        local Exp_Name = unpack(me)
        local alias, tp = unpack(Exp_Name.info.dcl)
        if alias == '&?' then
            assert(not (Exp_Name.info.dcl.tag=='Var' and TYPES.is_nat(tp)), 'bug found')
            LINE(me, [[
if (]]..V(Exp_Name)..[[.alias != NULL) {
]])
            HALT(me, {
                { ['evt.id']  = 'CEU_INPUT__CLEAR' },
                { ['clr_range'] = V(Exp_Name)..'.range' },
                { lbl = me.lbl_out.id },
                lbl = me.lbl_out.id,
            })
            LINE(me, [[
}
]])
        else
            HALT(me, {
                { evt = V(Exp_Name) },
                { seq = 'CEU_APP.seq+1' },
                { lbl = me.lbl_out.id },
                lbl = me.lbl_out.id,
            })
        end
    end,

    Emit_Evt = function (me)
        local Exp_Name, List_Exp = unpack(me)
        local Typelist = unpack(Exp_Name.info.dcl)
        LINE(me, [[
{
]])
        local ps = 'NULL'
        if List_Exp then
            local sufix = TYPES.noc(TYPES.tostring(Exp_Name.info.dcl[2]))
            LINE(me, [[
    tceu_event_]]..sufix..[[
        __ceu_ps = { ]]..table.concat(V(List_Exp),',')..[[ };
]])
            ps = '&__ceu_ps'
        end
        LINE(me, [[
    tceu_evt_occ __ceu_occ = { ]]..V(Exp_Name)..[[, CEU_APP.seq+1, &__ceu_ps,
                               {(tceu_code_mem*)&CEU_APP.root,
                                0, CEU_APP.root.mem.trails_n-1}
                             };
    tceu_stk __ceu_stk  = { 1, _ceu_stk, {_ceu_mem,_ceu_trlK,_ceu_trlK} };
    ceu_bcast(&__ceu_occ, &__ceu_stk);
    if (!__ceu_stk.is_alive) {
        return;
    }
}
]])
    end,

    ---------------------------------------------------------------------------

    Await_Wclock = function (me)
        local e = unpack(me)

        local wclk = CUR('__wclk_'..me.n)

        LINE(me, [[
ceu_wclock(]]..V(e)..', &'..wclk..[[, NULL);

_CEU_HALT_]]..me.n..[[_:
]])
        HALT(me, {
            { ['evt.id'] = 'CEU_INPUT__WCLOCK' },
            { seq        = 'CEU_APP.seq+1' },
            { lbl        = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
        LINE(me, [[
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_occ->params;
    if (!ceu_wclock(*dt, NULL, &]]..wclk..[[) ) {
        goto _CEU_HALT_]]..me.n..[[_;
    }
}
]])
    end,

    Emit_Wclock = function (me)
        local e = unpack(me)
        LINE(me, [[
{
    ceu_callback_num_ptr(CEU_CALLBACK_ASYNC_PENDING, 0, NULL);
    s32 __ceu_dt = ]]..V(e)..[[;
    do {
        ceu_input(CEU_INPUT__WCLOCK, &__ceu_dt);
        if (!_ceu_stk->is_alive) {
            return;
        }
        __ceu_dt = 0;
    } while (CEU_APP.wclk_min_set <= 0);
}
]])
        HALT(me, {
            { ['evt.id'] = 'CEU_INPUT__ASYNC' },
            { seq        = 'CEU_APP.seq+1' },
            { lbl        = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
    end,

    ---------------------------------------------------------------------------

    Async = function (me)
        local _,_,blk = unpack(me)
        LINE(me, [[
ceu_callback_num_ptr(CEU_CALLBACK_ASYNC_PENDING, 0, NULL);
]])
        HALT(me, {
            { ['evt.id'] = 'CEU_INPUT__ASYNC' },
            { seq        = 'CEU_APP.seq+1' },
            { lbl        = me.lbl_in.id },
            lbl = me.lbl_in.id,
        })
        CONC(me, blk)
    end,

    ---------------------------------------------------------------------------

    Set_Async_Thread = function (me)
        local thread, to = unpack(me)

        local v   = CUR('__thread_'..thread.n)
        local chk = '(('..v..' != NULL) && ('..v..'->has_started))'

        CONC_ALL(me)
        SET(me, to, chk, true)
    end,

    Atomic = function (me)
        local thread = AST.par(me, 'Async_Thread')
        if thread then
            LINE(me, [[
CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
if (_ceu_p.thread->has_aborted) {
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
    goto ]]..thread.lbl_abt.id..[[;   /* exit if ended from "sync" */
} else {                              /* othrewise, execute block */
]])
            CONC_ALL(me)
            LINE(me, [[
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
}
]])
        else
            DBG('TODO-ATOMIC-ISR')
--[[
            LINE(me, 'ceu_out_isr_off();')
            CONC(me)
            LINE(me, 'ceu_out_isr_on();')
]]
        end
    end,

    Async_Thread = function (me)
        local _,_, blk = unpack(me)

        local v = CUR('__thread_'..me.n)

-- TODO: pause, resume
        -- finalize
        LINE(me, [[
_ceu_mem->trails[]]..me.trails[1]..[[].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->trails[]]..me.trails[1]..[[].lbl    = ]]..me.lbl_fin.id..[[;
_ceu_mem->trails[]]..me.trails[1]..[[].clr_range =
    (tceu_evt_range) { _ceu_mem, ]]..me.trails[1]..','..me.trails[2]..[[ };

if (0) {
]])
        CASE(me, me.lbl_fin)
        LINE(me, [[
    if (]]..v..[[ != NULL) {
        ]]..v..[[->has_aborted = 1;
        CEU_THREADS_CANCEL(]]..v..[[->id);
    }
]])
        HALT(me)
        LINE(me, [[
}
]])

        -- spawn
        LINE(me, [[
]]..v..[[ = (tceu_threads_data*) ceu_callback_ptr_num(
                                    CEU_CALLBACK_REALLOC,
                                    NULL,
                                    sizeof(tceu_threads_data)
                                 ).value.ptr;
if (]]..v..[[ != NULL)
{
    ]]..v..[[->nxt = CEU_APP.threads_head;
    CEU_APP.threads_head = ]]..v..[[;

    ]]..v..[[->has_started    = 0;
    ]]..v..[[->has_terminated = 0;
    ]]..v..[[->has_aborted    = 0;
    ]]..v..[[->has_notified   = 0;

    tceu_threads_param p = { _ceu_mem, ]]..v..[[ };
    int ret =
        CEU_THREADS_CREATE(&]]..v..[[->id, _ceu_thread_]]..me.n..[[, &p);
    if (ret == 0) {
        while (! ]]..v..[[->has_started);   /* wait copy of "p" */
        while (1) {
]])
        HALT(me, {
            trail = me.trails[1]+1,
            { ['evt.id'] = 'CEU_INPUT__THREAD' },
            { lbl        = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
        LINE(me, [[
            {
                CEU_THREADS_T** __ceu_casted = (CEU_THREADS_T**)_ceu_occ->params;
                if (*(*(__ceu_casted)) == ]]..v..[[->id) {
                    break; /* this thread is terminating */
                }
            }
        }
    }
    /* proceed with sync execution (already locked) */
}
]])

        -- function definition
        CODES.threads = CODES.threads .. [[
static CEU_THREADS_PROTOTYPE(_ceu_thread_]]..me.n..[[,void* __ceu_p)
{
    /* start thread */

    /* copy param */
    tceu_threads_param _ceu_p = *((tceu_threads_param*) __ceu_p);
    tceu_code_mem* _ceu_mem = _ceu_p.mem;
    _ceu_p.thread->has_started = 1;

    /* body */
    ]]..blk.code..[[
#if 0
    goto ]]..me.lbl_abt.id..[[; /* avoids "not used" warning */
#endif

    /* goto from "atomic" and already terminated */
]]..me.lbl_abt.id..[[:

    /* terminate thread */
    ceu_callback_void_void(CEU_CALLBACK_THREAD_TERMINATING);
    CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
    _ceu_p.thread->has_terminated = 1;
    _ceu_mem->trails[]]..me.trails[1]..[[].evt.id = CEU_INPUT__NONE;
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
    CEU_THREADS_RETURN(NULL);
}
]]
    end,

    ---------------------------------------------------------------------------

    Set_Lua = function (me)
        local lua, to = unpack(me)
        local tp = to.info.tp

        CONC(me, lua)

        -- bool
        if TYPES.check(tp,'bool') then
            LINE(me, [[
]]..V(to)..[[ = lua_toboolean(]]..LUA(me)..[[,-1);
]])

        -- num
        elseif TYPES.is_num(tp) then
            LINE(me, [[
if (lua_isnumber(]]..LUA(me)..[[,-1)) {
    if (lua_isinteger(]]..LUA(me)..[[,-1)) {
        ]]..V(to)..[[ = lua_tointeger(]]..LUA(me)..[[,-1);
    } else {
        ]]..V(to)..[[ = lua_tonumber(]]..LUA(me)..[[,-1);
    }
} else {
    lua_pop(]]..LUA(me)..[[,1);
    lua_pushstring(]]..LUA(me)..[[, "number expected");
    goto _CEU_LUA_ERR_]]..lua.n..[[;
}
]])
        elseif TYPES.check(tp,'&&') then
            LINE(me, [[
{
    if (lua_islightuserdata(]]..LUA(me)..[[,-1)) {
        ]]..V(to)..[[ = lua_touserdata(]]..LUA(me)..[[,-1);
    } else {
        lua_pushstring(]]..LUA(me)..[[, "not implemented [3]");
        lua_pop(]]..LUA(me)..[[,1);
        goto _CEU_LUA_ERR_]]..lua.n..[[;
    }
}
]])
        else
            error 'not implemented'
        end

        LINE(me, lua.code_after)
    end,

    Lua_Do = CONC_ALL,
    Lua_Do_Open = function (me)
        local n = unpack(me)
        LINE(me, [[
]]..CUR('__lua_'..n)..[[ = luaL_newstate();
ceu_dbg_assert(]]..CUR('__lua_'..n)..[[ != NULL);
luaL_openlibs(]]..CUR('__lua_'..n)..[[);
lua_atpanic(]]..CUR('__lua_'..n)..[[, ceu_lua_atpanic);
]])
    end,
    Lua_Do_Close = function (me)
        local n = unpack(me)
        LINE(me, [[
lua_close(]]..CUR('__lua_'..n)..[[);
]])
    end,

    Lua = function (me)
        local nargs = #me.params
        local is_set = AST.par(me,'Set_Lua') or AST.par(me,'Set_Vec')
        local nrets = (is_set and 1) or 0

        local lua = me.lua
        lua = string.format('%q', lua)
        lua = string.gsub(lua, '\n', 'n') -- undo format for \n

        me.code_after = [[
    if (0) {
/* ERROR */
_CEU_LUA_ERR_]]..me.n..[[:;
        lua_concat(]]..LUA(me)..[[, 6);
        lua_error(]]..LUA(me)..[[); /* TODO */
    }
/* OK */
    lua_pop(]]..LUA(me)..[[, ]]..(is_set and 6 or 5)..[[);
}
]]

        LINE(me, [[
{
    int err_line = __LINE__ - 1;
    lua_pushstring(]]..LUA(me)..[[, "[");
    lua_pushstring(]]..LUA(me)..[[, __FILE__);
    lua_pushstring(]]..LUA(me)..[[, ":");
    lua_pushinteger(]]..LUA(me)..[[, err_line);
    lua_pushstring(]]..LUA(me)..[[, "] lua error : ");

    int err = luaL_loadstring(]]..LUA(me)..[[, ]]..lua..[[);
    if (err) {
        goto _CEU_LUA_ERR_]]..me.n..[[;
    }
]])

        for _, p in ipairs(me.params) do
            local tp = p.info.tp
            ASR(not TYPES.is_nat(tp), me, 'unknown type')
            if p.info.dcl and p.info.dcl.tag=='Vec' then
                if TYPES.check(tp,'byte') then
                    LINE(me, [[
    lua_pushlstring(]]..LUA(me)..[[,(char*)]]..V(p)..[[.buf,]]..V(p)..[[.len);
]])
                else
                    error 'not implemented'
                end
            elseif TYPES.check(tp,'bool') then
                LINE(me, [[
    lua_pushboolean(]]..LUA(me)..[[,]]..V(p)..[[);
]])
            elseif TYPES.is_num(tp) then
                local tp_id = unpack(TYPES.ID_plain(tp))
                if tp_id=='float' or tp_id=='f32' or tp_id=='f64' then
                    LINE(me, [[
    lua_pushnumber(]]..LUA(me)..[[,]]..V(p)..[[);
]])
                else
                    LINE(me, [[
    lua_pushinteger(]]..LUA(me)..[[,]]..V(p)..[[);
]])
                end
            elseif TYPES.check(tp,'_char','&&') then
                LINE(me, [[
    lua_pushstring(]]..LUA(me)..[[,]]..V(p)..[[);
]])
            elseif TYPES.check(tp,'&&') then
                LINE(me, [[
    lua_pushlightuserdata(]]..LUA(me)..[[,]]..V(p)..[[);
]])
            else
                error 'not implemented'
            end
        end

        LINE(me, [[
    err = lua_pcall(]]..LUA(me)..[[, ]]..nargs..','..nrets..[[, 0);
    if (err) {
        goto _CEU_LUA_ERR_]]..me.n..[[;
    }
]])

        if not is_set then
            LINE(me, me.code_after)
        end
    end,
}

-------------------------------------------------------------------------------

local function SUB (str, from, to)
    assert(to, from)
    local i,e = string.find(str, from, 1, true)
    if i then
        return SUB(string.sub(str,1,i-1) .. to .. string.sub(str,e+1),
                   from, to)
    else
        return str
    end
end

AST.visit(F)

local labels do
    labels = ''
    for _, lbl in ipairs(LABELS.list) do
        labels = labels..lbl.id..',\n'
    end
end

local features do
    features = ''
    for k,v in pairs(CEU.opts) do
        if string.sub(k,1,13) == 'ceu_features_' then
            if v then
                features = features .. '#define '..string.upper(k)..'\n'
            end
        end
    end
end

-- CEU.C
local c = PAK.files.ceu_c
local c = SUB(c, '=== FEATURES ===',         features)
local c = SUB(c, '=== NATIVE_PRE ===',       CODES.native.pre)
local c = SUB(c, '=== EXTS_ENUM_INPUT ===',  MEMS.exts.enum_input)
local c = SUB(c, '=== EXTS_DEFINES_INPUT_OUTPUT ===', MEMS.exts.defines_input_output)
local c = SUB(c, '=== EVTS_ENUM ===',        MEMS.evts.enum)
local c = SUB(c, '=== DATAS_HIERS ===',      MEMS.datas.hiers)
local c = SUB(c, '=== DATAS_MEMS ===',       MEMS.datas.mems)
local c = SUB(c, '=== EXTS_ENUM_OUTPUT ===', MEMS.exts.enum_output)
local c = SUB(c, '=== TCEU_NTRL ===',        TYPES.n2uint(AST.root.trails_n))
local c = SUB(c, '=== TCEU_NLBL ===',        TYPES.n2uint(#LABELS.list))
local c = SUB(c, '=== CODES_MEMS ===',       MEMS.codes.mems)
local c = SUB(c, '=== CODES_ARGS ===',       MEMS.codes.args)
local c = SUB(c, '=== EXTS_TYPES ===',       MEMS.exts.types)
local c = SUB(c, '=== EVTS_TYPES ===',       MEMS.evts.types)
local c = SUB(c, '=== LABELS ===',           labels)
local c = SUB(c, '=== NATIVE_POS ===',       CODES.native.pos)
local c = SUB(c, '=== THREADS ===',          CODES.threads)
local c = SUB(c, '=== CODES_WRAPPERS ===',   MEMS.codes.wrappers)
local c = SUB(c, '=== CODES ===',            AST.root.code)

if CEU.opts.ceu_output == '-' then
    print('\n\n/* CEU_C */\n\n'..c)
else
    local C = ASR(io.open(CEU.opts.ceu_output,'w'))
    C:write('\n\n/* CEU_C */\n\n'..c)
    C:close()
end

end

end
DBG,ASR = DBG1,ASR1
if CEU.opts.env then
    
do
local c = ''

--env-types
do
    local f = ASR(io.open(CEU.opts.env_types))
    c = c..'\n\n/* ENV_HEADER */\n\n'..f:read'*a'
    f:close()
end

--env-threads
do
    if CEU.opts.env_threads then
        local f = ASR(io.open(CEU.opts.env_threads))
        c = c..'\n\n/* ENV_THREADS */\n\n'..f:read'*a'
        f:close()
    end
end

-- callbacks
do
    c = c..[[
typedef union tceu_callback_arg {
    void* ptr;
    s32   num;
    usize size;
} tceu_callback_arg;

typedef struct tceu_callback_ret {
    bool is_handled;
    tceu_callback_arg value;
} tceu_callback_ret;

tceu_callback_ret ceu_callback (int cmd, tceu_callback_arg p1, tceu_callback_arg p2);

#define ceu_callback_void_void(cmd)                     \
        ceu_callback(cmd, (tceu_callback_arg){},        \
                          (tceu_callback_arg){})
#define ceu_callback_num_void(cmd,p1)                   \
        ceu_callback(cmd, (tceu_callback_arg){.num=p1}, \
                          (tceu_callback_arg){})
#define ceu_callback_num_ptr(cmd,p1,p2)                 \
        ceu_callback(cmd, (tceu_callback_arg){.num=p1}, \
                          (tceu_callback_arg){.ptr=p2})
#define ceu_callback_num_num(cmd,p1,p2)                 \
        ceu_callback(cmd, (tceu_callback_arg){.num=p1}, \
                          (tceu_callback_arg){.num=p2})
#define ceu_callback_ptr_num(cmd,p1,p2)                 \
        ceu_callback(cmd, (tceu_callback_arg){.ptr=p1}, \
                          (tceu_callback_arg){.num=p2})
#define ceu_callback_ptr_size(cmd,p1,p2)                \
        ceu_callback(cmd, (tceu_callback_arg){.ptr=p1}, \
                          (tceu_callback_arg){.size=p2})

#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#define ceu_callback_assert_msg_ex(v,msg,file,line)                              \
    if (!(v)) {                                                                  \
        if ((msg)!=NULL) {                                                       \
            ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"[");               \
            ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)(file));            \
            ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)":");               \
            ceu_callback_num_num(CEU_CALLBACK_LOG, 2, line);                     \
            ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"] ");              \
            ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"runtime error: "); \
            ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)(msg));             \
            ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"\n");              \
        }                                                                        \
        ceu_callback_num_ptr(CEU_CALLBACK_ABORT, 0, NULL);                       \
    }
#define ceu_callback_assert_msg(v,msg) ceu_callback_assert_msg_ex((v),(msg),__FILE__,__LINE__)

#define ceu_dbg_assert(v) ceu_callback_assert_msg(v,"bug found")

enum {
    CEU_CALLBACK_START,
    CEU_CALLBACK_STOP,
    CEU_CALLBACK_STEP,
    CEU_CALLBACK_ABORT,
    CEU_CALLBACK_LOG,
    CEU_CALLBACK_TERMINATING,
    CEU_CALLBACK_ASYNC_PENDING,
    CEU_CALLBACK_THREAD_TERMINATING,
    CEU_CALLBACK_WCLOCK_MIN,
    CEU_CALLBACK_OUTPUT,
    CEU_CALLBACK_REALLOC,
};
]]
end

if TESTS then
    c = c .. [[
u32 _ceu_tests_trails_visited_ = 0;
]]
end

--env-ceu
do
    local f = ASR(io.open(CEU.opts.env_ceu))
    c = c..'\n\n/* ENV_CEU */\n\n'..f:read'*a'
    f:close()
end

--env-main
do
    if CEU.opts.env_main then
        local f = ASR(io.open(CEU.opts.env_main))
        c = c..'\n\n/* ENV_MAIN */\n\n'..f:read'*a'
        f:close()
    end
end

--env-output
do
    local out = [[
/*
* This file is automatically generated.
* http://www.ceu-lang.org/
* http://github.com/fsantanna/ceu/
*
* Céu is distributed under the MIT License:
*

Copyright (C) 2012-2016 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

]] .. c

    if CEU.opts.env_output == '-' then
        print(out)
    else
        local f = ASR(io.open(CEU.opts.env_output,'w'))
        f:write(out)
        f:close()
    end
end

end

end
if CEU.opts.cc then
    
do
--DBG(CEU.opts.cc_exe..' -xc '..CEU.opts.cc_input..' '..  '-o '..CEU.opts.cc_output..' '..  CEU.opts.cc_args..' 2>&1')
local cc = CEU.opts.cc_exe..' -xc '..CEU.opts.cc_input..' '..
            '-o '..CEU.opts.cc_output..' '..
            CEU.opts.cc_args..' 2>&1'
local f = io.popen(cc)
local err = f:read'*a'
local ok = f:close()
ASR(ok, err)
DBG(err)

end

end
--AST.dump(AST.root)
