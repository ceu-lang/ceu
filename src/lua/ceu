#!/usr/bin/env lua5.3
--[[
-- This file is automatically generated.
-- Check the github repository for a readable version:
-- http://github.com/fsantanna/ceu
--
-- CÃ©u is distributed under the MIT License:
--

Copyright (C) 2012-2016 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--
--]]

PAK = {
    lua_exe = 'lua5.3',
    ceu_ver = '0.30-alpha',
    ceu_git = '9b918d96cf2d70f5c9d28717878a4ea715eb485e',
    files = {
        ceu_c =
            [====[
=== CEU_FEATURES ===        /* CEU_FEATURES */

#ifdef CEU_FEATURES_TRACE
#define CEU_TRACE_null   ((tceu_trace){NULL,NULL,0})

typedef struct tceu_trace {
    struct tceu_trace* up;
    const char* file;
    u32 line;
} tceu_trace;
#endif

typedef union tceu_callback_val {
    void* ptr;
    s32   num;
    usize size;
} tceu_callback_val;

static tceu_callback_val ceu_callback_ret;

typedef int (*tceu_callback_f) (int, tceu_callback_val, tceu_callback_val
#ifdef CEU_FEATURES_TRACE
                               , tceu_trace
#endif
                               );

typedef struct tceu_callback {
    tceu_callback_f       f;
    struct tceu_callback* nxt;
} tceu_callback;

static void ceu_callback (int cmd, tceu_callback_val p1, tceu_callback_val p2
#ifdef CEU_FEATURES_TRACE
                         , tceu_trace trace
#endif
                         );

#ifdef CEU_FEATURES_TRACE
#ifdef __cplusplus
#define ceu_callback_void_void(cmd,trace)               \
        ceu_callback(cmd, {},                           \
                          {},                           \
                          trace)
#else
#define ceu_callback_void_void(cmd,trace)               \
        ceu_callback(cmd, (tceu_callback_val){},        \
                          (tceu_callback_val){},        \
                          trace)
#endif
#define ceu_callback_num_void(cmd,p1,trace)             \
        ceu_callback(cmd, (tceu_callback_val){.num=p1}, \
                          (tceu_callback_val){},        \
                          trace)
#define ceu_callback_num_ptr(cmd,p1,p2,trace)           \
        ceu_callback(cmd, (tceu_callback_val){.num=p1}, \
                          (tceu_callback_val){.ptr=p2}, \
                          trace)
#define ceu_callback_num_num(cmd,p1,p2,trace)           \
        ceu_callback(cmd, (tceu_callback_val){.num=p1}, \
                          (tceu_callback_val){.num=p2}, \
                          trace)
#define ceu_callback_ptr_num(cmd,p1,p2,trace)           \
        ceu_callback(cmd, (tceu_callback_val){.ptr=p1}, \
                          (tceu_callback_val){.num=p2}, \
                          trace)
#define ceu_callback_ptr_ptr(cmd,p1,p2,trace)           \
        ceu_callback(cmd, (tceu_callback_val){.ptr=p1}, \
                          (tceu_callback_val){.ptr=p2}, \
                          trace)
#define ceu_callback_ptr_size(cmd,p1,p2,trace)          \
        ceu_callback(cmd, (tceu_callback_val){.ptr=p1}, \
                          (tceu_callback_val){.size=p2},\
                          trace)
#else
#ifdef __cplusplus
#define ceu_callback_void_void(cmd,trace)               \
        ceu_callback(cmd, {},                           \
                          {})
#else
#define ceu_callback_void_void(cmd,trace)               \
        ceu_callback(cmd, (tceu_callback_val){},        \
                          (tceu_callback_val){})
#endif
#define ceu_callback_num_void(cmd,p1,trace)             \
        ceu_callback(cmd, (tceu_callback_val){.num=p1}, \
                          (tceu_callback_val){})
#define ceu_callback_num_ptr(cmd,p1,p2,trace)           \
        ceu_callback(cmd, (tceu_callback_val){.num=p1}, \
                          (tceu_callback_val){.ptr=p2})
#define ceu_callback_num_num(cmd,p1,p2,trace)           \
        ceu_callback(cmd, (tceu_callback_val){.num=p1}, \
                          (tceu_callback_val){.num=p2})
#define ceu_callback_ptr_num(cmd,p1,p2,trace)           \
        ceu_callback(cmd, (tceu_callback_val){.ptr=p1}, \
                          (tceu_callback_val){.num=p2})
#define ceu_callback_ptr_ptr(cmd,p1,p2,trace)           \
        ceu_callback(cmd, (tceu_callback_val){.ptr=p1}, \
                          (tceu_callback_val){.ptr=p2})
#define ceu_callback_ptr_size(cmd,p1,p2,trace)          \
        ceu_callback(cmd, (tceu_callback_val){.ptr=p1}, \
                          (tceu_callback_val){.size=p2})
#endif

#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"

#ifdef ceu_assert_ex
#define ceu_assert(a,b) ceu_assert_ex(a,b,NONE)
#else
#ifdef CEU_FEATURES_TRACE
#define ceu_assert_ex(v,msg,trace)                                  \
    if (!(v)) {                                                     \
        ceu_trace(trace, msg);                                      \
        ceu_callback_num_ptr(CEU_CALLBACK_ABORT, 0, NULL, trace);   \
    }
#define ceu_assert(v,msg) ceu_assert_ex((v),(msg), CEU_TRACE(0))
#else
#define ceu_assert_ex(v,msg,trace)                                  \
    if (!(v)) {                                                     \
        ceu_callback_num_ptr(CEU_CALLBACK_ABORT, 0, NULL, trace);   \
    }
#define ceu_assert(v,msg) ceu_assert_ex((v),(msg),NONE)
#endif
#endif

#define ceu_dbg_log(msg)  { ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)(msg), CEU_TRACE(0)); \
                            ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"\n",  CEU_TRACE(0)); }

enum {
    CEU_CALLBACK_START,
    CEU_CALLBACK_STOP,
    CEU_CALLBACK_STEP,
    CEU_CALLBACK_ABORT,
    CEU_CALLBACK_LOG,
    CEU_CALLBACK_TERMINATING,
    CEU_CALLBACK_ASYNC_PENDING,
    CEU_CALLBACK_THREAD_TERMINATING,
    CEU_CALLBACK_ISR_ENABLE,
    CEU_CALLBACK_ISR_ATTACH,
    CEU_CALLBACK_ISR_DETACH,
    CEU_CALLBACK_ISR_EMIT,
    CEU_CALLBACK_WCLOCK_MIN,
    CEU_CALLBACK_WCLOCK_DT,
    CEU_CALLBACK_OUTPUT,
    CEU_CALLBACK_REALLOC,
};

#ifdef CEU_FEATURES_TRACE
static void ceu_trace (tceu_trace trace, const char* msg) {
    static bool IS_FIRST = 1;
    bool is_first = IS_FIRST;

    IS_FIRST = 0;

    if (trace.up != NULL) {
        ceu_trace(*trace.up, msg);
    }

    if (is_first) {
        IS_FIRST = 1;
        ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"\n", CEU_TRACE_null);
    }

    ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"[",          CEU_TRACE_null);
    ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)(trace.file), CEU_TRACE_null);
    ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)":",          CEU_TRACE_null);
    ceu_callback_num_num(CEU_CALLBACK_LOG, 2, trace.line,          CEU_TRACE_null);
    ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"]",          CEU_TRACE_null);
    ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)" -> ",       CEU_TRACE_null);

    if (is_first) {
        ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"runtime error: ", CEU_TRACE_null);
        ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)(msg),             CEU_TRACE_null);
        ceu_callback_num_ptr(CEU_CALLBACK_LOG, 0, (void*)"\n",              CEU_TRACE_null);
    }
}
#else
#define ceu_trace(a,b)
#endif
]====]..
            [====[
#include <stdlib.h>     /* NULL */
#include <string.h>     /* memcpy */

typedef struct {
    usize max;
    usize len;
    usize ini;
    usize unit;
    u8    is_ring:    1;
    u8    is_dyn:     1;
    u8    is_freezed: 1;
    byte* buf;
} tceu_vector;

#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))

#define ceu_vector_idx(vec,idx)     ((vec)->is_ring ? (((vec)->ini + (idx)) % (vec)->max) : (idx))
#define ceu_vector_buf_get(vec,idx) (&(vec)->buf[ceu_vector_idx(vec,idx)*(vec)->unit])
#define ceu_vector_ptr(vec)         (vec)

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_buf_set(vec,idx,buf,nu)      ceu_vector_buf_set_ex(vec,idx,buf,nu,CEU_TRACE(0))
#define ceu_vector_copy(dst,dst_i,src,src_i,n)  ceu_vector_copy_ex(dst,dst_i,src,src_i,n,CEU_TRACE(0))
#define ceu_vector_setmax(vec,len,freeze)       ceu_vector_setmax_ex(vec,len,freeze,CEU_TRACE(0))
#define ceu_vector_setlen_could(vec,len,grow)   ceu_vector_setlen_could_ex(vec,len,grow,CEU_TRACE(0))
#define ceu_vector_setlen(a,b,c)                ceu_vector_setlen_ex(a,b,c,CEU_TRACE(0))
#define ceu_vector_geti(a,b)                    ceu_vector_geti_ex(a,b,CEU_TRACE(0))
#else
#define ceu_vector_buf_set(vec,idx,buf,nu)      ceu_vector_buf_set_ex(vec,idx,buf,nu)
#define ceu_vector_copy(dst,dst_i,src,src_i,n)  ceu_vector_copy_ex(dst,dst_i,src,src_i,n)
#define ceu_vector_setmax(vec,len,freeze)       ceu_vector_setmax_ex(vec,len,freeze,_)
#define ceu_vector_setlen_could(vec,len,grow)   ceu_vector_setlen_could_ex(vec,len,grow)
#define ceu_vector_setlen(a,b,c)                ceu_vector_setlen_ex(a,b,c,_)
#define ceu_vector_geti(a,b)                    ceu_vector_geti_ex(a,b)
#endif

void  ceu_vector_init            (tceu_vector* vector, usize max, bool is_ring, bool is_dyn, usize unit, byte* buf);

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_setmax_ex(a,b,c,d) ceu_vector_setmax_ex_(a,b,c,d)
#else
#define ceu_vector_setmax_ex(a,b,c,d) ceu_vector_setmax_ex_(a,b,c)
#endif

byte* ceu_vector_setmax_ex_      (tceu_vector* vector, usize len, bool freeze
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

int   ceu_vector_setlen_could_ex (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_setlen_ex(a,b,c,d) ceu_vector_setlen_ex_(a,b,c,d)
#else
#define ceu_vector_setlen_ex(a,b,c,d) ceu_vector_setlen_ex_(a,b,c)
#endif

void  ceu_vector_setlen_ex_      (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

byte* ceu_vector_geti_ex         (tceu_vector* vector, usize idx
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

void  ceu_vector_buf_set_ex      (tceu_vector* vector, usize idx, byte* buf, usize nu
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

void  ceu_vector_copy_ex         (tceu_vector* dst, usize dst_i, tceu_vector* src, usize src_i, usize n
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

#if 0
char* ceu_vector_tochar (tceu_vector* vector);
#endif

void ceu_vector_init (tceu_vector* vector, usize max, bool is_ring,
                      bool is_dyn, usize unit, byte* buf) {
    vector->len        = 0;
    vector->max        = max;
    vector->ini        = 0;
    vector->unit       = unit;
    vector->is_dyn     = is_dyn;
    vector->is_ring    = is_ring;
    vector->is_freezed = 0;
    vector->buf        = buf;
}

byte* ceu_vector_setmax_ex_      (tceu_vector* vector, usize len, bool freeze
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(vector->is_dyn, "static vector", trace);

    if (vector->max == len) {
        goto END;
    }

    if (len == 0) {
        /* free */
        if (vector->buf != NULL) {
            vector->max = 0;
            ceu_callback_ptr_num(CEU_CALLBACK_REALLOC, vector->buf, 0, trace);
            vector->buf = NULL;
        }
    } else {
        ceu_assert_ex(len > vector->max, "not implemented: shrinking vectors", trace);
        ceu_callback_ptr_size(CEU_CALLBACK_REALLOC,
                              vector->buf,
                              len*vector->unit,
                              trace
                             );
        vector->buf = (byte*) ceu_callback_ret.ptr;

        if (vector->is_ring && vector->ini>0) {
            /*
             * [X,Y,Z,I,J,K,###,A,B,C]       -> (grow) ->
             * [X,Y,Z,I,J,K,###,A,B,C,-,-,-] -> (1st memcpy) ->
             * [?,?,?,I,J,K,###,A,B,C,X,Y,Z] -> (2nd memmove) ->
             * [I,J,K,###,-,-,-,A,B,C,X,Y,Z]
             */
            usize dif = (len - vector->max) * vector->unit;
            memcpy (&vector->buf[vector->max],          // -,-,-
                    &vector->buf[0],                    // X,Y,Z
                    dif * vector->unit);                // 3
            memmove(&vector->buf[0],                    // X,Y,Z
                    &vector->buf[dif * vector->unit],   // I,J,K
                    vector->ini * vector->unit);        // 3
        }

        vector->max = len;
    }

    if (freeze) {
        vector->is_freezed = 1;
    }

END:
    return vector->buf;
}

int   ceu_vector_setlen_could_ex (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    /* must fit w/o growing */
    if (!grow) {
        if (len > vector->len) {
            return 0;
        }
    }

    /* fixed size */
    if (!vector->is_dyn || vector->is_freezed) {
        if (len > vector->max) {
            return 0;
        }

    /* variable size */
    } else {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
        } else {
            /* grow vector */
            if (ceu_vector_setmax_ex(vector,len,0,trace) == NULL) {
                if (len != 0) {
                    return 0;
                }
            }
        }
    }

    return 1;
}

void  ceu_vector_setlen_ex_      (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    /* must fit w/o growing */
    if (!grow) {
        ceu_assert_ex(len <= vector->len, "access out of bounds", trace);
    }

    /* fixed size */
    if (!vector->is_dyn || vector->is_freezed) {
        ceu_assert_ex(len <= vector->max, "access out of bounds", trace);

    /* variable size */
    } else {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
/* TODO: shrink memory */
        } else {
            /* grow vector */
            if (ceu_vector_setmax_ex(vector,len,0,trace) == NULL) {
                ceu_assert_ex(len==0, "access out of bounds", trace);
            }
        }
    }

    if (vector->is_ring && len<vector->len) {
        vector->ini = (vector->ini + (vector->len - len)) % vector->max;
    }

    vector->len = len;
}

byte* ceu_vector_geti_ex         (tceu_vector* vector, usize idx
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(idx < vector->len, "access out of bounds", trace);
    return ceu_vector_buf_get(vector, idx);
}

void  ceu_vector_buf_set_ex      (tceu_vector* vector, usize idx, byte* buf, usize nu
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    usize n = ((nu % vector->unit) == 0) ? nu/vector->unit : nu/vector->unit+1;
#if 0
    if (vector->len < idx+n) {
        char err[50];
        snprintf(err,50, "access out of bounds : length=%ld, index=%ld", vector->len, idx+n);
        ceu_assert_ex(0, err, file, line);
    }
#else
    ceu_assert_ex((vector->len >= idx+n), "access out of bounds", trace);
#endif

    usize k  = (vector->max - ceu_vector_idx(vector,idx));
    usize ku = k * vector->unit;

    if (vector->is_ring && ku<nu) {
        memcpy(ceu_vector_buf_get(vector,idx),   buf,    ku);
        memcpy(ceu_vector_buf_get(vector,idx+k), buf+ku, nu-ku);
    } else {
        memcpy(ceu_vector_buf_get(vector,idx), buf, nu);
    }
}

void  ceu_vector_copy_ex         (tceu_vector* dst, usize dst_i, tceu_vector* src, usize src_i, usize n
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    usize unit = dst->unit;
    ceu_assert_ex((src->unit == dst->unit), "incompatible vectors", trace);

    ceu_assert_ex((src->len >= src_i+n), "access out of bounds", trace);
    ceu_vector_setlen_ex(dst, MAX(dst->len,dst_i+n), 1, trace);

    usize dif_src = MIN(n, (src->max - ceu_vector_idx(src,src_i)));
    usize dif_dst = MIN(n, (dst->max - ceu_vector_idx(dst,dst_i)));
    usize dif = MIN(dif_src, dif_dst);

    memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);

    dst_i += dif;
    src_i += dif;
    n -= dif;

    if (n == 0) {
        return;
    }

    if (dif_src > dif_dst) {
        dif = MIN(n, (src->max - ceu_vector_idx(src,src_i)));
        memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);
        dst_i += dif;
        src_i += dif;
        n -= dif;
    } else if (dif_dst > dif_src) {
        dif = MIN(n, (dst->max - ceu_vector_idx(dst,src_i)));
        memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);
        dst_i += dif;
        src_i += dif;
        n -= dif;
    }

    if (n == 0) {
        return;
    }

    memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), n);
}
]====]..
            [====[
#include <stdlib.h>     /* NULL */

typedef struct {
    usize   len;
    usize   free;
    usize   index;
    usize   unit;
    byte*   buf;
    byte**  queue; /* NULL on dynamic pools */
} tceu_pool;

void ceu_pool_init (tceu_pool* pool, usize len, usize unit, byte** queue, byte* buf)
{
    usize i;
    pool->len   = len;
    pool->free  = len;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->buf   = buf;
    for (i=0; i<len; i++) {
        queue[i] = &buf[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->len) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    usize empty = pool->index + pool->free;
    if (empty >= pool->len) {
        empty -= pool->len;
    }
    pool->queue[empty] = val;
    pool->free++;
}
]====]..
            [====[
#include <stddef.h>     /* offsetof */
#include <stdlib.h>     /* NULL */
#include <string.h>     /* memset, strlen */
#ifdef CEU_TESTS
#include <stdio.h>
#endif

#ifdef CEU_FEATURES_LUA
#include <lua5.3/lua.h>
#include <lua5.3/lauxlib.h>
#include <lua5.3/lualib.h>
#endif

#define S8_MIN   -127
#define S8_MAX    127
#define U8_MAX    255

#define S16_MIN  -32767
#define S16_MAX   32767
#define U16_MAX   65535

#define S32_MIN  -2147483647
#define S32_MAX   2147483647
#define U32_MAX   4294967295

#define S64_MIN  -9223372036854775807
#define S64_MAX   9223372036854775807
#define U64_MAX   18446744073709551615

#define CEU_SEQ_MAX U16_MAX
/* TODO */

typedef u16 tceu_nevt;   /* TODO */
typedef u16 tceu_nseq;   /* TODO */
typedef === CEU_TCEU_NTRL === tceu_ntrl;
typedef === CEU_TCEU_NLBL === tceu_nlbl;

#define CEU_API
CEU_API void ceu_start (tceu_callback* cb, int argc, char* argv[]);
CEU_API void ceu_stop  (void);
CEU_API void ceu_input (tceu_nevt evt_id, void* evt_params);
CEU_API int  ceu_loop  (tceu_callback* cb, int argc, char* argv[]);
CEU_API void ceu_callback_register (tceu_callback* cb);

struct tceu_stk;
struct tceu_code_mem;
struct tceu_pool_pak;
struct tceu_evt_occ;

typedef struct tceu_evt {
    tceu_nevt id;
    union {
        void* mem;                   /* CEU_INPUT__PROPAGATE_CODE, CEU_EVENT__MIN */
#ifdef CEU_FEATURES_POOL
        struct tceu_pool_pak* pak;   /* CEU_INPUT__PROPAGATE_POOL */
#endif
    };
} tceu_evt;

typedef struct tceu_evt_range {
    struct tceu_code_mem* mem;
    tceu_ntrl             trl0;
    tceu_ntrl             trlF;
} tceu_evt_range;

typedef struct tceu_evt_occ {
    tceu_evt       evt;
    tceu_nseq      seq;
    void*          params;
    tceu_evt_range range;
} tceu_evt_occ;

struct tceu_data_Exception;

typedef struct tceu_trl {
    struct {
        tceu_evt evt;
        union {
            /* NORMAL, CEU_EVENT__MIN */
            struct {
                tceu_nlbl lbl;
                union {
                    tceu_nseq seq;              /* NORMAL */
                    tceu_evt_range clr_range;   /* CEU_INPUT__CLEAR */
                };
            };

            /* CEU_INPUT__PAUSE_BLOCK */
            struct {
                tceu_evt  pse_evt;
                tceu_ntrl pse_skip;
                u8        pse_paused;
            };
        };
    };
} tceu_trl;

#ifdef CEU_FEATURES_EXCEPTION
typedef struct tceu_catch {
    struct tceu_catch*         up;
    struct tceu_code_mem*      mem;
    tceu_ntrl                  trl;
    struct tceu_opt_Exception* exception;
} tceu_catch;
#endif

typedef struct tceu_code_mem {
#ifdef CEU_FEATURES_POOL
    struct tceu_pool_pak* pak;
#endif
    struct tceu_code_mem* up_mem;
    tceu_ntrl   up_trl;
    u8          depth;
#ifdef CEU_FEATURES_TRACE
    tceu_trace  trace;
#endif
#ifdef CEU_FEATURES_EXCEPTION
    tceu_catch* catches;
#endif
#ifdef CEU_FEATURES_LUA
    lua_State*  lua;
#endif
    tceu_ntrl   trails_n;
    tceu_trl    _trails[0];
} tceu_code_mem;

#ifdef CEU_FEATURES_POOL
typedef struct tceu_code_mem_dyn {
    struct tceu_code_mem_dyn* prv;
    struct tceu_code_mem_dyn* nxt;
    u8 is_alive: 1;
    tceu_code_mem mem[0];   /* actual tceu_code_mem is in sequence */
} tceu_code_mem_dyn;

typedef struct tceu_pool_pak {
    tceu_pool         pool;
    tceu_code_mem_dyn first;
    tceu_code_mem*    up_mem;
    tceu_ntrl         up_trl;
    u8                n_traversing;
} tceu_pool_pak;
#endif

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_EVT(a,b) CEU_OPTION_EVT_(a,b)
#else
#define CEU_OPTION_EVT(a,b) CEU_OPTION_EVT_(a)
#endif

static tceu_evt* CEU_OPTION_EVT_ (tceu_evt* alias
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(alias != NULL, "value is not set", trace);
    return alias;
}

#ifdef CEU_FEATURES_THREAD
typedef struct tceu_threads_data {
    CEU_THREADS_T id;
    u8 has_started:    1;
    u8 has_terminated: 1;
    u8 has_aborted:    1;
    u8 has_notified:   1;
    struct tceu_threads_data* nxt;
} tceu_threads_data;

typedef struct {
    tceu_code_mem*     mem;
    tceu_threads_data* thread;
} tceu_threads_param;
#endif

#ifdef CEU_FEATURES_ISR
typedef struct tceu_evt_id_params {
    tceu_nevt id;
    void*     params;
} tceu_evt_id_params;

typedef struct tceu_isr {
    void (*fun)(tceu_code_mem*);
    tceu_code_mem*     mem;
    tceu_evt_id_params evt;
} tceu_isr;

#endif

/*****************************************************************************/

/* CEU_NATIVE_PRE */
=== CEU_NATIVE_PRE ===

/* EVENTS_ENUM */

enum {
    /* non-emitable */
    CEU_INPUT__NONE = 0,
    CEU_INPUT__FINALIZE,
    CEU_INPUT__THROW,
    CEU_INPUT__PAUSE_BLOCK,
    CEU_INPUT__PROPAGATE_CODE,
    CEU_INPUT__PROPAGATE_POOL,

    /* emitable */
    CEU_INPUT__CLEAR,           /* 6 */
    CEU_INPUT__PAUSE,
    CEU_INPUT__RESUME,
CEU_INPUT__SEQ,
    CEU_INPUT__CODE_TERMINATED,
    CEU_INPUT__ASYNC,
    CEU_INPUT__THREAD,
    CEU_INPUT__WCLOCK,
    === CEU_EXTS_ENUM_INPUT ===

CEU_EVENT__MIN,
    === CEU_EVTS_ENUM ===
};

enum {
    CEU_OUTPUT__NONE = 0,
    === CEU_EXTS_ENUM_OUTPUT ===
};

/* CEU_ISRS_DEFINES */

=== CEU_ISRS_DEFINES ===

/* EVENTS_DEFINES */

=== CEU_EXTS_DEFINES_INPUT_OUTPUT ===

/* CEU_DATAS_HIERS */

typedef s16 tceu_ndata;  /* TODO */

=== CEU_DATAS_HIERS ===

static int ceu_data_is (tceu_ndata* supers, tceu_ndata me, tceu_ndata cmp) {
    return (me==cmp || (me!=0 && ceu_data_is(supers,supers[me],cmp)));
}

#ifdef CEU_FEATURES_TRACE
#define ceu_data_as(a,b,c,d) ceu_data_as_(a,b,c,d)
#else
#define ceu_data_as(a,b,c,d) ceu_data_as_(a,b,c)
#endif

static void* ceu_data_as_ (tceu_ndata* supers, tceu_ndata* me, tceu_ndata cmp
#ifdef CEU_FEATURES_TRACE
                         , tceu_trace trace
#endif
                         )
{
    ceu_assert_ex(ceu_data_is(supers, *me, cmp), "invalid cast `as`", trace);
    return me;
}

/* CEU_DATAS_MEMS */

#pragma pack(push,1)
=== CEU_DATAS_MEMS ===
=== CEU_DATAS_MEMS_CASTS ===
#pragma pack(pop)

#ifdef CEU_FEATURES_EXCEPTION
typedef struct tceu_opt_Exception {
    bool      is_set;
    tceu_data_Exception value;
} tceu_opt_Exception;

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_tceu_opt_Exception(a,b) CEU_OPTION_tceu_opt_Exception_(a,b)
#else
#define CEU_OPTION_tceu_opt_Exception(a,b) CEU_OPTION_tceu_opt_Exception_(a)
#endif

static tceu_opt_Exception* CEU_OPTION_tceu_opt_Exception_ (tceu_opt_Exception* opt
#ifdef CEU_FEATURES_TRACE
                                                          , tceu_trace trace
#endif
                                                          )
{
    ceu_assert_ex(opt->is_set, "value is not set", trace);
    return opt;
}
#endif

/*****************************************************************************/

=== CEU_CODES_MEMS ===
#if 0
=== CODES_ARGS ===
#endif

=== CEU_EXTS_TYPES ===
=== CEU_EVTS_TYPES ===

enum {
    CEU_LABEL_NONE = 0,
    === CEU_LABELS ===
};

typedef struct tceu_stk {
    u8               is_alive : 1;
    u8               is_base  : 1;
    struct tceu_stk* down;
    tceu_evt_range   range;
} tceu_stk;

typedef struct tceu_jmp {
    tceu_nlbl      lbl;
    tceu_code_mem* mem;
    tceu_ntrl      trl;
} tceu_jmp;

/*****************************************************************************/

typedef struct tceu_app {
    int    argc;
    char** argv;

    bool end_ok;
    int  end_val;

    tceu_jmp jmp;

    /* SEQ */
    tceu_nseq seq;
    tceu_nseq seq_base;

    /* CALLBACKS */
    tceu_callback* cbs;

    /* ASYNC */
    bool async_pending;

    /* WCLOCK */
    s32 wclk_late;
    s32 wclk_min_set;
    s32 wclk_min_cmp;

#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_T threads_mutex;
    tceu_threads_data*  threads_head;   /* linked list of threads alive */
    tceu_threads_data** cur_;           /* TODO: HACK_6 "gc" mutable iterator */
#endif

    tceu_code_mem_ROOT root;
} tceu_app;

CEU_API static tceu_app CEU_APP;

#define CEU_LONGJMP_SET(me,_lbl)                            \
        /*fprintf(stderr, "set?\n");*/                      \
    if (!(me)->is_alive) {                                  \
        /*fprintf(stderr, "set %d %d\n", __LINE__,_lbl);*/          \
        ceu_assert(CEU_APP.jmp.lbl==CEU_LABEL_NONE, "bug found"); \
        CEU_APP.jmp.lbl = _lbl;                             \
        CEU_APP.jmp.mem = _ceu_mem;                         \
        CEU_APP.jmp.trl = _ceu_trlK;                        \
        return;                                             \
    }                                                       \
case _lbl:;                                                 \
        /*fprintf(stderr, "cnt\n");*/                       \
        /* continue from here */

#define CEU_LONGJMP_JMP(me)                                 \
        /*fprintf(stderr, "jmp? %d\n", __LINE__);*/         \
    if (!(me)->is_alive) {                                  \
        /*fprintf(stderr, "dead %d\n", __LINE__);*/         \
        if (CEU_APP.jmp.lbl == CEU_LABEL_NONE) {            \
            return;                                         \
        }                                                   \
        if (!(me)->down->is_alive) {                        \
            /*fprintf(stderr, "<<<\n");*/                   \
            return;                                         \
        } else {                                            \
            tceu_nlbl __ceu_lbl = CEU_APP.jmp.lbl;          \
            /*fprintf(stderr, "jmp\n");*/                   \
            CEU_APP.jmp.lbl = CEU_LABEL_NONE;               \
            RETURN_CEU_LBL(NULL,(me)->down,CEU_APP.jmp.mem,CEU_APP.jmp.trl,__ceu_lbl); \
        }                                                   \
    } else {                                                \
        /* continue */                                      \
    }

#define CEU_LONGJMP_JMP_(me)                                \
        /*fprintf(stderr, "jmp? %d\n", __LINE__);*/         \
    if (!(me)->is_alive) {                                  \
        /*fprintf(stderr, "dead %d\n", __LINE__);*/         \
        if (CEU_APP.jmp.lbl == CEU_LABEL_NONE) {            \
            return;                                         \
        }                                                   \
        if (!(me)->down->is_alive) {                        \
            /*fprintf(stderr, "<<<\n");*/                   \
            return;                                         \
        } else {                                            \
            tceu_nlbl __ceu_lbl = CEU_APP.jmp.lbl;          \
            /*fprintf(stderr, "jmp\n");*/                   \
            CEU_APP.jmp.lbl = CEU_LABEL_NONE;               \
            return ceu_lbl(NULL,(me)->down,CEU_APP.jmp.mem,CEU_APP.jmp.trl,__ceu_lbl); \
        }                                                   \
    } else {                                                \
        /* continue */                                      \
    }

/*****************************************************************************/

static tceu_code_mem* ceu_outer (tceu_code_mem* mem, u8 n) {
    for (; mem->depth!=n; mem=mem->up_mem);
    return mem;
}

static int ceu_mem_is_child (tceu_code_mem* me, tceu_code_mem* par_mem,
                             tceu_ntrl par_trl1, tceu_ntrl par_trl2)
{
    if (me == par_mem) {
        return (par_trl1==0 && par_trl2==me->trails_n-1) ? 1 : 0;
    }

    tceu_code_mem* cur_mem;
    for (cur_mem=me; cur_mem!=NULL; cur_mem=cur_mem->up_mem) {
        if (cur_mem->up_mem == par_mem) {
            if (cur_mem->up_trl>=par_trl1 && cur_mem->up_trl<=par_trl2) {
                return 2;
            }
        }
    }
    return 0;
}

static void ceu_stack_clear (tceu_stk* stk, tceu_code_mem* mem,
                             tceu_ntrl trl0, tceu_ntrl trlF) {
    for (; stk!=NULL; stk=stk->down) {
        if (!stk->is_alive || stk->is_base) {
            continue;
        }
        if (stk->range.mem != mem) {
            /* check if "stk->range.mem" is child of "mem" in between "[trl0,trlF]" */
            if (ceu_mem_is_child(stk->range.mem, mem, trl0, trlF)) {
                stk->is_alive = 0;
            }
        } else if (trl0<=stk->range.trl0 && stk->range.trlF<=trlF) {  /* [trl0,trlF] */
            stk->is_alive = 0;
        }
    }
}

#if 0
static void ceu_stack_dump (tceu_stk* stk) {
    for (; stk!=&CEU_STK_BASE; stk=stk->down) {
        printf("stk=%p mem=%p\n", stk, stk->mem);
    }
}
#endif

/*****************************************************************************/

#define CEU_WCLOCK_INACTIVE INT32_MAX

#ifdef CEU_FEATURES_TRACE
#define ceu_wclock(a,b,c,d) ceu_wclock_(a,b,c,d)
#else
#define ceu_wclock(a,b,c,d) ceu_wclock_(a,b,c)
#endif

static int ceu_wclock_ (s32 dt, s32* set, s32* sub
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
                      )
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "sub") */

    /* SET */
    if (set != NULL) {
        t = dt - CEU_APP.wclk_late;
        *set = t;

    /* SUB */
    } else {
        t = *sub;
        if ((t > CEU_APP.wclk_min_cmp) || (t > dt)) {
            *sub -= dt;    /* don't expire yet */
            t = *sub;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (CEU_APP.wclk_min_set > t) ) {
        CEU_APP.wclk_min_set = t;
        ceu_callback_num_ptr(CEU_CALLBACK_WCLOCK_MIN, t, NULL, trace);
    }

    return ret;
}

/*****************************************************************************/

#ifdef CEU_FEATURES_POOL
void ceu_code_mem_dyn_free (tceu_pool* pool, tceu_code_mem_dyn* cur) {
    cur->nxt->prv = cur->prv;
    cur->prv->nxt = cur->nxt;

#ifdef CEU_FEATURES_DYNAMIC
    if (pool->queue == NULL) {
        /* dynamic pool */
        ceu_callback_ptr_num(CEU_CALLBACK_REALLOC, cur, 0, CEU_TRACE_null);
    } else
#endif
    {
        /* static pool */
        ceu_pool_free(pool, (byte*)cur);
    }
}

void ceu_code_mem_dyn_remove (tceu_pool* pool, tceu_code_mem_dyn* cur) {
    cur->is_alive = 0;

    if (cur->mem[0].pak->n_traversing == 0) {
        ceu_code_mem_dyn_free(pool, cur);
    }
}

void ceu_code_mem_dyn_gc (tceu_pool_pak* pak) {
    if (pak->n_traversing == 0) {
        /* TODO-OPT: one element killing another is unlikely:
                     set bit in pool when this happens and only
                     traverses in this case */
        tceu_code_mem_dyn* cur = pak->first.nxt;
        while (cur != &pak->first) {
            tceu_code_mem_dyn* nxt = cur->nxt;
            if (!cur->is_alive) {
                ceu_code_mem_dyn_free(&pak->pool, cur);
            }
            cur = nxt;
        }
    }
}
#endif

/*****************************************************************************/

#ifdef CEU_FEATURES_LUA
static void ceu_lua_createargtable (lua_State* lua, char** argv, int argc, int script) {
    int i, narg;
    if (script == argc) script = 0;  /* no script name? */
    narg = argc - (script + 1);  /* number of positive indices */
    lua_createtable(lua, narg, script + 1);
    for (i = 0; i < argc; i++) {
        lua_pushstring(lua, argv[i]);
        lua_rawseti(lua, -2, i - script);
    }
    lua_setglobal(lua, "arg");
}

#endif

/*****************************************************************************/

CEU_API void ceu_callback_register (tceu_callback* cb) {
    cb->nxt = CEU_APP.cbs;
    CEU_APP.cbs = cb;
}

static void ceu_callback (int cmd, tceu_callback_val p1, tceu_callback_val p2
#ifdef CEU_FEATURES_TRACE
                         , tceu_trace trace
#else
#endif
                         )
{
    tceu_callback* cur = CEU_APP.cbs;
    while (cur) {
        int is_handled = cur->f(cmd,p1,p2
#ifdef CEU_FEATURES_TRACE
              ,trace
#endif
              );
        if (is_handled) {
            return;
        }
        cur = cur->nxt;
    }

#define CEU_TRACE(n) trace
    if (cmd == CEU_CALLBACK_OUTPUT) {
        switch (p1.num) {
            === CEU_CALLBACKS_OUTPUTS ===
        }
    }
#undef CEU_TRACE
}

/*****************************************************************************/

static void ceu_bcast (tceu_evt_occ* occ, tceu_stk* stk, bool is_prim);
static void ceu_lbl (tceu_evt_occ* _ceu_occ, tceu_stk* _ceu_stk,
                     tceu_code_mem* _ceu_mem, tceu_ntrl _ceu_trlK, tceu_nlbl _ceu_lbl);

=== CEU_NATIVE_POS ===

=== CEU_CODES_WRAPPERS ===

=== CEU_ISRS ===

=== CEU_THREADS ===

/*****************************************************************************/

#ifdef CEU_FEATURES_EXCEPTION
void ceu_throw_ex (tceu_catch* catches, tceu_data_Exception* exception, usize len, tceu_stk* stk
#ifdef CEU_FEATURES_TRACE
                  , tceu_trace trace
#endif
                  )
{
    tceu_catch* cur = catches;
    while (cur != NULL) {
        if (ceu_data_is(CEU_DATA_SUPERS_Exception,exception->_enum,cur->exception->value._enum)) {
            //ceu_sys_assert(!cur->exception->is_set, "double catch");
            ceu_assert_ex(!cur->exception->is_set, "double catch", trace);
            cur->exception->is_set = 1;
            memcpy(&cur->exception->value, exception, len);

#if 0
            /* do not allow nested catches (and itself) to awake */
            cur->exception = NULL;
            while (catches != cur) {
                catches->exception = NULL;
                catches = catches->up;
            }
#endif

            return ceu_lbl(NULL, stk, cur->mem, cur->trl, cur->mem->_trails[cur->trl].lbl);
        }
        cur = cur->up;
    }
    ceu_assert_ex(0, exception->message, trace);
}
#ifdef CEU_FEATURES_TRACE
#define ceu_throw(a,b,c) ceu_throw_ex(a,b,c,_ceu_stk,CEU_TRACE(0))
#else
#define ceu_throw(a,b,c) ceu_throw_ex(a,b,c,_ceu_stk)
#endif
#endif

#ifdef CEU_FEATURES_THREAD
int ceu_threads_gc (int force_join) {
    int n_alive = 0;
    CEU_APP.cur_ = &CEU_APP.threads_head;
    tceu_threads_data*  head  = *CEU_APP.cur_;
    while (head != NULL) {
        tceu_threads_data** nxt_ = &head->nxt;
        if (head->has_terminated || head->has_aborted)
        {
            if (!head->has_notified) {
                ceu_input(CEU_INPUT__THREAD, &head->id);
                head->has_notified = 1;
            }

            /* remove from list if rejoined */
            {
                int has_joined;
                if (force_join || head->has_terminated) {
                    CEU_THREADS_JOIN(head->id);
                    has_joined = 1;
                } else {
                    /* possible with "CANCEL" which prevents setting "has_terminated" */
                    has_joined = CEU_THREADS_JOIN_TRY(head->id);
                }
                if (has_joined) {
                    *CEU_APP.cur_ = head->nxt;
                    nxt_ = CEU_APP.cur_;
                    ceu_callback_ptr_num(CEU_CALLBACK_REALLOC, head, 0, CEU_TRACE_null);
                }
            }
        }
        else
        {
            n_alive++;
        }
        CEU_APP.cur_ = nxt_;
        head  = *CEU_APP.cur_;
    }
    return n_alive;
}
#endif

/*****************************************************************************/

void ceu_input_one (tceu_nevt evt_id, void* evt_params, tceu_stk* stk);

#define RETURN_CEU_LBL(_1,_2,_3,_4,_5)  \
    _ceu_occ  = _1;                     \
    _ceu_stk  = _2;                     \
    _ceu_mem  = _3;                     \
    _ceu_trlK = _4;                     \
    _ceu_lbl  = _5;                     \
    goto _CEU_LBL_;

static void ceu_lbl (tceu_evt_occ* _ceu_occ, tceu_stk* _ceu_stk,
                     tceu_code_mem* _ceu_mem, tceu_ntrl _ceu_trlK, tceu_nlbl _ceu_lbl)
{
#define CEU_TRACE(n) ((tceu_trace){&_ceu_mem->trace,__FILE__,__LINE__+(n)})
#ifdef CEU_STACK_MAX
    {
        static void* base = NULL;
        if (base == NULL) {
            base = &_ceu_occ;
        } else {
#if 0
#if 0
//Serial.begin(9600);
Serial.println((usize)base);
Serial.println((usize)&_ceu_lbl);
Serial.print(" lbl "); Serial.println(_ceu_lbl);
//Serial.flush();
    if((usize)(((byte*)base)-CEU_STACK_MAX) <= (usize)(&_ceu_occ)) {
    } else {
        delay(1000);
    }
#else
printf(">>> %p / %p / %ld\n", base, &_ceu_lbl, ((u64)base)-((u64)&_ceu_lbl));
printf("%ld %ld %d\n", (usize)(base-CEU_STACK_MAX), (usize)(&_ceu_occ),
            ((usize)(base-CEU_STACK_MAX) <= (usize)(&_ceu_occ)));
#endif
#endif
            ceu_assert((usize)(((byte*)base)-CEU_STACK_MAX) <= (usize)(&_ceu_occ), "stack overflow");
        }
    }
#endif

_CEU_LBL_:
#if 0
    printf("-=-=- %d -=-=-\n", _ceu_lbl);
#endif
    switch (_ceu_lbl) {
        CEU_LABEL_NONE:
            break;
        === CEU_CODES ===
    }
#undef CEU_TRACE
}

#if defined(_CEU_DEBUG)
#define _CEU_DEBUG
static int xxx = 0;
#endif

static void ceu_bcast (tceu_evt_occ* occ, tceu_stk* stk, bool is_prim)
{
    tceu_ntrl trlK;
    tceu_trl* trl;
    tceu_evt_range range = occ->range;

    if (is_prim && occ->evt.id>CEU_INPUT__SEQ) {
        ceu_assert_ex(((tceu_nseq)(CEU_APP.seq+1)) != CEU_APP.seq_base,
                      "too many internal reactions", CEU_TRACE_null);
        CEU_APP.seq++;
    }

    tceu_stk _stk = { 1, 0, stk, range }; /* maybe nested bcast aborts it */

    /* MARK TRAILS TO EXECUTE */

#ifdef _CEU_DEBUG
for (int i=0; i<xxx; i++) {
    fprintf(stderr, " ");
}
fprintf(stderr, ">>> %d/%p, SEQ=%d [%p] %d->%d\n", occ->evt.id, occ->evt.mem, occ->seq,
                                           range.mem, range.trl0, range.trlF);
xxx += 4;
#endif

    /* CLEAR: inverse execution order */
    tceu_ntrl trl0 = range.trl0;
    tceu_ntrl trlF = range.trlF;
    if (occ->evt.id == CEU_INPUT__CLEAR) {
        tceu_ntrl tmp = trl0;
        trl0 = trlF;
        trlF = tmp;
    }

#ifdef CEU_TESTS
    _ceu_tests_bcasts_++;
#endif

    for (trlK=trl0, trl=&range.mem->_trails[trlK]; ;)
    {
#ifdef CEU_TESTS
        _ceu_tests_trails_visited_++;
#endif

#ifdef _CEU_DEBUG
for (int i=0; i<xxx; i++) {
    fprintf(stderr, " ");
}
fprintf(stderr, "??? trlK=%d, evt=%d, seq=%d\n", trlK, trl->evt.id, trl->seq);
#endif

        /* special trails: propagate, skip paused */

        switch (trl->evt.id)
        {
            /* propagate "occ" to nested "code/pool" */
            case CEU_INPUT__PROPAGATE_CODE: {
#if 0
                // TODO: simple optimization that could be done
                //          - do it also for POOL?
                if (occ->evt.id==CEU_INPUT__CODE_TERMINATED && occ->params==trl->evt.mem ) {
                    // dont propagate when I am terminating
                } else
#endif
                {
                    tceu_evt_range _range = {
                        (tceu_code_mem*)trl->evt.mem,
                        0,
                        (tceu_ntrl)(((tceu_code_mem*)trl->evt.mem)->trails_n-1)
                    };
                    occ->range = _range;
                    ceu_bcast(occ, &_stk, 0);
                    CEU_LONGJMP_JMP_((&_stk));
                }
                break;
            }
#ifdef CEU_FEATURES_POOL
            case CEU_INPUT__PROPAGATE_POOL: {
                ceu_assert_ex(trl->evt.pak->n_traversing < 255, "bug found", CEU_TRACE_null);
                trl->evt.pak->n_traversing++;
                tceu_code_mem_dyn* cur = trl->evt.pak->first.nxt;
#if 0
printf(">>> BCAST[%p]:\n", trl->pool_first);
printf(">>> BCAST[%p]: %p / %p\n", trl->pool_first, cur, &cur->mem[0]);
#endif
                while (cur != &trl->evt.pak->first) {
                    if (cur->is_alive) {
                        tceu_evt_range _range = { &cur->mem[0],
                                                  0, (tceu_ntrl)((&cur->mem[0])->trails_n-1) };
                        occ->range = _range;
                        tceu_stk _stk = { 1, 0, stk,
                                          {cur->mem[0].up_mem,cur->mem[0].up_trl,cur->mem[0].up_trl} };
                        ceu_bcast(occ, &_stk, 0);
                        CEU_LONGJMP_JMP_((&_stk));
                    }
                    cur = cur->nxt;
                }
                trl->evt.pak->n_traversing--;
                ceu_code_mem_dyn_gc(trl->evt.pak);
                break;
            }
#endif

            /* skip "paused" blocks || set "paused" block */
            case CEU_INPUT__PAUSE_BLOCK: {
                u8 was_paused = trl->pse_paused;
                if (occ->evt.id==trl->pse_evt.id &&
                    (occ->evt.id<CEU_EVENT__MIN || occ->evt.mem==trl->pse_evt.mem))
                {
                    if (*((u8*)occ->params) != trl->pse_paused) {
                        trl->pse_paused = *((u8*)occ->params);

                        if (trl->pse_paused) {
                            tceu_evt_occ occ2 = { {CEU_INPUT__PAUSE,{NULL}}, CEU_APP.seq, occ->params,
                                                  {range.mem,
                                                   (tceu_ntrl)(trlK+1), (tceu_ntrl)(trlK+trl->pse_skip)}
                                                };
                            ceu_bcast(&occ2, &_stk, 0);
                        } else {
                            CEU_APP.wclk_min_set = 0;   /* maybe resuming a timer, let it be the minimum set */
                            tceu_evt_occ occ2 = { {CEU_INPUT__RESUME,{NULL}}, CEU_APP.seq, occ->params,
                                                  {range.mem,
                                                   (tceu_ntrl)(trlK+1), (tceu_ntrl)(trlK+trl->pse_skip)}
                                                };
                            ceu_bcast(&occ2, &_stk, 0);
                        }
                        ceu_assert_ex(_stk.is_alive, "bug found", CEU_TRACE_null);
                    }
                }
                /* don't skip if pausing now */
                if (was_paused && occ->evt.id!=CEU_INPUT__CLEAR) {
                                  /* also don't skip on CLEAR (going reverse) */
                    trlK += trl->pse_skip;
                    trl  += trl->pse_skip;
                    goto _CEU_AWAKE_NO_;
                }
                break;
            }
        }

        /* normal trails: check if awakes */

        if (occ->evt.id == CEU_INPUT__CLEAR) {
            tceu_nevt trl_evt_id = trl->evt.id;
            trl->evt.id = CEU_INPUT__NONE;
            if (trl_evt_id == CEU_INPUT__FINALIZE) {
                /* FINALIZE awakes now on "mark" */
                ceu_lbl(occ, &_stk, range.mem, trlK, trl->lbl);
            }
        } else if (occ->evt.id==CEU_INPUT__CODE_TERMINATED && trl->evt.id==CEU_INPUT__PROPAGATE_CODE) {
            if (trl->evt.mem == occ->evt.mem) {
                goto _CEU_AWAKE_YES_;
            }
        } else if (trl->evt.id == occ->evt.id) {
            if (occ->evt.id==CEU_INPUT__PAUSE || occ->evt.id==CEU_INPUT__RESUME) {
                goto _CEU_AWAKE_YES_;
            }
            if (((tceu_nseq)(trl->seq-CEU_APP.seq_base)) >
                ((tceu_nseq)(occ->seq-CEU_APP.seq_base))) {
                goto _CEU_AWAKE_NO_;
            }
            if (trl->evt.id>CEU_EVENT__MIN || trl->evt.id==CEU_INPUT__CODE_TERMINATED) {
                if (trl->evt.mem == occ->evt.mem) {
                    goto _CEU_AWAKE_YES_;   /* internal event matches "mem" */
                }
            } else {
                if (occ->evt.id != CEU_INPUT__NONE) {
                    goto _CEU_AWAKE_YES_;       /* external event matches */
                }
            }
        }

        goto _CEU_AWAKE_NO_;

_CEU_AWAKE_YES_:
#ifdef _CEU_DEBUG
for (int i=0; i<xxx+4; i++) {
    fprintf(stderr, " ");
}
fprintf(stderr, "+++ %d\n", trl->lbl);
#endif

        trl->evt.id = CEU_INPUT__NONE;
        ceu_lbl(occ, &_stk, range.mem, trlK, trl->lbl);
        CEU_LONGJMP_JMP_((&_stk));

_CEU_AWAKE_NO_:
        if ((trl->evt.id > CEU_INPUT__SEQ) && (occ->seq == ((tceu_nseq)(CEU_APP.seq_base+0)))) {
            trl->seq = CEU_APP.seq_base;
        }

        if (trlK == trlF) {
            break;
        } else if (occ->evt.id == CEU_INPUT__CLEAR) {
            trlK--; trl--;
        } else {
            trlK++; trl++;
        }
    }
_CEU_BREAK_:;

    /*occ->range = range;*/

#ifdef _CEU_DEBUG
xxx -= 4;
for (int i=0; i<xxx; i++) {
    fprintf(stderr, " ");
}
fprintf(stderr, "<<< %d [%p] %d->%d\n", occ->evt.id, range.mem, range.trl0, range.trlF);
#endif
}

void ceu_input_one (tceu_nevt evt_id, void* evt_params, tceu_stk* stk)
{
    CEU_APP.seq_base = CEU_APP.seq;

    switch (evt_id) {
        case CEU_INPUT__WCLOCK:
            CEU_APP.wclk_min_cmp = CEU_APP.wclk_min_set;    /* swap "cmp" to last "set" */
            CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;     /* new "set" resets to inactive */
            ceu_callback_num_ptr(CEU_CALLBACK_WCLOCK_MIN, CEU_WCLOCK_INACTIVE, NULL, CEU_TRACE_null);
            if (CEU_APP.wclk_min_cmp <= *((s32*)evt_params)) {
                CEU_APP.wclk_late = *((s32*)evt_params) - CEU_APP.wclk_min_cmp;
            }
            break;
        case CEU_INPUT__ASYNC:
            CEU_APP.async_pending = 0;
            break;
    }
    if (evt_id != CEU_INPUT__WCLOCK) {
        CEU_APP.wclk_late = 0;
    }

/* TODO: remove this extra bcast to reset seqs */
#if 1
{
    tceu_stk _stk = { 1, 1, stk,
                     { (tceu_code_mem*)&CEU_APP.root,
                       0, (tceu_ntrl)(CEU_APP.root._mem.trails_n-1) } };
    tceu_evt_occ occ = { {CEU_INPUT__NONE,{NULL}}, CEU_APP.seq, evt_params,
                         {(tceu_code_mem*)&CEU_APP.root,
                          0, (tceu_ntrl)(CEU_APP.root._mem.trails_n-1)}
                       };
    ceu_bcast(&occ, &_stk, 1);
}
#endif

    tceu_stk _stk = { 1, 1, stk,
                     { (tceu_code_mem*)&CEU_APP.root,
                       0, (tceu_ntrl)(CEU_APP.root._mem.trails_n-1) } };
    tceu_evt_occ occ = { {evt_id,{NULL}}, (tceu_nseq)(CEU_APP.seq+1), evt_params,
                         {(tceu_code_mem*)&CEU_APP.root,
                          0, (tceu_ntrl)(CEU_APP.root._mem.trails_n-1)}
                       };
    ceu_bcast(&occ, &_stk, 1);
}

CEU_API void ceu_input (tceu_nevt evt_id, void* evt_params)
{
    ceu_callback_void_void(CEU_CALLBACK_WCLOCK_DT, CEU_TRACE_null);
    s32 dt = ceu_callback_ret.num;
    if (dt != CEU_WCLOCK_INACTIVE) {
        ceu_input_one(CEU_INPUT__WCLOCK, &dt, NULL);
    }
    if (evt_id != CEU_INPUT__NONE) {
        ceu_input_one(evt_id, evt_params, NULL);
    }
}

CEU_API void ceu_start (tceu_callback* cb, int argc, char* argv[]) {
    CEU_APP.argc     = argc;
    CEU_APP.argv     = argv;

    CEU_APP.end_ok   = 0;

    CEU_APP.jmp.lbl = CEU_LABEL_NONE;

    CEU_APP.seq      = 0;
    CEU_APP.seq_base = 0;

    CEU_APP.cbs = cb;

    CEU_APP.async_pending = 0;

    CEU_APP.wclk_late = 0;
    CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;
    CEU_APP.wclk_min_cmp = CEU_WCLOCK_INACTIVE;

#ifdef CEU_FEATURES_THREAD
    pthread_mutex_init(&CEU_APP.threads_mutex, NULL);
    CEU_APP.threads_head = NULL;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
#endif

    ceu_callback_void_void(CEU_CALLBACK_START, CEU_TRACE_null);

    tceu_stk stk = { 1, 1, NULL,
                     { (tceu_code_mem*)&CEU_APP.root,
                       0, (tceu_ntrl)(CEU_APP.root._mem.trails_n-1) } };
    ceu_lbl(NULL, &stk, (tceu_code_mem*)&CEU_APP.root, 0, CEU_LABEL_ROOT);
}

CEU_API void ceu_stop (void) {
#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
    ceu_assert_ex(ceu_threads_gc(1) == 0, "bug found", CEU_TRACE_null); /* wait all terminate/free */
#endif
    ceu_callback_void_void(CEU_CALLBACK_STOP, CEU_TRACE_null);
}

/*****************************************************************************/

CEU_API int ceu_loop (tceu_callback* cb, int argc, char* argv[])
{
    ceu_start(cb, argc, argv);

    while (!CEU_APP.end_ok) {
        ceu_callback_void_void(CEU_CALLBACK_STEP, CEU_TRACE_null);
#ifdef CEU_FEATURES_THREAD
        if (CEU_APP.threads_head != NULL) {
            CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
/* TODO: remove this!!! */
            CEU_THREADS_SLEEP(100); /* allow threads to do "atomic" and "terminate" */
            CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
            ceu_threads_gc(0);
        }
#endif
        ceu_input(CEU_INPUT__ASYNC, NULL);
    }

    ceu_stop();

#ifdef CEU_TESTS
    printf("_ceu_tests_bcasts_ = %d\n", _ceu_tests_bcasts_);
    printf("_ceu_tests_trails_visited_ = %d\n", _ceu_tests_trails_visited_);
#endif

    return CEU_APP.end_val;
}
]====],
    }
}
optparse = 
(function()
--[[--
 Parse and process command line options.

 In the common case, you can write the long-form help output typical of
 a modern-command line program, and let this module generate a custom
 parser that collects and diagnoses the options it describes.

 The parser is an object instance which can then be tweaked for
 the uncommon case, by hand, or by using the @{on} method to tie your
 custom handlers to options that are not handled quite the way you'd
 like.

 @module optparse
]]


local _ENV		= _ENV
local assert		= assert
local error		= error
local getmetatable	= getmetatable
local ipairs		= ipairs
local pairs		= pairs
local print		= print
local require		= require
local setmetatable	= setmetatable
local tostring		= tostring
local type		= type

local io_open		= io.open
local io_stderr		= io.stderr
local os_exit		= os.exit
local string_len	= string.len
local table_insert	= table.insert



--[[ ================== ]]--
--[[ Initialize _DEBUG. ]]--
--[[ ================== ]]--


local _DEBUG		= _DEBUG
do
  -- Make sure none of these symbols leak out into the rest of the
  -- module, in case we can enable 'strict' mode at the end of the block.

  local ok, debug_init	= pcall (require, "std.debug_init")
  if ok then
    _DEBUG		= debug_init._DEBUG
  else
    local function choose (t)
      for k, v in pairs (t) do
        if _DEBUG == false then
          t[k] = v.fast
	elseif _DEBUG == nil then
          t[k] = v.default
        elseif type (_DEBUG) ~= "table" then
          t[k] = v.safe
        elseif _DEBUG[k] ~= nil then
          t[k] = _DEBUG[k]
        else
          t[k] = v.default
        end
      end
      return t
    end

    _DEBUG = choose {
      strict    = {default = true,  safe = true,  fast = false},
    }
  end

  -- Unless strict was disabled (`_DEBUG = false`), or that module is not
  -- available, check for use of undeclared variables in this module.
  if _DEBUG.strict then
    local ok, strict	= pcall (require, "std.strict")
    if ok then
      _ENV = strict {}
    else
      _DEBUG.strict = false
    end
  end
end



--[[ ================= ]]--
--[[ Helper Functions. ]]--
--[[ ================= ]]--


local function getmetamethod (x, n)
  local m = (getmetatable (x) or {})[n]
  if type (m) == "function" then return m end
  return (getmetatable (m) or {}).__call
end


local function len (x)
  local m = getmetamethod (x, "__len")
  if m then return m (x) end
  if type (x) ~= "table" then return #x end

  local n = #x
  for i = 1, n do
    if x[i] == nil then return i -1 end
  end
  return n
end


local function last (t)
  return t[len (t)]
end


local optional, required


--- Normalise an argument list.
-- Separate short options, remove `=` separators from
-- `--long-option=optarg` etc.
-- @local
-- @function normalise
-- @tparam table arglist list of arguments to normalise
-- @treturn table normalised argument list
local function normalise (self, arglist)
  local normal = {}
  local i = 0
  while i < len (arglist) do
    i = i + 1
    local opt = arglist[i]

    -- Split '--long-option=option-argument'.
    if opt:sub (1, 2) == "--" then
      local x = opt:find ("=", 3, true)
      if x then
        local optname = opt:sub (1, x -1)

	-- Only split recognised long options.
	if self[optname] then
          table_insert (normal, optname)
          table_insert (normal, opt:sub (x + 1))
	else
	  x = nil
	end
      end

      if x == nil then
	-- No '=', or substring before '=' is not a known option name.
        table_insert (normal, opt)
      end

    elseif opt:sub (1, 1) == "-" and string_len (opt) > 2 then
      local orig, split, rest = opt, {}
      repeat
        opt, rest = opt:sub (1, 2), opt:sub (3)

        split[#split + 1] = opt

	-- If there's no handler, the option was a typo, or not supposed
	-- to be an option at all.
	if self[opt] == nil then
	  opt, split = nil, { orig }

        -- Split '-xyz' into '-x -yz', and reiterate for '-yz'
        elseif self[opt].handler ~= optional and
          self[opt].handler ~= required then
	  if string_len (rest) > 0 then
            opt = "-" .. rest
	  else
	    opt = nil
	  end

        -- Split '-xshortargument' into '-x shortargument'.
        else
          split[#split + 1] = rest
          opt = nil
        end
      until opt == nil

      -- Append split options to normalised list
      for _, v in ipairs (split) do table_insert (normal, v) end
    else
      table_insert (normal, opt)
    end
  end

  normal[-1], normal[0]  = arglist[-1], arglist[0]
  return normal
end


--- Store `value` with `opt`.
-- @local
-- @function set
-- @string opt option name
-- @param value option argument value
local function set (self, opt, value)
  local key = self[opt].key
  local opts = self.opts[key]

  if type (opts) == "table" then
    table_insert (opts, value)
  elseif opts ~= nil then
    self.opts[key] = { opts, value }
  else
    self.opts[key] = value
  end
end



--[[ ============= ]]--
--[[ Option Types. ]]--
--[[ ============= ]]--


--- Option at `arglist[i]` can take an argument.
-- Argument is accepted only if there is a following entry that does not
-- begin with a '-'.
--
-- This is the handler automatically assigned to options that have
-- `--opt=[ARG]` style specifications in the @{OptionParser} spec
-- argument.  You can also pass it as the `handler` argument to @{on} for
-- options you want to add manually without putting them in the
-- @{OptionParser} spec.
--
-- Like @{required}, this handler will store multiple occurrences of a
-- command-line option.
-- @static
-- @tparam table arglist list of arguments
-- @int i index of last processed element of *arglist*
-- @param[opt=true] value either a function to process the option
--   argument, or a default value if encountered without an optarg
-- @treturn int index of next element of *arglist* to process
-- @usage
-- parser:on ("--enable-nls", parser.option, parser.boolean)
function optional (self, arglist, i, value)
  if i + 1 <= len (arglist) and arglist[i + 1]:sub (1, 1) ~= "-" then
    return self:required (arglist, i, value)
  end

  if type (value) == "function" then
    value = value (self, arglist[i], nil)
  elseif value == nil then
    value = true
  end

  set (self, arglist[i], value)
  return i + 1
end


--- Option at `arglist[i]` requires an argument.
--
-- This is the handler automatically assigned to options that have
-- `--opt=ARG` style specifications in the @{OptionParser} spec argument.
-- You can also pass it as the `handler` argument to @{on} for options
-- you want to add manually without putting them in the @{OptionParser}
-- spec.
--
-- Normally the value stored in the `opt` table by this handler will be
-- the string given as the argument to that option on the command line.
-- However, if the option is given on the command-line multiple times,
-- `opt["name"]` will end up with all those arguments stored in the
-- array part of a table:
--
--     $ cat ./prog
--     ...
--     parser:on ({"-e", "-exec"}, required)
--     _G.arg, _G.opt = parser:parse (_G.arg)
--     print (tostring (_G.opt.exec))
--     ...
--     $ ./prog -e '(foo bar)' -e '(foo baz)' -- qux
--     {1=(foo bar),2=(foo baz)}
-- @static
-- @tparam table arglist list of arguments
-- @int i index of last processed element of *arglist*
-- @param[opt] value either a function to process the option argument,
--   or a forced value to replace the user's option argument.
-- @treturn int index of next element of *arglist* to process
-- @usage
-- parser:on ({"-o", "--output"}, parser.required)
function required (self, arglist, i, value)
  local opt = arglist[i]
  if i + 1 > len (arglist) then
    self:opterr ("option '" .. opt .. "' requires an argument")
    return i + 1
  end

  if type (value) == "function" then
    value = value (self, opt, arglist[i + 1])
  elseif value == nil then
    value = arglist[i + 1]
  end

  set (self, opt, value)
  return i + 2
end


--- Finish option processing
--
-- This is the handler automatically assigned to the option written as
-- `--` in the @{OptionParser} spec argument.  You can also pass it as
-- the `handler` argument to @{on} if you want to manually add an end
-- of options marker without writing it in the @{OptionParser} spec.
--
-- This handler tells the parser to stop processing arguments, so that
-- anything after it will be an argument even if it otherwise looks
-- like an option.
-- @static
-- @tparam table arglist list of arguments
-- @int i index of last processed element of `arglist`
-- @treturn int index of next element of `arglist` to process
-- @usage
-- parser:on ("--", parser.finished)
local function finished (self, arglist, i)
  for opt = i + 1, len (arglist) do
    table_insert (self.unrecognised, arglist[opt])
  end
  return 1 + len (arglist)
end


--- Option at `arglist[i]` is a boolean switch.
--
-- This is the handler automatically assigned to options that have
-- `--long-opt` or `-x` style specifications in the @{OptionParser} spec
-- argument. You can also pass it as the `handler` argument to @{on} for
-- options you want to add manually without putting them in the
-- @{OptionParser} spec.
--
-- Beware that, _unlike_ @{required}, this handler will store multiple
-- occurrences of a command-line option as a table **only** when given a
-- `value` function.  Automatically assigned handlers do not do this, so
-- the option will simply be `true` if the option was given one or more
-- times on the command-line.
-- @static
-- @tparam table arglist list of arguments
-- @int i index of last processed element of *arglist*
-- @param[opt] value either a function to process the option argument,
--   or a value to store when this flag is encountered
-- @treturn int index of next element of *arglist* to process
-- @usage
-- parser:on ({"--long-opt", "-x"}, parser.flag)
local function flag (self, arglist, i, value)
  local opt = arglist[i]
  if type (value) == "function" then
    set (self, opt, value (self, opt, true))
  elseif value == nil then
    local key = self[opt].key
    self.opts[key] = true
  end

  return i + 1
end


--- Option should display help text, then exit.
--
-- This is the handler automatically assigned tooptions that have
-- `--help` in the specification, e.g. `-h, -?, --help`.
-- @static
-- @function help
-- @usage
-- parser:on ("-?", parser.version)
local function help (self)
  print (self.helptext)
  os_exit (0)
end


--- Option should display version text, then exit.
--
-- This is the handler automatically assigned tooptions that have
-- `--version` in the specification, e.g. `-V, --version`.
-- @static
-- @function version
-- @usage
-- parser:on ("-V", parser.version)
local function version (self)
  print (self.versiontext)
  os_exit (0)
end



--[[ =============== ]]--
--[[ Argument Types. ]]--
--[[ =============== ]]--


--- Map various option strings to equivalent Lua boolean values.
-- @table boolvals
-- @field false false
-- @field 0 false
-- @field no false
-- @field n false
-- @field true true
-- @field 1 true
-- @field yes true
-- @field y true
local boolvals = {
  ["false"] = false, ["true"]  = true,
  ["0"]     = false, ["1"]     = true,
  no        = false, yes       = true,
  n         = false, y         = true,
}


--- Return a Lua boolean equivalent of various *optarg* strings.
-- Report an option parse error if *optarg* is not recognised.
--
-- Pass this as the `value` function to @{on} when you want various
-- "truthy" or "falsey" option arguments to be coerced to a Lua `true`
-- or `false` respectively in the options table.
-- @static
-- @string opt option name
-- @string[opt="1"] optarg option argument, must be a key in @{boolvals}
-- @treturn bool `true` or `false`
-- @usage
-- parser:on ("--enable-nls", parser.optional, parser.boolean)
local function boolean (self, opt, optarg)
  if optarg == nil then optarg = "1" end -- default to truthy
  local b = boolvals[tostring (optarg):lower ()]
  if b == nil then
    return self:opterr (optarg .. ": Not a valid argument to " ..opt[1] .. ".")
  end
  return b
end


--- Report an option parse error unless *optarg* names an
-- existing file.
--
-- Pass this as the `value` function to @{on} when you want to accept
-- only option arguments that name an existing file.
-- @fixme this only checks whether the file has read permissions
-- @static
-- @string opt option name
-- @string optarg option argument, must be an existing file
-- @treturn string *optarg*
-- @usage
-- parser:on ("--config-file", parser.required, parser.file)
local function file (self, opt, optarg)
  local h, errmsg = io_open (optarg, "r")
  if h == nil then
    return self:opterr (optarg .. ": " .. errmsg)
  end
  h:close ()
  return optarg
end



--[[ =============== ]]--
--[[ Option Parsing. ]]--
--[[ =============== ]]--


--- Report an option parse error, then exit with status 2.
--
-- Use this in your custom option handlers for consistency with the
-- error output from built-in @{optparse} error messages.
-- @static
-- @string msg error message
local function opterr (self, msg)
  local prog = self.program
  -- Ensure final period.
  if msg:match ("%.$") == nil then msg = msg .. "." end
  io_stderr:write (prog .. ": error: " .. msg .. "\n")
  io_stderr:write (prog .. ": Try '" .. prog .. " --help' for help.\n")
  os_exit (2)
end


------
-- Function signature of an option handler for @{on}.
-- @function on_handler
-- @tparam table arglist list of arguments
-- @int i index of last processed element of *arglist*
-- @param[opt=nil] value additional `value` registered with @{on}
-- @treturn int index of next element of *arglist* to process


--- Add an option handler.
--
-- When the automatically assigned option handlers don't do everything
-- you require, or when you don't want to put an option into the
-- @{OptionParser} `spec` argument, use this function to specify custom
-- behaviour.  If you write the option into the `spec` argument anyway,
-- calling this function will replace the automatically assigned handler
-- with your own.
--
-- When writing your own handlers for @{optparse:on}, you only need
-- to deal with normalised arguments, because combined short arguments
-- (`-xyz`), equals separators to long options (`--long=ARG`) are fully
-- expanded before any handler is called.
-- @function on
-- @tparam[string|table] opts name of the option, or list of option names
-- @tparam on_handler handler function to call when any of *opts* is
--   encountered
-- @param value additional value passed to @{on_handler}
-- @usage
-- -- Don't process any arguments after `--`
-- parser:on ('--', parser.finished)
local function on (self, opts, handler, value)
  if type (opts) == "string" then opts = { opts } end
  handler = handler or flag -- unspecified options behave as flags

  local normal = {}
  for _, optspec in ipairs (opts) do
    optspec:gsub ("(%S+)",
                  function (opt)
                    -- 'x' => '-x'
                    if string_len (opt) == 1 then
                      opt = "-" .. opt

                    -- 'option-name' => '--option-name'
                    elseif opt:match ("^[^%-]") ~= nil then
                      opt = "--" .. opt
                    end

                    if opt:match ("^%-[^%-]+") ~= nil then
                      -- '-xyz' => '-x -y -z'
                      for i = 2, string_len (opt) do
                        table_insert (normal, "-" .. opt:sub (i, i))
                      end
                    else
                      table_insert (normal, opt)
                    end
                  end)
  end

  -- strip leading '-', and convert non-alphanums to '_'
  local key = last (normal):match ("^%-*(.*)$"):gsub ("%W", "_")

  for _, opt in ipairs (normal) do
    self[opt] = { key = key, handler = handler, value = value }
  end
end


------
-- Parsed options table, with a key for each encountered option, each
-- with value set by that option's @{on_handler}.  Where an option
-- has one or more long-options specified, the key will be the first
-- one of those with leading hyphens stripped and non-alphanumeric
-- characters replaced with underscores.  For options that can only be
-- specified by a short option, the key will be the letter of the first
-- of the specified short options:
--
--     {"-e", "--eval-file"} => opts.eval_file
--     {"-n", "--dryrun", "--dry-run"} => opts.dryrun
--     {"-t", "-T"} => opts.t
--
-- Generally there will be one key for each previously specified
-- option (either automatically assigned by @{OptionParser} or
-- added manually with @{on}) containing the value(s) assigned by the
-- associated @{on_handler}.  For automatically assigned handlers,
-- that means `true` for straight-forward flags and
-- optional-argument options for which no argument was given; or else
-- the string value of the argument passed with an option given only
-- once; or a table of string values of the same for arguments given
-- multiple times.
--
--     ./prog -x -n -x => opts = { x = true, dryrun = true }
--     ./prog -e '(foo bar)' -e '(foo baz)'
--         => opts = {eval_file = {"(foo bar)", "(foo baz)"} }
--
-- If you write your own handlers, or otherwise specify custom
-- handling of options with @{on}, then whatever value those handlers
-- return will be assigned to the respective keys in `opts`.
-- @table opts


--- Parse an argument list.
-- @tparam table arglist list of arguments
-- @tparam[opt] table defaults table of default option values
-- @treturn table a list of unrecognised *arglist* elements
-- @treturn opts parsing results
local function parse (self, arglist, defaults)
  self.unrecognised, self.opts = {}, {}

  arglist = normalise (self, arglist)

  local i = 1
  while i > 0 and i <= len (arglist) do
    local opt = arglist[i]

    if self[opt] == nil then
      table_insert (self.unrecognised, opt)
      i = i + 1

      -- Following non-'-' prefixed argument is an optarg.
      if i <= len (arglist) and arglist[i]:match "^[^%-]" then
        table_insert (self.unrecognised, arglist[i])
        i = i + 1
      end

    -- Run option handler functions.
    else
      assert (type (self[opt].handler) == "function")

      i = self[opt].handler (self, arglist, i, self[opt].value)
    end
  end

  -- Merge defaults into user options.
  for k, v in pairs (defaults or {}) do
    if self.opts[k] == nil then self.opts[k] = v end
  end

  -- metatable allows `io.warn` to find `parser.program` when assigned
  -- back to _G.opts.
  return self.unrecognised, setmetatable (self.opts, {__index = self})
end


--- Take care not to register duplicate handlers.
-- @param current current handler value
-- @param new new handler value
-- @return `new` if `current` is nil
local function set_handler (current, new)
  assert (current == nil, "only one handler per option")
  return new
end


local function _init (self, spec)
  local parser = {}

  parser.versiontext, parser.version, parser.helptext, parser.program =
    spec:match ("^([^\n]-(%S+)\n.-)%s*([Uu]sage: (%S+).-)%s*$")

  if parser.versiontext == nil then
    error ("OptionParser spec argument must match '<version>\\n" ..
           "...Usage: <program>...'")
  end

  -- Collect helptext lines that begin with two or more spaces followed
  -- by a '-'.
  local specs = {}
  parser.helptext:gsub ("\n  %s*(%-[^\n]+)",
                        function (spec) table_insert (specs, spec) end)

  -- Register option handlers according to the help text.
  for _, spec in ipairs (specs) do
    local options, handler = {}

    -- Loop around each '-' prefixed option on this line.
    while spec:sub (1, 1) == "-" do

      -- Capture end of options processing marker.
      if spec:match "^%-%-,?%s" then
        handler = set_handler (handler, finished)

      -- Capture optional argument in the option string.
      elseif spec:match "^%-[%-%w]+=%[.+%],?%s" then
        handler = set_handler (handler, optional)

      -- Capture required argument in the option string.
      elseif spec:match "^%-[%-%w]+=%S+,?%s" then
        handler = set_handler (handler, required)

      -- Capture any specially handled arguments.
      elseif spec:match "^%-%-help,?%s" then
        handler = set_handler (handler, help)

      elseif spec:match "^%-%-version,?%s" then
        handler = set_handler (handler, version)
      end

      -- Consume argument spec, now that it was processed above.
      spec = spec:gsub ("^(%-[%-%w]+)=%S+%s", "%1 ")

      -- Consume short option.
      local _, c = spec:gsub ("^%-([-%w]),?%s+(.*)$",
                              function (opt, rest)
                                if opt == "-" then opt = "--" end
                                table_insert (options, opt)
                                spec = rest
                              end)

      -- Be careful not to consume more than one option per iteration,
      -- otherwise we might miss a handler test at the next loop.
      if c == 0 then
        -- Consume long option.
        spec:gsub ("^%-%-([%-%w]+),?%s+(.*)$",
                   function (opt, rest)
                     table_insert (options, opt)
                     spec = rest
                   end)
      end
    end

    -- Unless specified otherwise, treat each option as a flag.
    on (parser, options, handler or flag)
  end

  return setmetatable (parser, getmetatable (self))
end


--- Signature for initialising a custom OptionParser.
--
-- Read the documented options from *spec* and return custom parser that
-- can be used for parsing the options described in *spec* from a run-time
-- argument list.  Options in *spec* are recognised as lines that begin
-- with at least two spaces, followed by a hyphen.
-- @static
-- @function OptionParser_Init
-- @string spec option parsing specification
-- @treturn OptionParser a parser for options described by *spec*
-- @usage
-- customparser = optparse (optparse_spec)


return setmetatable ({
  --- Module table.
  -- @table optparse
  -- @string version release version identifier


  --- OptionParser prototype object.
  --
  -- Most often, after instantiating an @{OptionParser}, everything else
  -- is handled automatically.
  --
  -- Then, calling `parser:parse` as shown below saves unparsed arguments
  -- into `_G.arg` (usually filenames or similar), and `_G.opts` will be a
  -- table of successfully parsed option values. The keys into this table
  -- are the long-options with leading hyphens stripped, and non-word
  -- characters turned to `_`.  For example if `--another-long` had been
  -- found in the initial `_G.arg`, then `_G.opts` will have a key named
  -- `another_long`, with an appropriate value.  If there is no long
  -- option name, then the short option is used, i.e. `_G.opts.b` will be
  -- set.
  --
  -- The values saved against those keys are controlled by the option
  -- handler, usually just `true` or the option argument string as
  -- appropriate.
  -- @object OptionParser
  -- @tparam OptionParser_Init _init initialisation function
  -- @string program the first word following "Usage:" from *spec*
  -- @string version the last white-space delimited word on the first line
  --   of text from *spec*
  -- @string versiontext everything preceding "Usage:" from *spec*, and
  --   which will be displayed by the @{version} @{on_handler}
  -- @string helptext everything including and following "Usage:" from
  --   *spec* string and which will be displayed by the @{help}
  --   @{on_handler}
  -- @usage
  -- local optparse = require "optparse"
  --
  -- local optparser = optparse [[
  -- any text VERSION
  -- Additional lines of text to show when the --version
  -- option is passed.
  --
  -- Several lines or paragraphs are permitted.
  --
  -- Usage: PROGNAME
  --
  -- Banner text.
  --
  -- Optional long description text to show when the --help
  -- option is passed.
  --
  -- Several lines or paragraphs of long description are permitted.
  --
  -- Options:
  --
  --   -b                       a short option with no long option
  --       --long               a long option with no short option
  --       --another-long       a long option with internal hypen
  --   -v, --verbose            a combined short and long option
  --   -n, --dryrun, --dry-run  several spellings of the same option
  --   -u, --name=USER          require an argument
  --   -o, --output=[FILE]      accept an optional argument
  --       --version            display version information, then exit
  --       --help               display this help, then exit
  --
  -- Footer text.  Several lines or paragraphs are permitted.
  --
  -- Please report bugs at bug-list@yourhost.com
  -- ]]
  --
  -- -- Note that `std.io.die` and `std.io.warn` will only prefix messages
  -- -- with `parser.program` if the parser options are assigned back to
  -- -- `_G.opts`:
  -- _G.arg, _G.opts = optparser:parse (_G.arg)
  prototype = setmetatable ({
    -- Prototype initial values.
    opts        = {},
    helptext    = "",
    program     = "",
    versiontext = "",
    version     = 0,
  }, {
    _type = "OptionParser",

    __call = _init,

    --- @export
    __index = {
      boolean  = boolean,
      file     = file,
      finished = finished,
      flag     = flag,
      help     = help,
      optional = optional,
      required = required,
      version  = version,

      on     = on,
      opterr = opterr,
      parse  = parse,
    },
  }),
}, {
  --- Metamethods
  -- @section Metamethods

  _type = "Module",


  -- Pass through options to the OptionParser prototype.
  __call = function (self, ...) return self.prototype (...) end,
  

  --- Lazy loading of optparse submodules.
  -- Don't load everything on initial startup, wait until first attempt
  -- to access a submodule, and then load it on demand.
  -- @function __index
  -- @string name submodule name
  -- @treturn table|nil the submodule that was loaded to satisfy the missing
  --   `name`, otherwise `nil` if nothing was found
  -- @usage
  -- local optparse = require "optparse"
  -- local version = optparse.version
  __index = function (self, name)
    local ok, t = pcall (require, "optparse." .. name)
    if ok then
      rawset (self, name, t)
      return t
    end
  end,
})

end)()



do
-- Lua 5.3
unpack     = unpack     or table.unpack
loadstring = loadstring or load

-------------------------------------------------------------------------------

function DBG1 (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function ASR1 (cond, msg)
    if cond then
        return cond
    end
    if TESTS then
        return assert(false, msg)
                -- TODO: error(msg) ???
    else
        DBG('>>> ERROR : '..msg)
        os.exit(1)
    end
end

-------------------------------------------------------------------------------

function DBG2 (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function WRN (cond, ln, code, msg)
    if cond then
        return cond
    end

    if not tonumber(code) then
        code, msg, extra = '0000', code, msg
    end
    ln = (AST.is_node(ln) and ln.ln) or ln
    msg = 'WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg

    if TESTS_file and tonumber(code)>1100 then
        TESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[

==============
]])
    end

    DBG2('WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg)
    return cond
end
function ASR2 (cond, ln, code, msg, extra)
    if cond then
        return cond
    end

    if not tonumber(code) then
        code, msg, extra = '0000', code, msg
    end
    ln = (AST.is_node(ln) and ln.ln) or ln
    msg = 'ERR ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg
    if extra and OPTS.verbose then
        msg = msg..'\n'..extra
    end

    if TESTS_file and tonumber(code)>1100 then
        TESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[
==============
]])
    end

    if TESTS then
        return assert(false, msg)
                -- TODO: error(msg) ???
    else
        DBG2(msg)
        os.exit(1)
    end
end

local pass = function () end
function ASR_WRN_PASS (v)
    if v == 'error' then
        return ASR
    elseif v == 'warning' then
        return WRN
    else
        assert(v == 'pass')
        return pass
    end
end

function ASR_WRN_PASS_MIN (f1, f2)
    if f1==pass or f2==pass then
        return pass
    elseif f1==WRN or f2==WRN then
        return WRN
    else
        return ASR
    end
end

end

DBG,ASR = DBG1,ASR1

do
PAK = PAK or {
    ceu_ver = '?',
    ceu_git = '?',
}

if not TESTS then
    CEU = {}

    local help = [[
ceu ]]..PAK.ceu_ver..' ('..PAK.ceu_git..[[)

Usage: ceu [<options>] <file>...

Options:

    --help                          display this help, then exit
    --version                       display version information, then exit

    --pre                           Preprocessor phase: preprocess CÃ©u into CÃ©u
    --pre-exe=FILE                      preprocessor executable
    --pre-args=ARGS                     preprocessor arguments
    --pre-input=FILE                    input file to compile (CÃ©u source)
    --pre-output=FILE                   output file to generate (CÃ©u source)

    --ceu                           CÃ©u phase: compiles CÃ©u into C
    --ceu-input=FILE                    input file to compile (CÃ©u source)
    --ceu-output=FILE                   output source file to generate (C source)
    --ceu-line-directives=BOOL          insert `#line` directives in the C output (default `true`)
    --ceu-callbacks-lines=BOOL          pass current filename and line number to callbacks (default `true`)

    --ceu-features-trace=BOOL           enable trace support (default `false`)
    --ceu-features-exception=BOOL       enable exceptions support (default `false`)
    --ceu-features-dynamic=BOOL         enable dynamic allocation support (default `false`)
    --ceu-features-pool=BOOL            enable pool support (default `false`)
    --ceu-features-lua=BOOL             enable `lua` support (default `false`)
    --ceu-features-thread=BOOL          enable `async/thread` support (default `false`)
    --ceu-features-isr=BOOL             enable `async/isr` support (default `false`)

    --ceu-err-unused=OPT                effect for unused identifier: error|warning|pass
    --ceu-err-unused-native=OPT                    unused native identifier
    --ceu-err-unused-code=OPT                      unused code identifier
    --ceu-err-uninitialized=OPT         effect for uninitialized variable: error|warning|pass
    --ceu-err-uncaught-exception=OPT    effect for uncaught exception: error|warning|pass
    --ceu-err-uncaught-exception-main=OPT   ... at the main block (outside `code` abstractions)
    --ceu-err-uncaught-exception-lua=OPT    ... from Lua code

    --env                           Environment phase: packs all C files together
    --env-types=FILE                    header file with type declarations (C source)
    --env-threads=FILE                  header file with thread declarations (C source)
    --env-ceu=FILE                      output file from CÃ©u phase (C source)
    --env-main=FILE                     source file with main function (C source)
    --env-output=FILE                   output file to generate (C source)

    --cc                            C phase: compiles C into binary
    --cc-exe=FILE                       C compiler executable
    --cc-args=ARGS                      compiler arguments
    --cc-input=FILE                     input file to compile (C source)
    --cc-output=FILE                    output file to generate (binary)

http://www.ceu-lang.org/

Please report bugs at <http://github.com/fsantanna/ceu/issues>.
]]

--[[
  -b                       a short option with no long option
      --long               a long option with no short option
      --another-long       a long option with internal hypen
      --true               a Lua keyword as an option name
  -v, --verbose            a combined short and long option
  -n, --dryrun, --dry-run  several spellings of the same option
  -u, --name=USER          require an argument
  -o, --output=[FILE]      accept an optional argument
  --                       end of options
]]

    local parser = optparse(help)
    local arg, opts = parser:parse(_G.arg)
--[[
    print'------'
    for k,v in pairs(arg) do
        print(k,v)
    end
    print'------'
    for k,v in pairs(opts) do
        print(k,v)
    end
    print'------'
]]

    CEU.help = help
    CEU.arg  = arg
    CEU.opts = opts
end

for i,v in pairs(CEU.arg) do
    DBG(CEU.help)
    ASR(false, 'invalid option "'..v..'"')
end

local function check_no (pre)
    for k,v in pairs(CEU.opts) do
        local kk = string.gsub(k,'_','-')
        ASR(not string.find(k, '^'..pre..'_'),
            'invalid option "'..kk..'" : '..
            'expected option "'..pre..'"')
    end
end

if not (CEU.opts.pre or CEU.opts.ceu or CEU.opts.env or CEU.opts.cc) then
    DBG(CEU.help)
    ASR(false, 'expected some option')
end

if CEU.opts.pre then
    CEU.opts.pre_exe  = CEU.opts.pre_exe  or 'cpp'
    CEU.opts.pre_args = CEU.opts.pre_args or ''
    ASR(CEU.opts.pre_input, 'expected option `pre-input`')
    CEU.opts.pre_output = CEU.opts.pre_output or '-'
else
    check_no('pre')
end

do
    local function toboolean (v)
        if v == 'true' then
            return true
        elseif v == 'false' then
            return false
        end
        return nil
    end

    local T = {
        ceu_output             = { tostring,  '-'     },
        ceu_line_directives    = { toboolean, 'true'  },
        ceu_features_trace     = { toboolean, 'false' },
        ceu_features_exception = { toboolean, 'false' },
        ceu_features_dynamic   = { toboolean, 'false' },
        ceu_features_pool      = { toboolean, 'false' },
        ceu_features_lua       = { toboolean, 'false' },
        ceu_features_thread    = { toboolean, 'false' },
        ceu_features_isr       = { toboolean, 'false' },

        env_output             = { tostring,  '-'     },
    }

    for k, t in pairs(T) do
        local tp, v = unpack(t)
        local pre = string.match(k, '^(.-)_')
        if CEU.opts[pre] then
            v = tp(CEU.opts[k] or v)
            ASR(v ~= nil, 'invalid value for option "'..k..'"')
            CEU.opts[k] = v
        end
    end
end

if CEU.opts.ceu then
    if CEU.opts.pre then
        if CEU.opts.ceu_input then
            ASR(CEU.opts.ceu_input == CEU.opts.pre_output,
                "`pre-output` and `ceu-input` don't match")
        else
            if CEU.opts.pre_output == '-' then
                CEU.opts.pre_output = os.tmpname()
            end
            CEU.opts.ceu_input = CEU.opts.pre_output
        end
    end
    ASR(CEU.opts.ceu_input, 'expected option `ceu-input`')

    if CEU.opts.ceu_features_exception then
        --ASR(CEU.opts.ceu_features_trace, 'expected option `ceu-features-trace`')
    end
    if CEU.opts.ceu_features_lua or CEU.opts.ceu_features_thread then
        ASR(CEU.opts.ceu_features_dynamic, 'expected option `ceu-features-dynamic`')
    end
else
    check_no('ceu')
end

if CEU.opts.env then
    if not CEU.opts.ceu then
        ASR(not CEU.opts.pre, 'expected option `ceu`')
    end

    ASR(CEU.opts.env_types,   'expected option `env-types`')
    --ASR(CEU.opts.env_threads, 'expected option `env-threads`')
    --ASR(CEU.opts.env_main,    'expected option `env-main`')

    if CEU.opts.ceu then
        if CEU.opts.env_ceu then
            ASR(CEU.opts.env_ceu == CEU.opts.ceu_output,
                "`ceu-output` and `env-ceu` don't match")
        else
            if CEU.opts.ceu_output == '-' then
                CEU.opts.ceu_output = os.tmpname()
            end
            CEU.opts.env_ceu = CEU.opts.ceu_output
        end
    end
    ASR(CEU.opts.env_ceu, 'expected option `env-ceu`')
else
    check_no('env')
end

if CEU.opts.cc then
    if not CEU.opts.env then
        ASR(not CEU.opts.pre, 'expected option `env`')
        ASR(not CEU.opts.ceu, 'expected option `env`')
    end

    CEU.opts.cc_exe  = CEU.opts.cc_exe  or 'gcc'
    CEU.opts.cc_args = CEU.opts.cc_args or ''

    if CEU.opts.env then
        if CEU.opts.cc_input then
            ASR(CEU.opts.cc_input == CEU.opts.env_output,
                "`env-output` and `cc-input` don't match")
        else
            if CEU.opts.env_output == '-' then
                CEU.opts.env_output = os.tmpname()
            end
            CEU.opts.cc_input = CEU.opts.env_output
        end
    end
    ASR(CEU.opts.cc_input, 'expected option `cc-input`')

    ASR(CEU.opts.cc_output, 'expected option `cc-output`')
else
    check_no('cc')
end

end

if CEU.opts.pre then
    
do
-- "-C":  keep comments (because of nesting)
-- "-dD": repeat #define's (because of macros used as C functions)
local f = io.popen(CEU.opts.pre_exe..' -C -dD '..CEU.opts.pre_args..
            ' "'..CEU.opts.pre_input..'" -o "'..CEU.opts.pre_output..'" 2>&1')
local out = f:read'*a'
ASR(f:close(), out)

-- remove "# <n> "<filename>"
if CEU.opts.ceu_line_directives == false then
    local f = assert(io.open(CEU.opts.pre_output))
    local str = f:read'*a'
    f:close()

    str = string.gsub(str, '\n# %d+[^\n]*\n', '\n')

    f = assert(io.open(CEU.opts.pre_output, 'w'))
    f:write(str)
    f:close()
end

if CEU.opts.pre_output == '-' then
    print(out)
end

end

end
if CEU.opts.ceu then
    
do
m = require 'lpeg'
m.setmaxstack(1000)

local LINE = 1
local FILE = CEU.opts.pre_input or CEU.opts.ceu_input
local patt

CEU.i2l = {}

local line = m.Cmt('\n',
    function (s,i)
        for i=#CEU.i2l, i do
            CEU.i2l[i] = { string.gsub(FILE,'\\','/'), LINE }
        end
        LINE = LINE + 1
        return true
    end )

local S = (m.S'\t\r ' + m.P'\\'*(1-m.P'\n')^0*'\n')
local SS = S^0

-- #line N "file" :: directive to set line/filename
local dir_lins = m.Cmt( m.P'#' *SS* m.P'line'^-1
                          *SS* m.C(m.R'09'^1)             -- line
                          *SS* ( m.P'"' * m.C((1-m.P'"')^0) * m.P'"'
                              + m.Cc(false) )            -- file
                          * (S + (m.P(1)-'\n'))^0 * '\n' -- \n
                 ,
    function (s,i, line, file)
        LINE = tonumber(line)
        FILE = string.gsub(file,'\\','/')
        return true
    end )

patt = (line + dir_lins + 1)^0

local f = ASR(io.open(CEU.opts.ceu_input))
CEU.source = '\n#line 1 "'..string.gsub(FILE,'\\','/')..'"'..'\n'..f:read'*a'..'\n'
f:close()
patt:match(CEU.source)

end

    
do
local P, C, V, S, Cc, Ct, Cg = m.P, m.C, m.V, m.S, m.Cc, m.Ct, m.Cg

--local __debug = true
local spc = 0
if __debug then
    local VV = V
    V = function (id)
        return
            m.Cmt(P'',
                function ()
                    DBG(string.rep(' ',spc)..'>>>', id)
                    spc = spc + 2
                    return true
                end)
            * (
                VV(id) * m.Cmt(P'',
                            function ()
                                spc = spc - 2
                                DBG(string.rep(' ',spc)..'+++', id)
                                return true
                            end)
              + m.Cmt(P'',
                    function ()
                        spc = spc - 2
                        DBG(string.rep(' ',spc)..'---', id)
                        return false
                    end) * P(false)
            )
    end
end

local x = V'__SPACE'^0
local X = V'__SPACE'^1

local T = {
    {
        '`%*` or `/` or `%%` or `%+` or `%-` or `>>` or `<<` or `&` or `^` or `|` or `!=` or `==` or `<=` or `>=` or `<` or `>` or `and` or `or`',
        'binary operator'
    },
    {
        '`%*` or `/` or `%%` or `%+` or `%-` or `>>` or `<<` or `^` or `|` or `!=` or `==` or `<=` or `>=` or `<` or `>` or `and` or `or`',
        'binary operator'
    },

    {
        '`&&` or `%?`',
        'type modifier'
    },

    {
        'primitive type or abstraction identifier or native identifier',
        'type'
    },

    {
        '`native` or `code` or `input` or `output` or end of file',
        'end of file'
    },
    {
        '`;` or `native` or `code` or `input` or `output` or `with`',
        '`with`'
    },
    {
        '`native` or `code` or `input` or `output` or `end`',
        '`end`'
    },

    {
        ' or `/dynamic` or `/static` or `/recursive`',
        '',
    },

    {
        '`%*` or `%$` or internal identifier or native identifier or `outer`',
        'location'
    },

    {
        '`do` or `await` or `%[` or location or `{` or `%(` or `not` or `%-` or `%+` or `~` or `%$%$` or `&&` or `&` or `call` or `sizeof` or `null` or number or `false` or `true` or `off` or `on` or `no` or `yes` or `"` or string literal or `emit` or `call/recursive` or `val` or `new` or `spawn` or `_` or `request` or `watching`',
        'expression'
    },
    {
        '`not` or `%-` or `%+` or `~` or `%$%$` or `%*` or `%$` or `&&` or `&` or `call` or internal identifier or native identifier or `outer` or `{` or `%(` or `sizeof` or `null` or number or `false` or `true` or `off` or `on` or `no` or `yes` or `"` or string literal',
        'expression'
    },

    {
        '`code` or `input` or `output` or `data` or `native` or `do` or `if` or `loop` or `every` or `lock` or `spawn` or `par/or` or `par/and` or `watching` or `catch` or `pause/if` or `await` or `atomic` or `pre` or `{` or `%[` or `lua` or `var` or `nothing` or `pool` or `event` or `deterministic` or location or `%(` or `emit` or `call/recursive` or `call` or `request` or `kill` or `not` or `%-` or `%+` or `~` or `%$%$` or `&&` or `&` or `sizeof` or `null` or number or `false` or `true` or `off` or `on` or `no` or `yes` or `"` or string literal or `escape` or `break` or `continue` or `throw` or `par` or end of file',
        'statement'
    },
    {
        '`code` or `input` or `output` or `data` or `native` or `do` or `if` or `loop` or `every` or `lock` or `spawn` or `par/or` or `par/and` or `watching` or `catch` or `pause/if` or `await` or `atomic` or `pre` or `{` or `%[` or `lua` or `var` or `nothing` or `pool` or `event` or `deterministic` or location or `%(` or `emit` or `call/recursive` or `call` or `request` or `kill` or `not` or `%-` or `%+` or `~` or `%$%$` or `&&` or `&` or `sizeof` or `null` or number or `false` or `true` or `off` or `on` or `no` or `yes` or `"` or string literal or `escape` or `break` or `continue` or `throw` or `par` or `with`',
        'statement'
    },
    {
        '`code` or `input` or `output` or `data` or `native` or `do` or `if` or `loop` or `every` or `lock` or `spawn` or `par/or` or `par/and` or `watching` or `catch` or `pause/if` or `await` or `atomic` or `pre` or `{` or `%[` or `lua` or `var` or `nothing` or `pool` or `event` or `deterministic` or location or `%(` or `emit` or `call/recursive` or `call` or `request` or `kill` or `not` or `%-` or `%+` or `~` or `%$%$` or `&&` or `&` or `sizeof` or `null` or number or `false` or `true` or `off` or `on` or `no` or `yes` or `"` or string literal or `escape` or `break` or `continue` or `throw` or `par` or `end`',
        'statement'
    },
}
if TESTS then
    TESTS.parser_translate = TESTS.parser_translate or { ok={}, original=T }
end

-- ( ) . % + - * ? [ ] ^ $

local function translate (msg)
    for i,t in ipairs(T) do
        local fr,to = unpack(t)
        local new = string.gsub(msg, fr, to)
        if TESTS then
            if msg ~= new then
                TESTS.parser_translate.ok[i] = true
            end
        end
        msg = new
--return new
    end
    return msg
end

local ERR_i    = 0
local ERR_strs = {}
local LST_i    = 0
local LST_str  = 'begin of file'

local IGN = 0
local ign_inc   = m.Cmt(P'', function() IGN=IGN+1 return true  end)
local ign_dec_t = m.Cmt(P'', function() IGN=IGN-1 return true  end)
local ign_dec_f = m.Cmt(P'', function() IGN=IGN-1 return false end)

local function I (patt)
    return ign_inc * (patt*ign_dec_t + ign_dec_f*P(false))
end

local function ERR ()
--DBG(LST_i, ERR_i, ERR_strs, _I2L[LST_i], I2TK[LST_i])
    local file, line = unpack(CEU.i2l[LST_i])
    return 'ERR : '..file..
              ' : line '..line..
              ' : after `'..LST_str..'`'..
              ' : expected '..translate(table.concat(ERR_strs,' or '))
end

local function fail (i, err)
    if i==ERR_i and (not ERR_strs[err]) then
        ERR_strs[#ERR_strs+1] = err
        ERR_strs[err] = true
    elseif i > ERR_i then
        ERR_i = i
        ERR_strs = { err }
        ERR_strs[err] = true
    end
    return false
end

-- KK accepts leading chars
local function KK (patt, err, nox)
    if type(patt) == 'string' then
        err = err or '`'..patt..'`'
    else
        err = err or error(debug.traceback())
    end

    local ret = m.Cmt(patt,
                    -- SUCCESS
                    function (_, i, tk)
                        if IGN>0 then return true end
if __debug then
    DBG(string.rep(' ',spc)..'|||', '|'..tk..'|')
end
                        if i > LST_i then
                            LST_i   = i
                            LST_str = tk
                        end
                        return true
                    end)
              + m.Cmt(P'',
                    -- FAILURE
                    function (_,i)
                        if err==true or IGN>0 then return false end
                        return fail(i,err)
                    end) * P(false)
                           -- (anones "left recursive" error (explicit fail))

    if not nox then
        ret = ret * x
    end
    return ret
end

-- K is exact match
local function K (patt, err, nox)
    err = err or '`'..patt..'`'
    patt = patt * -m.R('09','__','az','AZ','\127\255')
    return KK(patt, err, nox)
end

local CKK = function (tk,err,nox)
    local patt = C(KK(tk,err,true))
    if nox == nil then
        patt = patt * x
    end
    return patt
end
local CK = function (tk,err,nox)
    local patt = C(K(tk,err,true))
    if nox == nil then
        patt = patt * x
    end
    return patt
end

local OPT = function (patt)
    return patt + Cc(false)
end

local PARENS = function (patt)
    return KK'(' * patt * KK')'
end

local function LIST (patt)
    return patt * (KK','*patt)^0 * KK','^-1
end

local E = function (msg)
    return m.Cmt(P'',
            function (_,i)
                return fail(i,msg)
            end)
end

-- TODO; remove
local EE = function (msg)
    return m.Cmt(P'',
            function (_,i)
                TESTS_TODO = true
                return fail(i,msg)
            end)
end

-->>> OK
local TYPES = P'bool' + 'yes/no' + 'on/off'
            + 'byte'
            + 'r32' + 'r64' + 'real'
            + 'integer' + 'int'
            + 's16' + 's32' + 's64' + 's8'
            + 'ssize'
            + 'u16' + 'u32' + 'u64' + 'u8'
            + 'uint' + 'usize' + 'none'
--<<<

-- must be in reverse order (to count superstrings as keywords)
KEYS = P
'yes' +
'with' +
'watching' +
'var' +
'val' +
'until' +
'true' +
'traverse' +
'tight' +
'throws' +
'throw' +
'thread' +
'then' +
'static' +
'spawn' +
'sizeof' +
'resume' +
'request' +
'recursive' +
'pure' +
'pre' +
'pos' +
'pool' +
'plain' +
'pause' +
'par' +
'output' +
'outer' +
'or' +
'on' +
'off' +
'null' +
'nothing' +
'not' +
'none' +
'nohold' +
'no' +
'new' +
'NEVER' +
'native' +
'lua' +
'loop' +
'lock' +
'kill' +
'isr' +
'is' +
'input' +
'in' +
'if' +
'hold' +
'FOREVER' +
'finalize' +
'false' +
'every' +
'event' +
'escape' +
'end' +
'emit' +
'else' +
'dynamic' +
'do' +
'deterministic' +
'data' +
'continue' +
'const' +
'code' +
'catch' +
'call' +
'break' +
'await' +
'atomic' +
'async' +
'as' +
'and' +
TYPES

KEYS = KEYS * -m.R('09','__','az','AZ','\127\255')

local Alpha    = m.R'az' + '_' + m.R'AZ'
local Alphanum = Alpha + m.R'09'
local ALPHANUM = m.R'AZ' + '_' + m.R'09'
local alphanum = m.R'az' + '_' + m.R'09'

-- Rule:    unchanged in the AST
-- _Rule:   changed in the AST as "Rule"
-- __Rule:  container for other rules, not in the AST
-- __rule:  (local) container for other rules

GG = { [1] = x * V'_Stmts' * V'Y' * (P(-1) + E('end of file'))

-->>> OK

    , Y = C''     -- yielding point

    , __seqs = KK';' * KK(';',true)^0     -- "true": ignore as "expected"
    , Nothing = K'nothing'

-- DO, BLOCK

    -- escape/A 10
    -- break/i
    -- continue/i
    , _Escape   = K'escape'   * ('/'*V'ID_int' + Cc(true)) * OPT(V'__Exp')
    , Break    = K'break'    * OPT('/'*V'ID_int') * V'Y'
    , Continue = K'continue' * OPT('/'*V'ID_int')

    -- do/A ... end
    , _Do = K'do' * ('/'*(V'ID_int'+V'ID_any') + Cc(true)) * OPT(PARENS(V'List_Var'+Cc(true))) *
                V'Block' *
            K'end'

    , __Do  = K'do' * V'Block' * K'end'
    , _Dopre = K'pre' * V'__Do'

    , Block = V'_Stmts'

-- PAR, PAR/AND, PAR/OR

    , Par     = K'par' * K'do' *
                 V'Block' * (K'with' * V'Block')^1 *
                K'end'
    , Par_And = K'par/and' * K'do' *
                    V'Block' * (K'with' * V'Block')^1 *
                K'end'
    , Par_Or  = K'par/or' * K'do' *
                    V'Block' * (K'with' * V'Block')^1 *
                K'end'

-- FLOW CONTROL

    , _If = K'if' * V'__Exp' * K'then' * V'Block' *
            (K'else/if' * V'__Exp' * K'then' * V'Block')^0 *
            OPT(K'else' * V'Block') *
            K'end'

    , _Loop_Num_Range = (CKK'[' + CKK']') * (
                            V'__Exp' * CKK'->' * (V'ID_any' + V'__Exp') +
                            (V'ID_any' + V'__Exp') * CKK'<-' * V'__Exp'
                          ) * (CKK'[' + CKK']') *
                          OPT(KK',' * V'__Exp')

    , _Loop_Num = K'loop' * OPT('/'*V'__Exp') *
                    (V'__ID_int'+V'ID_any') * OPT(K'in' * V'_Loop_Num_Range') *
                  V'__Do'
    , Loop_Pool = K'loop' * OPT('/'*V'__Exp') *
                    (V'ID_int'+V'ID_any') * K'in' * V'Loc' *
                  V'__Do'
    , Loop      = K'loop' * OPT('/'*V'__Exp') *
                  V'__Do'

    , _Every  = K'every' * OPT((V'Loc'+PARENS(V'List_Loc')) * K'in') *
                    (V'Await_Ext' + V'Await_Int' + V'Await_Wclock') *
                V'__Do'

    , _Lock = K'lock' * V'Loc' * V'__Do'

    , Stmt_Call = V'Abs_Call' + V'__Nat_Call'

    , __fin_stmt  = V'___fin_stmt' * V'__seqs'
    , ___fin_stmt = V'Nothing'
                  + V'_Set'
                  + V'Emit_Ext_emit' + V'Emit_Ext_call'
                  + V'Stmt_Call'
    , __finalize  = K'finalize' * (PARENS(V'List_Loc') + Cc(false)) * K'with' *
                        V'Block' *
                    OPT(K'pause'  * K'with' * V'Block') *
                    OPT(K'resume' * K'with' * V'Block') *
                    K'end'
    , _Finalize = K'do' * OPT(V'__fin_stmt') * V'__finalize'

    , _Var_set_fin = K'var' * V'__ALS' * V'Type' * V'__ID_int'
                   * (KK'='-'==') * KK'&'
                    * (V'__Nat_Call' + V'Abs_Call')
                     * V'__finalize'

    , Pause_If = K'pause/if' * (V'Loc'+V'ID_ext') * V'__Do'

-- ASYNCHRONOUS

    , Async        = K'await' * K'async' * (-P'/thread'-'/isr') * V'Y' *
                        OPT(PARENS(V'List_Var')) * V'__Do'
    , Async_Thread = K'await' * K'async/thread' * V'Y' *
                        OPT(PARENS(V'List_Var')) * V'__Do'
    , _Async_Isr   = K'spawn' * K'async/isr' * KK'[' * V'List_Exp' * KK']' *
                        OPT(PARENS(V'List_Var')) * V'Y' *
                     V'__Do'
    , Atomic  = K'atomic' * V'__Do'

-- CODE / EXTS (call, req)

    -- CODE

    , __code = K'code' * Ct( Cg(K'/tight'*Cc'tight','tight') *
                             Cg(K'/dynamic'*Cc'dynamic','dynamic')^-1 *
                             Cg(K'/recursive'*Cc'recursive','recursive')^-1 ) *
                (V'__ID_abs'-V'__id_data') *
                    V'Code_Pars' * KK'->' *
                        Cc(false) *
                            (#V'Type' * V'Code_Ret') *
                Cc(false)
             + K'code' * Ct( Cg(K'/await'*Cc'await','await') *
                             Cg(K'/dynamic'*Cc'dynamic','dynamic')^-1 *
                             Cg(K'/recursive'*Cc'recursive','recursive')^-1 ) *
                (V'__ID_abs'-V'__id_data') *
                    V'Code_Pars' * KK'->' *
                        OPT(V'_Code_Pars' * KK'->') *
                            V'Code_Ret' *
                (K'throws'*V'List_Throws' + Cc(false))

    , _Code_proto = V'__code' * Cc(false)
    , _Code_impl  = V'__code' * V'__Do' * V'Y'
    , List_Throws = LIST(V'ID_abs')

    , _Spawn_Block = K'spawn' * OPT(PARENS(V'List_Var'+Cc(true))) * V'__Do'

    -- EXTS

    -- call
--[[
    , __extcode = (CK'input/output' + CK'output/input') * K'/tight'
                    * OPT(CK'/recursive')
                    * V'__ID_ext' * V'Code_Pars' * KK'->' * V'Type'
* EE'TODO-PARSER: extcode'
    , _Ext_Code_proto = V'__extcode'
    , _Ext_Code_impl  = V'__extcode' * V'__Do'

    -- req
    , __extreq = (CK'input/output' + CK'output/input') * K'/await'
                   * OPT('[' * (V'__Exp'+Cc(true)) * KK']')
                   * V'__ID_ext' * V'Code_Pars' * KK'->' * V'Type'
* EE'TODO-PARSER: request'
    , _Ext_Req_proto = V'__extreq'
    , _Ext_Req_impl  = V'__extreq' * V'__Do'
]]

    -- TYPEPARS

    , Code_Pars  = #KK'(' * PARENS(P'none' + LIST(V'__Dcls'))
    , _Code_Pars = #KK'(' * PARENS(P'none' + LIST(V'__Dcls'))
    , Code_Ret = (V'Type' + K'NEVER'*Cc'FOREVER')

-- DATA

    , __data       = K'data' * V'__ID_abs' * OPT(KK'as' * (V'__Exp'+CK'nothing'))
    , _Data_simple = V'__data'
    , _Data_block  = V'__data' * K'with' * (V'__Dcls' * V'__seqs')^1 * K'end'

-- NATIVE, C, LUA

    -- C

    , _Nats  = K'native' *
                    OPT(KK'/'*(CK'pure'+CK'const'+CK'nohold'+CK'plain')) *
                        LIST(V'__ID_nat')
        --> Nat+

    , Nat_End = K'native' * KK'/' * K'end'
    , Nat_Block = K'native' * (CK'/pre'+CK'/pos') * (#K'do')*'do' *
                ( C(V'_C') + C((P(1)-(S'\t\n\r '*'end'*P';'^0*'\n'))^0) ) *
             x* K'end'

    , Nat_Stmt = KK('{',nil,true) * V'__nat1' * KK'}'
    , _Nat_Exp = KK('{',nil,true) * V'__nat1' * KK'}'
    , __nat1   = (V'__nat2' + C'{'*V'__nat1'*C'}')^0
    , __nat2   = C((1-S'{}'-V'__exp')^1) + V'__exp'

    , __Nat_Call = K'call'^-1 * V'__Exp'

    -- Lua

    , _Lua_Do  = K'lua' * V'__Dim' * V'__Do'
    , _Lua     = KK'[' * m.Cg(P'='^0,'lua') * KK('[',nil,true) *
                 ( V'__exp' + C((P(1)-V'__exp'-V'__luacmp')^1) )^0
                  * (V'__luacl'/function()end) *x
    , __luacl  = ']' * C(P'='^0) * KK']'
    , __luacmp = m.Cmt(V'__luacl' * m.Cb'lua',
                    function (s,i,a,b) return a == b end)

    , __exp = (P'@'-'@@') * KK'(' * V'__Exp' * KK')'
            + (P'@'-'@@') * V'__Exp'
            + m.Cs(P'@@'/'@')

-- VARS, VECTORS, POOLS, VTS, EXTS

    -- DECLARATIONS

    , __ALS = (CKK'&?' + CKK'&')

    , __var_set = V'__ID_int' * OPT(Ct(V'__Sets_one'+V'__Sets_many'))

    , _Var_set  = K'var'    * OPT(V'__ALS') * OPT(V'__Dim_Ring')
                            * Ct((Cg(K'/dynamic','dynamic') + Cg(K'/nohold','nohold'))^-1)
                                                     * V'Type'             * V'__var_set'
    , _Pool_set = K'pool'   * OPT(CKK'&') * V'__Dim' * V'Type'             * V'__var_set'
    , _Evt_set  = K'event'  * OPT(CKK'&') * (PARENS(V'_Typelist')+V'Type') * V'__var_set'

    , Ext = CK'input'  * (PARENS(V'_Typelist')     + V'Type')             * V'__ID_ext'
          + CK'output' * (PARENS(V'_Typelist_amp') + OPT(CKK'&')*V'Type') * V'__ID_ext'
    , _Typelist     = LIST(V'Type')
    , _Typelist_amp = LIST(Ct(OPT(CKK'&') * V'Type' * (V'__ID_int' + Cc(false))))

    , Ext_impl = V'Ext' * V'__Do' * V'Y'

    , __Dcls    = V'_Var_set' + V'_Pool_set' + V'_Evt_set'
-- AWAIT, EMIT

    , __Awaits_one  = K'await' * (V'Await_Wclock' + V'_Abs_Await')
    , __Awaits_many = K'await' * V'Await_Until'

    , Await_Until  = (V'Await_Ext' + V'Await_Int') * OPT(K'until'*V'__Exp')

    , Await_Ext    = V'ID_ext'   * V'Y' -I(V'_Abs_Await')            -- TODO: rem
    , Await_Int    = V'Loc' * V'Y' -I(V'Await_Wclock'+V'_Abs_Await') -- TODO: rem
    , Await_Wclock = (V'WCLOCKK' + V'WCLOCKE') * V'Y'

    , Await_Forever = K'await' * K'FOREVER' * V'Y'
    , Await_Pause   = K'await' * K'pause'   * V'Y'
    , Await_Resume  = K'await' * K'resume'  * V'Y'

    , _Emit_ps = OPT(V'__Exp' + V'ID_any' + PARENS(OPT(V'_List_Exp_Any')))
    , Emit_Wclock   = K'emit' * (V'WCLOCKK'+V'WCLOCKE')
    , Emit_Ext_emit = K'emit'                     * V'ID_ext' * V'_Emit_ps'
    , Emit_Ext_call = (K'call/recursive'+K'call') * V'ID_ext' * V'_Emit_ps'
    , Emit_Ext_req  = K'request'                  * V'ID_ext' * V'_Emit_ps'
* EE'TODO-PARSER: request'

    , Emit_Evt = K'emit' * -#(V'WCLOCKK'+V'WCLOCKE') * V'Loc' * V'_Emit_ps' * V'Y'

    , Throw = K'throw' * V'__Exp' --(V'Abs_Cons' + V'__Exp')
    , _Catch = K'catch' * LIST(V'Loc') * V'__Do'

    , __watch = (V'Await_Ext' + V'Await_Int' + V'Await_Wclock' + V'_Abs_Await')
    , _Watching = K'watching'
                    * LIST(V'__watch')
                * V'__Do'

    , __num = CKK(m.R'09'^1,'number') / tonumber
    , WCLOCKK = #V'__num' *
                (V'__num' * KK'h'   *x + Cc(0)) *
                (V'__num' * KK'min' *x + Cc(0)) *
                (V'__num' * KK's'   *x + Cc(0)) *
                (V'__num' * KK'ms'  *x + Cc(0)) *
                (V'__num' * KK'us'  *x + Cc(0))
                    * OPT(CK'/_')
    , WCLOCKE = PARENS(V'__Exp') * (
                    CK'h' + CK'min' + CK's' + CK'ms' + CK'us'
                  + E'<h,min,s,ms,us>'
              ) * OPT(CK'/_')

-- DETERMINISTIC

    , __det_id = V'ID_ext' + V'ID_int' + V'ID_nat'
    , Deterministic = K'deterministic' * V'__det_id' * (
                        K'with' * LIST(V'__det_id')
                      )^-1

-- ABS
    , __abs_mods = Ct ( (Cg(K'/dynamic'*Cc'dynamic','dynamic') +
                         Cg(K'/static' *Cc'static', 'static'))^-1 *
                         Cg(K'/recursive'*Cc'recursive','recursive')^-1 )
    , Abs_Call   = K'call' * V'__abs_mods' * (V'Abs_Cons' -I(V'__id_data'))
    , Abs_Val    = CK'val' * V'Abs_Cons'
    , Abs_New    = CK'new' * V'Abs_Cons'
    , _Abs_Await = V'__Abs_Cons_Code' * V'Y'

    , Abs_Spawn      = K'spawn' * V'__Abs_Cons_Code' * -(KK'in' * V'Loc')
    , Abs_Spawn_Pool = K'spawn' * V'__Abs_Cons_Code' * KK'in' * V'Loc'

    , __Abs_Cons_Code = V'__abs_mods' * (V'Abs_Cons' -I(V'__id_data'))
    , Abs_Cons   = OPT(V'Loc'*KK'.') * V'ID_abs' * PARENS(OPT(V'Abslist'))
    , Abslist    = LIST(V'__abs_item')^-1
    , __abs_item = (V'Abs_Cons' + V'Vec_Cons' + V'__Exp' + V'ID_any')

-- SETS

    , _Set = V'Loc' * V'__Sets_one'
           + (V'Loc' + PARENS(V'List_Loc')) * V'__Sets_many'

    , __Sets_one  = (KK'='-'==') * (V'__sets_one'  + PARENS(V'__sets_one'))
    , __Sets_many = (KK'='-'==') * (V'__sets_many' + PARENS(V'__sets_many'))

    , __sets_one =
          V'_Set_Do'
        + V'_Set_Await_one'
        + V'_Set_Async_Thread'
        + V'_Set_Lua'
        + V'_Set_Vec'
        + V'_Set_Emit_Wclock'
        + V'_Set_Emit_Ext_emit' + V'_Set_Emit_Ext_call'
        + V'_Set_Abs_Val'
        + V'_Set_Abs_New'
        + V'_Set_Abs_Spawn'
        + V'_Set_Any'
        + V'_Set_Exp'

    , __sets_many = V'_Set_Emit_Ext_req' + V'_Set_Await_many' + V'_Set_Watching'

    -- after `=`

    , _Set_Do            = #K'do'            * V'_Do'

    , _Set_Await_one     = #K'await'         * V'__Awaits_one'
    , _Set_Await_many    = #K'await'         * V'__Awaits_many'
    , _Set_Watching      = #K'watching'      * V'_Watching'

    , _Set_Async_Thread  = #(K'await' * K'async/thread') * V'Async_Thread'
    , _Set_Lua           = #V'__lua_pre'     * V'_Lua'
    , _Set_Lua_Do        =                     V'_Lua_Do'
    , _Set_Vec           =                     V'Vec_Cons'

    , _Set_Emit_Wclock   = #K'emit'          * V'Emit_Wclock'
    , _Set_Emit_Ext_emit = #K'emit'          * V'Emit_Ext_emit'
    , _Set_Emit_Ext_req  = #K'request'       * V'Emit_Ext_req'
    , _Set_Emit_Ext_call = #V'__extcode_pre' * V'Emit_Ext_call'

    , _Set_Abs_Val       = #K'val'           * V'Abs_Val'
    , _Set_Abs_New       = #K'new'           * V'Abs_New'
    , _Set_Abs_Spawn     = #K'spawn'         * (V'Abs_Spawn' + V'Abs_Spawn_Pool')

    , _Set_Any           = #K'_'             * V'ID_any'
    , _Set_Exp           =                     V'__Exp'

    , __extcode_pre = (K'call/recursive'+K'call') * V'ID_ext'
    , __lua_pre     = KK'[' * (P'='^0) * '['
    , __vec_pre     = KK'[' - V'__lua_pre'

    , __vec_concat = KK'..' * (V'__Exp' + V'_Lua' + #KK'['*V'Vec_Tup')
    , Vec_Tup  = V'__vec_pre' * OPT(V'List_Exp') * KK']'
    , Vec_Cons = (V'Loc'+V'__Exp') * V'__vec_concat'^1
               + V'Vec_Tup'        * V'__vec_concat'^0

-- IDS

    , ID_prim = V'__ID_prim'
    , ID_ext  = V'__ID_ext'
    , ID_int  = V'__ID_int'
    , ID_abs  = V'__ID_abs'
    , ID_nat  = V'__ID_nat'
    , ID_any  = V'__ID_any'

    , __ID_prim = CK(TYPES,                     'primitive type')
    , __ID_ext  = CK(m.R'AZ'*ALPHANUM^0  -KEYS, 'external identifier')
    , __ID_int  = CK(m.R'az'*Alphanum^0  -KEYS, 'internal identifier')
    , __ID_nat  = CK(P'_' * Alphanum^1,         'native identifier')
    , __ID_any  = CK(P'_' * -Alphanum,          '`_`')

    , __id_abs  = m.R'AZ'*V'__one_az' -KEYS
    , __id_data = V'__id_abs' * ('.' * V'__id_abs')^1
    , __ID_abs = CK(V'__id_data'+V'__id_abs', 'abstraction identifier')

    -- at least one lowercase character
    , __one_az = #(ALPHANUM^0*m.R'az') * Alphanum^0


-- MODS

    , __Dim      = KK'[' * (V'__Exp'+Cc('[]')) * KK']'
    , __Dim_Ring = KK'[' * (V'__Exp'+Cc('[]')) * (OPT(CK'*')+Cc(false)) * KK']'

-- LISTS

-- TODO: rename List_*
    , List_Loc = LIST(V'Loc' + V'ID_any')
    , List_Exp = LIST(V'__Exp')
    , _List_Exp_Any = LIST(V'__Exp'+ V'ID_any')
    , List_Var = LIST(V'ID_int' + V'ID_any')

 --<<<

    , Kill  = K'kill' * V'Loc' * OPT(PARENS(V'__Exp'))

-- Types

    , Type = (V'ID_prim' + V'ID_abs' + V'ID_nat') * (CKK'&&')^0 * CKK'?'^-1

-- Expressions

    -- Loc

    , Loc      = V'__01_Loc'
    , __01_Loc = V'__02_Loc' * CK'as' * (V'Type' + KK'/'*(CK'nohold'+CK'plain'+CK'pure'))
               + V'__02_Loc'
    , __02_Loc = (Cc('pre') * (CKK'*'+(CKK'$'-'$$')))^-1 * V'__03_Loc'
    , __03_Loc = V'__04_Loc' *
                    (Cc'pos' * (
                        KK'[' * Cc'idx' * V'__Exp' * KK']'                   +
                        (CKK':' + (CKK'.'-'..')) * (V'__ID_int'+V'__ID_nat') +
                        (CKK'!'-'!=') * Cc(false)
                      )
                    )^0
    , __04_Loc = V'ID_int'  + V'ID_nat'
               + V'Outer'
               + V'_Nat_Exp'
               + PARENS(V'__01_Loc')


    -- Exp

    , __Exp  = V'__01'
    , __01   = V'__11' * ( CK'is' * V'Type'
                         + CK'as' * (V'Type' + KK'/'*(CK'nohold'+CK'plain'+CK'pure'))
                         )
             + V'__02'
    , __02   = V'__03' * (CK'or'  * V'__03')^0
    , __03   = V'__04' * (CK'and' * V'__04')^0
    , __04   = V'__05' * ( ( CKK'!='+CKK'=='+CKK'<='+CKK'>='
                           + (CKK'<'-'<<'-'<-')+(CKK'>'-'>>')
                           ) * V'__05'
                         )^0
    , __05   = V'__06' * ((CKK'|'-'||') * V'__06')^0
    , __06   = V'__07' * (CKK'^' * V'__07')^0
    , __07   = V'__08' * ((CKK'&'-'&&') * V'__08')^0
    , __08   = V'__09' * ((CKK'>>'+CKK'<<') * V'__09')^0
    , __09   = V'__10' * ((CKK'+'+(CKK'-'-'->')) * V'__10')^0
    , __10   = V'__11' * ((CKK'*'+(CKK'/'-'//'-'/*')+CKK'%') * V'__11')^0
    , __11   = ( Cc('pre') *
                    ( CK'not'+(CKK'-'-'->')+CKK'+'+CKK'~'+CKK'$$'+CKK'*'+CKK'$'+CKK'&&'+CKK'&' )
               )^0 * V'__12'
    , __12  = V'__13' *
                    (Cc'pos' * (
                        KK'[' * Cc'idx' * V'__Exp' * KK']'                   +
                        (CKK':' + (CKK'.'-'..')) * (V'__ID_int'+V'__ID_nat') +
                        (CKK'!'-'!=') * Cc(false)                            +
                        (CKK'?') * Cc(false)                                 +
                        (Cc'call') * PARENS(OPT(V'List_Exp'))
                      )
                    )^0
    , __13   = V'Abs_Call'
             + V'ID_int'  + V'ID_nat'
             + V'Outer'
             + V'_Nat_Exp'
             + PARENS(V'__Exp')
             + V'SIZEOF'
             + V'NULL' + V'NUMBER' + V'BOOL' + V'STRING'

    , SIZEOF = K'sizeof' * PARENS((V'Type' + V'__Exp'))

    , NUMBER = CK( #m.R'09' * (m.R'09'+S'xX'+m.R'AF'+m.R'af'+(P'.'-'..')
                                      +(S'Ee'*'-')+S'Ee')^1,
                   'number' )
             --+ CKK( "'" * (P(1)-"'")^0 * "'" , 'number' )

    , BOOL   = K'false' / function() return 0 end
             + K'true'  / function() return 1 end
             + K'off'   / function() return 0 end
             + K'on'    / function() return 1 end
             + K'no'    / function() return 0 end
             + K'yes'   / function() return 1 end
    , STRING = CKK( CKK'"' * (P(1)-'"'-'\n')^0 * K'"', 'string literal' )
    , NULL   = CK'null'     -- TODO: the idea is to get rid of this

    , Outer   = K'outer'

---------
                -- "Ct" as a special case to anone "too many captures" (HACK_1)
    , _Stmts  = Ct (( V'__Stmt_Block' * (KK';'^0) +
                      V'__Stmt_Simple' * V'__seqs'
                   )^0
                 * ( V'__Stmt_Last' * V'__seqs' +
                     V'__Stmt_Last_Block' * (KK';'^0)
                   )^-1
                 * (V'Nat_Block'+V'_Code_impl'+V'Ext_impl')^0 )

    , __Stmt_Last  = V'_Escape' + V'Break' + V'Continue' + V'Await_Forever' + V'Throw'
    , __Stmt_Last_Block = V'Y' * V'Par'
    , __Stmt_Simple = V'Nothing'
                    + V'__Dcls'
                    + V'Ext'
                    + V'_Data_simple'
                    + V'_Code_proto' --+ V'_Ext_Code_proto' + V'_Ext_Req_proto'
                    + V'_Nats'  + V'Nat_End'
                    + V'Deterministic'
                    + V'_Set'
                    + V'__Awaits_one' + V'__Awaits_many'
                    + V'Await_Pause' + V'Await_Resume'
                    + V'Emit_Wclock'
                    + V'Emit_Ext_emit' + V'Emit_Ext_call' + V'Emit_Ext_req'
                    + V'Emit_Evt'
                    + V'Abs_Spawn' + V'Abs_Spawn_Pool' + V'Kill'
                    + V'Stmt_Call'

    , __Stmt_Block = V'_Code_impl' + V'Ext_impl' --+ V'_Ext_Code_impl' + V'_Ext_Req_impl'
              + V'_Data_block'
              + V'Nat_Block'
              + V'_Do'    + V'_If'
              + V'Loop' + V'_Loop_Num' + V'Loop_Pool'
              + V'_Every' + V'_Lock'
              + V'_Spawn_Block'
              + V'_Finalize'
              + V'Y'*V'Par_Or' + V'Y'*V'Par_And' + V'_Watching'
              + V'_Catch'
              + V'Pause_If'
              + V'Async' + V'Async_Thread' + V'_Async_Isr' + V'Atomic'
              + V'_Dopre'
              + V'Nat_Stmt'
              + V'_Lua' + V'_Lua_Do'
              + V'_Var_set_fin'

    --, _C = '/******/' * (P(1)-'/******/')^0 * '/******/'
    , _C      = m.Cg(V'_CSEP','mark') *
                    (P(1)-V'_CEND')^0 *
                V'_CEND'
    , _CSEP = '/***' * (1-P'***/')^0 * '***/'
    , _CEND = m.Cmt(C(V'_CSEP') * m.Cb'mark',
                    function (s,i,a,b) return a == b end)

    , __SPACE = ('\n' * (V'__comm'+S'\t\n\r ')^0 *
                  '#' * (P(1)-'\n')^0)
              + ('//' * (P(1)-'\n')^0)
              + S'\t\n\r '
              + V'__comm'

    , __comm    = '/' * m.Cg(P'*'^1,'comm') * (P(1)-V'__commcmp')^0 * 
                    V'__commcl'
                    / function () end
    , __commcl  = C(P'*'^1) * '/'
    , __commcmp = m.Cmt(V'__commcl' * m.Cb'comm',
                    function (s,i,a,b) return a == b end)

}

if TESTS then
    assert(m.P(GG):match(CEU.source), ERR())
else
    if not m.P(GG):match(CEU.source) then
             -- TODO: match only in ast.lua?
        DBG(ERR())
        os.exit(1)
    end
end

end

    
do
AST = {
    root = nil,
    ns   = {},
}

local STACK = {}

local MT = {}
function AST.is_node (node)
    return (getmetatable(node) == MT) and node.tag
end

AST.tag2id = {
    Abs_Await        = 'await',
    Abs_Spawn        = 'spawn',
    Abs_Spawn_Pool   = 'spawn',
    Alias            = 'alias',
    Async            = 'async',
    Async_Isr        = 'async/isr',
    Async_Thread     = 'async/thread',
    Await_Until      = 'await',
    Await_Ext        = 'await',
    Await_Forever    = 'await',
    Await_Int        = 'await',
    Await_Wclock     = 'await',
    Break            = 'break',
    Code             = 'code',
    Continue         = 'continue',
    Data             = 'data',
    Emit_Evt         = 'emit',
    Emit_ext_req     = 'request',
    EOC              = 'end of code',
    EOF              = 'end of file',
    Escape           = 'escape',
    Every            = 'every',
    Evt              = 'event',
    Ext_Code         = 'external code',
    Ext_Code         = 'external code',
    Ext              = 'external',
    Finalize         = 'finalize',
    If               = 'if',
    Kill             = 'kill',
    Loop             = 'loop',
    Loop_Num         = 'loop',
    Loop_Pool        = 'loop',
    Nat_Block        = 'native block',
    Nat              = 'native',
    Nothing          = 'nothing',
    Par_And          = 'par/and',
    Par_Or           = 'par/or',
    Par              = 'par',
    Watching         = 'watching',
    Throw            = 'throw',
    Catch            = 'catch',
    Pool             = 'pool',
    Prim             = 'primitive',
    Set_Await_many   = 'await',
    Val              = 'value',
    Var              = 'variable',
    Vec              = 'vector',
}

local _N = 0
function AST.node (tag, ln, ...)
    local me
    if tag == '_Stmts' then
        -- "Ct" as a special case to avoid "too many captures" (HACK_1)
        tag = 'Stmts'
        me = setmetatable((...), MT)
    else
        me = setmetatable({ ... }, MT)
    end
    me.n = _N
    AST.ns[me.n] = me
    --me.xxx = debug.traceback()
    _N = _N + 1
    me.ln  = ln
    --me.ln[2] = me.n
    me.tag = tag

    for i,sub in ipairs(me) do
        if AST.is_node(sub) then
            AST.set(me, i, sub)
        end
    end

    return me
end

function AST.depth (me)
    if me.__par then
        return 1 + AST.depth(me.__par)
    else
        return 1
    end
end

function AST.copy (node, ln, keep_n)
    if not AST.is_node(node) then
        return node
    end
    assert(node.tag ~= 'Ref')

    local ret = setmetatable({}, MT)
    local N = (keep_n and node.n) or _N
    if not keep_n then
        _N = _N + 1
    end

    for k, v in pairs(node) do
        if type(k)=='table' and v=='fs' then
            -- skip F's
        elseif type(k) ~= 'number' then
            ret[k] = v
        else
            if AST.is_node(v) then
                AST.set(ret, k, AST.copy(v, ln, keep_n))
                ret[k].ln = ln or ret[k].ln
            else
                ret[k] = AST.copy(v, ln, keep_n)
            end
        end
    end
    ret.n = N

    return ret
end

function AST.is_equal (n1, n2, ignore)
    if ignore and ignore(n1,n2) then
        return true
    elseif n1 == n2 then
        return true
    elseif AST.is_node(n1) and AST.is_node(n2) then
        if n1.tag == n2.tag then
            for i, v in ipairs(n1) do
                if not AST.is_equal(n1[i],n2[i],ignore) then
                    return false
                end
            end
            return true
        else
            return false
        end
    elseif type(n1)=='table' and type(n2)=='table' then
        for k,v in pairs(n1) do
            if n2[k] ~= v then
                return false
            end
        end
        for k,v in pairs(n2) do
            if n1[k] ~= v then
                return false
            end
        end
        return true
    else
        return false
    end
end

--[[
function AST.idx (par, me)
    assert(AST.is_node(par))
    for i, sub in ipairs(par) do
        if sub == me then
            return i
        end
    end
    error'bug found'
end
]]

function AST.get (me, tag, ...)
    local idx, tag2 = ...

    if type(tag) == 'number' then
        if tag > 0 then
            if me.__par then
                return AST.get(me.__par, tag-1, ...)
            else
                return nil
            end
        else
            assert(tag == 0)
            return AST.get(me, ...)
        end
    end

    if not (AST.is_node(me) and (me.tag==tag or tag=='')) then
        return nil, tag, ((AST.is_node(me) and me.tag) or 'none')
    end

    if idx then
        idx = (idx>=0 and idx or (#me+idx+1))
        return AST.get(me[idx], tag2, select(3,...))
    else
        return me
    end
end

function AST.asr (me, tag, ...)
    local ret, tag1, tag2 = AST.get(me, tag, ...)
    if not ret then
        DBG(debug.traceback())
        error('bug (expected: '..tag1..' | found: '..tag2..')')
    end
    return ret
end

function AST.set (par, i, child)
    par[i] = child
    if AST.is_node(child) then
        child.__par = par
        child.__i   = i
    end
end

function AST.insert (par, i, child)
    table.insert(par, i, {})
    AST.set(par, i, child)
    for i, sub in ipairs(par) do
        if AST.is_node(sub) then
            sub.__i = i
        end
    end
end

function AST.remove (par, i)
    table.remove(par, i)
    for i, sub in ipairs(par) do
        if AST.is_node(sub) then
            sub.__i = i
        end
    end
end

function AST.is_par (par, child)
    if par == child then
        return true
    elseif not child.__par then
        return false
    else
        return AST.is_par(par, child.__par)
    end
end

function AST.par (me, pred)
    if type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    if not me.__par then
        return nil
    elseif pred(me.__par) then
        return me.__par, me.__i
    else
        return AST.par(me.__par, pred)
    end
end

function AST.pred_true (me) return true end

function AST.iter (pred, inc)
    if pred == nil then
        pred = AST.pred_true
    elseif type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    local from = (inc and 1) or #STACK
    local to   = (inc and #STACK) or 1
    local step = (inc and 1) or -1
    local i = from
    return function ()
        for j=i, to, step do
            local stmt = STACK[j]
            if pred(stmt) then
                i = j+step
                return stmt
            end
        end
    end
end

--[[
-- doesnt pass b/c of data inheritance
local __detect_same
function AST.check (me, not_first)
    if not_first == nil then
        __detect_same = {}
    end
--AST.dump(AST.root)
    assert(not __detect_same[me], 'AST.check fail: '..me.n..' : '..me.tag)
    __detect_same[me] = true

    for i, sub in ipairs(me) do
        if AST.is_node(sub) then
            AST.check(sub, true)
        end
    end
end
]]

function AST.dump (me, spc, lvl, __notfirst)
    if lvl and lvl==0 then
        return
    end
    spc = spc or 0
    local ks = ''
--[[
    for k, v in pairs(me) do
        if type(k)~='number' then
            v = string.gsub(string.sub(tostring(v),1,8),'\n','\\n')
            ks = ks.. k..'='..v..','
        end
    end
]]
    --local t=0; for _ in pairs(me.aw.t) do t=t+1 end
    --ks = 'n='..(me.aw.n or '?')..',t='..t..',ever='..(me.aw.forever_ and 1 or 0)
    --ks = table.concat(me.trails,'-')
--
--[[
if me.ana and me.ana.pre and me.ana.pos then
    local f = function(v)
                return type(v)=='table'
                            and (type(v[1])=='table' and v[1].id or v[1])
                    or tostring(v)
              end
    local t = {}
    for k in pairs(me.ana.pre) do t[#t+1]=f(k) end
    ks = '['..table.concat(t,',')..']'
    local t = {}
    for k in pairs(me.ana.pos) do t[#t+1]=f(k) end
    ks = ks..'['..table.concat(t,',')..']'
end
]]
--
    --ks = me.ns.trails..' / '..tostring(me.needs_clr)
    local me_str  = string.gsub(tostring(me),       'table: ', '')
    local par_str = string.gsub(tostring(me.__par), 'table: ', '')
    DBG(string.rep(' ',spc)..me.tag..
        ' |'..me_str..'/'..par_str..'['..tostring(me.__i)..']|'..
--[[
        '')
]]
        ' (ln='..me.ln[2]..' n='..me.n..
                           ' p='..(me.__par and me.__par.n or '')..
                           ' trl='..(me.trails and me.trails[1] or '?')..'/'..(me.trails_n or '?')..
                           ' i='..(me.__i or '?')..
                           ' d='..AST.depth(me)..
                           ') '..ks)
    for i, sub in ipairs(me) do
        if AST.is_node(sub) then
            AST.dump(sub, spc+2, lvl and lvl-1)
        else
            DBG(string.rep(' ',spc+2) .. '['..tostring(sub)..']')
        end
    end
end

local function FF (F, str)
    local f = F[str]
    if type(f) == 'string' then
        return FF(F, f)
    end
    assert(f==nil or type(f)=='function')
    return f
end

-------------------------------------------------------------------------------

local function from_to (old, new, t)
    if new and new~=old then
        if t.par then
            AST.set(t.par, t.i, new)
        end
        return true, new
    else
        return false, old
    end
end

local function visit_aux (F, me)
    if me[F] then
        return me
    end

    local pre, mid, pos = FF(F,me.tag..'__PRE'), FF(F,me.tag), FF(F,me.tag..'__POS')
    local bef, aft = FF(F,me.tag..'__BEF'), FF(F,me.tag..'__AFT')

    local chg = false
    local t   = { par=me.__par, i=me.__i }

    if F.Node__PRE then
        local ret, dont = F.Node__PRE(me)
        chg, me = from_to(me, ret, t)
        if chg and (not dont) then
            return AST.visit_fs(me)
        end
    end
    if pre then
        local ret, dont = pre(me)
        chg, me = from_to(me, ret, t)
        if chg and (not dont) then
            return AST.visit_fs(me)
        end
    end

    STACK[#STACK+1] = me

    for i, _ in ipairs(me) do
        if bef then assert(bef(me,me[i],i)==nil) end
        if AST.is_node(me[i]) then
            me[i] = visit_aux(F, me[i], i)
        end
        if aft then assert(aft(me,me[i],i)==nil) end
    end

    if mid then
        assert(mid(me) == nil, me.tag)
    end
    if F.Node then
        assert(F.Node(me) == nil)
    end

    STACK[#STACK] = nil

    if pos then
        local ret, dont = pos(me)
        chg, me = from_to(me, ret, t)
        if chg and (not dont) then
            return AST.visit_fs(me)
        end
    end
     if F.Node__POS then
        local ret, dont = F.Node__POS(me)
        chg, me = from_to(me, ret, t)
        if chg and (not dont) then
            return AST.visit_fs(me)
        end
    end

    me[F] = 'fs'

   return me
end

local fs = {}
function AST.visit (F, node)
    assert(node == nil)
    fs[#fs+1] = F
    return visit_aux(F, AST.root)
end

AST.visit_fs = function (node)
    local ret
    for _, f in ipairs(fs) do
        ret = visit_aux(f, node)
    end
    return ret
end

-------------------------------------------------------------------------------

local function i2l (p)
    return CEU.i2l[p]
end

for tag, patt in pairs(GG) do
    if string.sub(tag,1,2) ~= '__' then
        GG[tag] = m.Cc(tag) * (m.Cp()/i2l) * patt / AST.node
    end
end

local function f (ln, v1, v2, v3, v4, ...)
    --DBG('>>>',ln[2],v1,v2,v3,v4,...)
    if v1 == 'pre' then
        local x = ''
        if v2=='+' or v2=='-' or v2=='&' or v2=='*' then
            x = '1' -- unary +/-
        end
        return AST.node('Exp_'..x..v2, ln, v2, f(ln,v3,v4,...))
    elseif v2 == 'pos' then
        return f(ln, AST.node('Exp_'..v3,ln,v3,v1,v4), ...)
    elseif v2 then
        -- binary
        return f(ln, AST.node('Exp_'..v2,ln,v2,v1,v3), v4, ...)
    else
        -- primary
        return v1
    end
end

local __exps = { '', '_Loc' }
for _, id in ipairs(__exps) do
    for i=0, 12 do
        if i < 10 then
            i = '0'..i
        end
        local tag = '__'..i..id
        if GG[tag] then
            GG[tag] = (m.Cp()/i2l) * GG[tag] / f
        end
    end
end

AST.root = m.P(GG):match(CEU.source)
AST.visit({})

end

    DBG,ASR = DBG2,ASR2
    
do
ADJS = {
    stmts = nil,
}

local node = AST.node

local Pre_Stmts

F = {
    ['1__PRE'] = function (me)
        local stmts, eof = unpack(me)
        AST.asr(stmts, 'Stmts')
        ADJS.stmts = stmts

        --  Stmts
        --      to
        --  Block
        --      Stmts
        --          nats
        --          Lock
        --          Var             -- _ret
        --          Set
        --              ret
        --              Do
        --                  Block
        --                      Stmts
        --                          _Lua_Do
        --                              Stmts   -- pre do (Pre_Stmts)
        --                              Stmts   -- orig

        Pre_Stmts = node('Stmts', me.ln)
        AST.insert(stmts, 1, Pre_Stmts)

        local nats = node('Stmts', me.ln,
                        node('Nat', me.ln,
                            false,
                            node('Type', me.ln,
                                node('ID_prim', me.ln, '_')),
                            '_{}'),
                        node('Nat', me.ln,
                            false,
                            'plain',
                            '_char'),
                        node('Nat', me.ln,
                            'nohold',
                            node('Type', me.ln,
                                node('ID_prim', me.ln, '_')),
                            '_ceu_assert'))
        nats[3].is_predefined = true

        local ret = node('Var', me.ln,
                        false,
                        node('Type', me.ln,
                            node('ID_prim', me.ln, 'int')),
                        '_ret')
        ret.is_implicit = true

        local lock = node('Data', me.ln, 'Lock', false,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('_Var_set', me.ln,
                                    false,
                                    false,
                                    {},
                                    node('Type', me.ln,
                                        node('ID_prim', me.ln, 'bool')),
                                    'is_locked',
                                    {node('_Set_Exp',me.ln,
                                        node('BOOL',me.ln,'0'))}
                                    ),
                                node('_Evt_set', me.ln,
                                    false,
                                    node('Type', me.ln,
                                        node('ID_prim', me.ln, 'none')),
                                    'ok_unlocked',
                                    false))))
        lock.is_predefined = true

        local exception do
            -- always define "Exception" to generate "support is disabled" message
            --if CEU.opts.ceu_features_exception then
                local base = node('Data', me.ln, 'Exception', false,
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('_Var_set', me.ln,
                                            false,
                                            false,
                                            {},
                                            node('Type', me.ln,
                                                node('ID_nat', me.ln, '_char'),
                                                '&&'),
                                            'message',
                                            {node('_Set_Exp',me.ln,
                                                node('STRING',me.ln,'"unspecified message"'))}
                                            ))))
                base.is_predefined = true

                local lua do
                    if CEU.opts.ceu_features_lua then
                        lua = node('Data', me.ln, 'Exception.Lua', false,
                                node('Block', me.ln, node('Stmts', me.ln)))
                        lua.is_predefined = true
                    else
                        lua = node('Nothing', me.ln)
                    end
                end
                exception = node('Stmts', me.ln, base, lua)
            --else
                --exception = node('Nothing', me.ln)
            --end
        end

        local lua do
            if CEU.opts.ceu_features_lua then
                lua = node('Stmts', me.ln,
                        node('_Lua_Do', me.ln,
                            '[]',
                            node('Block', me.ln,
                                stmts)))
            else
                lua = stmts
            end
        end

        AST.root =
            node('ROOT', me.ln,
                node('Block', me.ln,
                    node('Stmts', me.ln,
                        nats,
                        lock,
                        exception,
                        ret,
                        node('_Set', me.ln,
                            node('Loc', me.ln,
                                node('ID_int', me.ln, '_ret')),
                            node('_Set_Do', me.ln,
                                node('Do', me.ln,
                                    true, false,
                                    node('Block', me.ln, lua)))),
                        eof)))
        return AST.root
    end,
    _Stmts__PRE = function (me)
error'TODO: luacov never executes this?'
        local t = unpack(me)
        return node('Stmts', me.ln, unpack(t))
    end,
    _Dopre__POS = function (me)
        AST.set(Pre_Stmts, #Pre_Stmts+1, AST.asr(me,'', 1,'Block', 1,'Stmts'))
        return node('Nothing', me.ln)
    end,

    _Do__PRE = function (me)
        local _,vars = unpack(me)
        if vars == true then
            AST.set(me, 2,
                node('Var_List', me.ln))
        end
        me.tag = 'Do'
    end,

    _Spawn_Block__PRE = function (me)
        local vars, blk = unpack(me)
        if not AST.get(vars,'Block') then
            if vars then
                return node('_Spawn_Block', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('_Do', me.ln, true, vars, blk))))
            else
                AST.remove(me,1)
            end
        end
    end,

-------------------------------------------------------------------------------

    -- TODO: "__PRE" because of "continue"
    _If__PRE = function (me)
        local cnd, t, f_or_more = unpack(me)
        if #me == 3 then
            -- if <cond> then <t> else <f> end
            me.tag = 'If'
            if f_or_more == false then
                AST.set(me, 3, node('Block', me.ln,
                                node('Stmts', me.ln)))
            end
            return      -- has no "else/if" and has "else" clause
        else
            return node('If', me.ln,
                    cnd,
                    t,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('_If', me.ln,
                                f_or_more,
                                select(4,unpack(me))))))
        end
    end,

-------------------------------------------------------------------------------

    _Data_simple__PRE = '_Data_block__PRE',
    _Data_block__PRE = function (me)
        local id, enum = unpack(me)
        return node('Data', me.ln,
                id, enum,
                node('Block', me.ln,
                    node('Stmts', me.ln,
                        unpack(me, 3))))
    end,

    _Code_Pars__POS = function (me)
        me.tag = 'Stmts'
    end,

    _Code_impl__PRE = '_Code_proto__PRE',
    _Code_proto__PRE = function (me)
        local mods, id, ins, mid, out, throws, blk, eoc = unpack(me)
        me.tag = 'Code'

        mid = mid or node('_Code_Pars', me.ln)

        local Type = AST.get(out,'Code_Ret', 1,'Type')
        local is_void do
            if Type then
                local ID_prim,mod = unpack(Type)
                is_void = (ID_prim.tag=='ID_prim' and ID_prim[1]=='none' and (not mod))
            end
        end

        if Type then
            if is_void then
                out = node('Var_', me.ln, false, AST.copy(Type), '_ret')
                    -- TODO: HACK_5 (Var_)
            else
                out = node('Var', me.ln, false, AST.copy(Type), '_ret')
            end
            out.is_implicit = true
        else
            out = node('Nothing', me.ln)
        end

        local set_or_do = node('Do', me.ln,
                            (Type and true) or node('ID_any', me.ln),
                            false,
                            node('Block', me.ln,
                                node('Stmts', me.ln,
                                    ins,
                                    node('Block', me.ln,
                                        node('Stmts', me.ln,
                                            mid,
                                            (blk or node('Stmts',me.ln)))))))

        if Type and (not is_void) then
            set_or_do = node('_Set', me.ln,
                            node('Loc', me.ln,
                                node('ID_int', me.ln, '_ret')),
                            node('_Set_Do', me.ln,
                                set_or_do))
        end

        local ret = node('Code', me.ln, mods, id, throws,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('Code_Ret', me.ln,
                                    out),
                                set_or_do)),
                        eoc)
        ret.is_impl = (blk ~= false)

        AST.par(ins,'Block').__adjs_1 = true
        AST.par(mid,'Block').__adjs_2 = true
        if blk then
            blk.__adjs_3 = true
        end
        ret.__adjs_1 = AST.par(ins,'Block')
        ret.__adjs_2 = AST.par(mid,'Block')
        ret.__adjs_3 = blk

        return ret
    end,

-------------------------------------------------------------------------------

    _Loop__PRE = function (me)
        local max, body = unpack(me)

        local max_dcl = node('Nothing', me.ln)
        local max_ini = node('Nothing', me.ln)
        local max_inc = node('Nothing', me.ln)
        local max_chk = node('Nothing', me.ln)
        if max then
            max_chk = node('Stmt_Call', me.ln,
                        node('Exp_call', me.ln,
                            'call',
                            node('Loc', me.ln,
                                node('ID_nat', me.ln,
                                    '_ceu_assert')),
                            node('List_Exp', me.ln,
                                node('Exp_<', me.ln, '<',
                                    node('Loc', me.ln,
                                        node('ID_int', me.ln, '__max_'..me.n)),
                                    AST.copy(max)),
                                node('STRING', me.ln,
                                    '"`loop` overflow"'))))
        end

        local Stmts = AST.asr(body,'Block', 1,'Stmts')
        local i = (from_loop_num and 2 or 1)  -- after lim_chk
        AST.insert(Stmts, i,        max_chk)
        AST.insert(Stmts, #Stmts+1, max_inc)

        return node('Block', me.ln,
                node('Stmts', me.ln,
                    max_dcl,
                    max_ini,
                    node('Loop', me.ln, max, body)))
    end,
    _Loop_Num__PRE = function (me)
        local max, i, range, body = unpack(me)

        -- loop i do end
        -- loop i in [0 -> _] do end
        if not range then
            range = node('Loop_Num_Rage', me.ln,
                        '[',
                        node('NUMBER', me.ln, 0),
                        '->',
                        node('ID_any', me.ln),
                        ']',
                        false)
        end
        local lb, fr, dir, to, rb, step = unpack(range)

        -- loop i in [...] do end
        -- loop i in [...], 1 do end
        if step == false then
            step = node('NUMBER', me.ln, 1)
        end

        fr.__adj_step_mul = 0
        to.__adj_step_mul = 0

        -- loop i in [0 <- 10], 1 do end
        -- loop i in [10 -> 1], -1 do end
        if dir == '<-' then
            fr, to = to, fr
            step = node('Exp_1-', me.ln, '-', step)

            -- loop i in [... 10[ do end
            -- loop i in [... 10-1] do end
            if rb == '[' then
                fr.__adj_step_mul = 1
            end
            if lb == ']' then
                to.__adj_step_mul = 1
            end
        else
            --step = node('Exp_1+', me.ln, '+', step)

            -- loop i in ]0 ...] do end
            -- loop i in [0+1 ...] do end
            if lb == ']' then
                fr.__adj_step_mul = 1
            end
            if rb == '[' then
                to.__adj_step_mul = 1
            end
        end

        local i_dcl = node('Nothing', me.ln)
        if AST.is_node(i) then
            AST.asr(i, 'ID_any')
            i = '__i_'..me.n    -- invent an ID not referenceable
            i_dcl = node('Var', me.ln,
                        false,
                        node('Type', me.ln,
                            node('ID_prim', me.ln, 'int')),
                        i)
        end

        i = node('ID_int', me.ln, i)

        return node('Block', me.ln,
                node('Stmts', me.ln,
                    AST.copy(i_dcl),
                    node('Loop_Num', me.ln,
                        max,
                        i,
                        node('Loop_Num_Range', me.ln, fr, dir, to, step),
                        body)))
    end,

    _Every__PRE = function (me)
        local to, awt, Y, body = unpack(me)

        --[[
        --      every a=EXT do ... end
        -- becomes
        --      loop a=await EXT; ... end
        --]]

        local dcls = node('Stmts', me.ln)
        local set_awt
        if to then
            if awt.tag=='Await_Ext' or awt.tag=='Await_Int' then
                set_awt = node('Set_Await_many', me.ln, awt, to)
            else
                set_awt = node('Set_Await_one', me.ln, awt, to)
            end
        else
            set_awt = awt
        end

        return node('Every', me.ln,
                node('Loop', me.ln,
                    false,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            dcls,
                            set_awt,
                            Y,
                            body))))
    end,

    _Lock__PRE = function (me)
        local exp, body = unpack(me)
        local exp = unpack(exp)
        return node('Do', me.ln,
                node('ID_any', me.ln),
                false,
                node('Block', me.ln,
                    node('Stmts', me.ln,
                        node('Loop', me.ln,
                            false,
                            node('Block', me.ln,
                                node('Stmts', me.ln,
                                    node('If', me.ln,
                                        node('Loc', me.ln,
                                            node('Exp_.', me.ln,
                                                '.',
                                                AST.copy(exp),
                                                'is_locked')),
                                        node('Block', me.ln,
                                            node('Stmts', me.ln,
                                                node('Await_Until', me.ln,
                                                    node('Await_Int', me.ln,
                                                        node('Loc', me.ln,
                                                            node('Exp_.', me.ln,
                                                                '.',
                                                                AST.copy(exp),
                                                                'ok_unlocked')),
                                                        node('Y', me.ln, '')),
                                                    false))),
                                        node('Block', me.ln,
                                            node('Stmts', me.ln,
                                                node('Break', me.ln))))))),
                        node('Set_Exp', me.ln,
                            node('BOOL', me.ln, '1'),
                            node('Loc', me.ln,
                                node('Exp_.', me.ln,
                                    '.',
                                    AST.copy(exp),
                                    'is_locked'))),
                        node('_Finalize', me.ln,
                            false,
                            false,
                            node('Block', me.ln,
                                node('Stmts', me.ln,
                                    node('Set_Exp', me.ln,
                                        node('BOOL', me.ln, '0'),
                                        node('Loc', me.ln,
                                            node('Exp_.', me.ln,
                                                '.',
                                                AST.copy(exp),
                                                'is_locked'))),
                                    node('Emit_Evt', me.ln,
                                        node('Loc', me.ln,
                                            node('Exp_.', me.ln,
                                                '.',
                                                AST.copy(exp),
                                                'ok_unlocked')),
                                        node('_Emit_ps', me.ln, false)))),
                            false,
                            false),
                        body)))
    end,

-------------------------------------------------------------------------------

    _Set__PRE = function (me)
        local to,set = unpack(me)

        if set.tag == '_Set_Watching' then
            --  _Set
            --      to
            --      _Set_Watching
            --          _Watching
            --              Await_*
            --              Block
            -->>>
            --  _Watching
            --      _Set
            --          to
            --          _Set_Await_many
            --              Await_*
            --      Block
            local watching = AST.asr(unpack(set),'_Watching')
            local awt = unpack(watching)
            local tag do
                if awt.tag=='Await_Ext' or awt.tag=='Await_Int' then
                    tag = '_Set_Await_many'
                else
                    tag = '_Set_Await_one'
                end
            end
            AST.set(me, 2, node(tag, me.ln, awt))
            me[2].__adjs_is_watching = true
            AST.set(watching, 1, me)
            return watching

        elseif set.tag == '_Set_Await_many' then
            local unt = unpack(set)
            if unt.tag == 'Await_Until' then
                local awt = unpack(unt)
                AST.set(unt, 1, me)
                AST.set(set, 1, awt)
                return unt
            end

            -- x = await Ff(...)
            --  to
            -- x = (var&? Ff f; f=spawn Ff(...); await f;)
            --  to
            -- var&? Ff f; f=spawn Ff(...); x=await f;
            if AST.get(set,'', 1,'Stmts', 3,'Await_Int') then
                local stmts = unpack(set)
                local dcl, spw, awt = unpack(set)
                AST.set(stmt, 3,
                    node('_Set', me.ln,
                        to,
                        awt))
                return stmts
            end

        elseif set.tag == '_Set_Await_one' then
            local awt = unpack(set)
            if awt.tag == '_Abs_Await' then
                awt = F._Abs_Await__PRE(awt)
                AST.set(awt[1], 3,
                    node('_Set', me.ln,
                        to,
                        node('_Set_Await_many', me.ln,
                            awt[1][3])))
                return awt
            end
        end

        -----------------------------------------------------------------------

        if set.tag == '_Set_Do' then
            -- set to "to" happens on "escape"
            local do_ = unpack(set)
            AST.set(do_, #do_+1, to)
            return do_
        else
            --  _Set
            --      to
            --      _Set_*
            --          fr
            -->>>
            --  Set_*
            --      fr
            --      to

            assert(#set==1 or #set==2, 'bug found')
            set.tag = string.sub(set.tag,2)
            AST.set(set, 2, to)

            -- a = &b   (Set_Exp->Set_Alias)
            if set.tag=='Set_Exp' and set[1].tag=='Exp_1&' then
                set.tag = 'Set_Alias'
            end

            return set
        end
    end,

    Set_Await_many__PRE = function (me)
        local _,var,_ = unpack(me)
        if var.tag == 'Loc' then
            AST.set(me, 2, node('List_Loc', var.ln, var))
        end
    end,

    _Abs_Await__PRE = function (me)
        -- await Ff(...)
        --  to
        -- do
        --   var&? Ff f;
        --   f = spawn Ff(...)
        --   await f;
        -- end
        local _,abs = unpack(me)
        local ret = node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Var', me.ln,
                                '&?',
                                node('Type', me.ln,
                                    AST.copy(AST.asr(abs,'Abs_Cons',2,'ID_abs'))),
                                '_spw_'..me.n),
                            node('_Set', me.ln,
                                node('Loc', me.ln,
                                    node('ID_int', me.ln,
                                        '_spw_'..me.n)),
                                node('_Set_Abs_Spawn', me.ln,
                                    node('Abs_Spawn', me.ln,
                                        unpack(me)))),
                            node('Await_Int', me.ln,
                                node('Loc', me.ln,
                                    node('ID_int', me.ln,
                                        '_spw_'..me.n)))))
        AST.asr(ret,'Block').__adjs_is_abs_await = true
        AST.asr(ret,'Block', 1,'Stmts', 1,'Var').__adjs_is_abs_await = true
        AST.asr(ret,'Block', 1,'Stmts', 3,'Await_Int').__adjs_is_abs_await = true
        return ret
    end,

    _Escape__PRE = function (me)
        local _, fr = unpack(me)

        local set = node('Set_Exp', me.ln,
                        fr,
                        node('TODO', me.ln, 'escape', me))   -- see dcls.lua
        -- a = &b   (Set_Exp->Set_Alias)
        if fr and fr.tag=='Exp_1&' then
            set.tag = 'Set_Alias'
        end

        me.tag = 'Escape'
        me[2] = nil
        return node('Stmts', me.ln, set, me)
    end,

    _Catch__PRE = function (me)
        local loc, block = unpack(me)

        if block.tag ~= 'Block' then
            local ret = node('_Catch', me.ln, unpack(me, 2))
            ret[#ret] = node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('_Catch', me.ln,
                                    loc,
                                    me[#me])))
            return ret
        end

        return node('Catch', me.ln,
                    loc,
                    node('Par_Or', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('Await_Exception', me.ln))),
                        block))
    end,

    _Watching__PRE = function (me)
        local watch, block = unpack(me)

        -- watching Ff()->(), Gg()->(), ...
        if block.tag ~= 'Block' then
            return node('_Watching', me.ln, watch,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('_Watching', me.ln,
                                unpack(me,2)))))
        end

        return node('Watching', me.ln,
                node('Par_Or', me.ln,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            watch)),
                    block))
    end,

-------------------------------------------------------------------------------

    Vec_Cons__POS = function (me)
        local Set = AST.par(me,'Set_Abs_Val')
        if not Set then
            return
        end

-->> TODO: join
        local T = { }
        do
            local old = me
            local new = AST.par(me, 'Abs_Cons')

            while new do
                assert(AST.asr(new,'', 3,'Abslist', old.__i,'') == old)
                table.insert(T, 1, old.__i)
                old = new
                new = AST.par(new, 'Abs_Cons')
            end
        end
--|| TODO: join
        local exp
        do
            local base = AST.asr(Set,'', 2,'Loc', 1,'')
            local ret = AST.copy(base)
            for _, idx in ipairs(T) do
                ret = node('Exp_.', me.ln, '.', ret, idx)
            end
            exp = node('Loc', me.ln, ret)
        end
--<< TODO: join

        Set.__adjs_sets = Set.__adjs_sets or node('Stmts', me.ln)
        AST.insert(Set.__adjs_sets, #Set.__adjs_sets+1,
                    node('Set_Vec', me.ln,
                        me,                -- see dcls.lua
                        exp))

        return node('ID_any', me.ln)
    end,

    Set_Abs_Val__POS = function (me)
        if me.__adjs_sets then
            local ret = node('Stmts', me.ln, me, me.__adjs_sets)
            me.__adjs_sets = nil
            return ret
        end
    end,

-------------------------------------------------------------------------------

    _Lua = function (me)
        --[[
        -- a = @a ; b = @b
        --
        -- __ceu_1, __ceu_2 = ...
        -- a = __ceu_1 ; b = __ceu_2
        --]]
        local params = {}
        local code = {}
        local names = {}
        for _, v in ipairs(me) do
            if type(v) == 'table' then
                params[#params+1] = v
                code[#code+1] = '_ceu_'..#params..' '
                names[#names+1] = code[#code]
            else
                code[#code+1] = v;
            end
        end

        -- me.ret:    node to assign result ("_Set_pre")
        -- me.params: @v1, @v2
        -- me.lua:    code as string

        if AST.par(me,'Set_Lua') or AST.par(me,'Set_Vec') then
           table.insert(code, 1, 'return ')
        end

        me.params = params
        if #params == 0 then
            me.lua = table.concat(code,'')
        else
            me.lua = table.concat(names,', ')..' = ...\n'..
                     table.concat(code,'')
        end

        me.tag = 'Lua'
    end,

-------------------------------------------------------------------------------

    __dcl_set__PRE = function (me)
        local is_alias, mods, dim, tp, id, set
        local tag = string.sub(me.tag,2,-5)

        -- convert from 'Var' to 'Vec'
        if tag == 'Var' then
            local _,dim,is_ring,mods = unpack(me)
            if dim then
                --ASR(not mods, me, 'TODO')
                AST.remove(me, 4)
                AST.remove(me, 3)
                me.tag = 'Vec'
                tag    = 'Vec'
                me.is_ring = is_ring
            else
                AST.remove(me, 2)
            end
        end

        if tag=='Var' or tag=='Pool' or tag=='Vec' then
            is_alias, dim_or_mods, tp, id, set = unpack(me)
            AST.set(me, 2, tp)
            AST.set(me, 3, id)
            AST.set(me, 4, dim_or_mods)
            AST.set(me, 5, nil)
        else
            is_alias, tp, id, set = unpack(me)
            AST.set(me, 4, nil)
        end

        if set then
            set = node('_Set', me.ln,
                    node('Loc', me.ln,
                        node('ID_int', me.ln, id)),
                    unpack(set))
        end

        me.tag = tag
        return node('Stmts', me.ln, me, set or nil)
    end,

    _Var_set__PRE = '__dcl_set__PRE',
    _Pool_set__PRE = '__dcl_set__PRE',
    _Evt_set__PRE = function (me)
        local _,tp = unpack(me)
        if tp.tag == 'Type' then
            AST.set(me, 2, node('_Typelist',me.ln,tp))
        end
        return F.__dcl_set__PRE(me)
    end,

    -- single declaration with multiple ids
    --      -> multiple declarations with single ids
    _Nats__PRE = function (me)
        local mod = unpack(me)
        local ids = { unpack(me, 2) }

        local ret = node('Stmts', me.ln)
        for i,id in ipairs(ids) do
            AST.set(ret, #ret+1,
                node('Nat', me.ln, mod,
                    node('Type', me.ln,
                        node('ID_prim', me.ln, '_')),
                    id))
        end

        return ret
    end,

-------------------------------------------------------------------------------

    _Var_set_fin__PRE = function (me)
        local alias, Type, __ID_int = unpack(me)
        me.tag = '_Var_set_fin_X'
        return node('Stmts', me.ln,
                node('Var', me.ln,
                    alias,
                    Type,
                    __ID_int),
                me)
    end,

-------------------------------------------------------------------------------

    -- Type -> Typelist
    -- input int X  -> input (int) X;
    -- input void X -> input () X;
    Ext__PRE = 'Evt__PRE',
    Evt__PRE = function (me)
        local class,Type,x = unpack(me)
        if class == 'output' then
            me.are_aliases = {}
            if Type and Type.tag=='_Typelist_amp' then
                for i,T in ipairs(Type) do
                    local is_alias,tp,id = unpack(T)
                    ASR(is_alias==false or is_alias=='&')
                    ASR(tp.tag == 'Type')
                    AST.set(Type, i, tp)
                    me.are_aliases[i] = is_alias
                    do  -- reject none with id/alias
                        local ID_prim,mod = unpack(tp)
                        local is_none = (ID_prim.tag=='ID_prim' and ID_prim[1]=='none' and (not mod))
                        if is_none then
                            ASR(not (id or is_alias), me, 'invalid type')
                        end
                    end
                    if AST.par(me, 'Ext_impl') then
                        tp.__adjs_var = { is_alias,id }
                    end
                end
                Type.tag = '_Typelist'
            else
                ASR(Type==false or Type=='&')
                ASR(x.tag=='Type')
                local is_alias
                is_alias, Type = Type, x

                do  -- reject none with id/alias
                    local ID_prim,mod = unpack(Type)
                    local is_none = (ID_prim.tag=='ID_prim' and ID_prim[1]=='none' and (not mod))
                    if is_none then
                        ASR(not is_alias, me, 'invalid type')
                    end
                end
                me.are_aliases[1] = is_alias
                table.remove(me, 2)
            end
        end

        if Type.tag == 'Type' then
            AST.set(me, 2, node('_Typelist', me.ln, Type))
        end
    end,

    Ext_impl__POS = function (me)
        local ext, body = unpack(me)
        ext.__adjs_is_impl = true
        local _, list = unpack(ext)

        local stmts = node('Stmts', me.ln)
        for _, tp in ipairs(list) do
            local is_alias, id = unpack(assert(tp.__adjs_var))
            local var = node('Var', me.ln, is_alias, AST.copy(tp), id)
            AST.set(stmts, #stmts+1, var)
        end

        local do_ = node('Do', me.ln, true, false)
        AST.set(do_, #do_+1, body)

        AST.set(stmts, #stmts+1, do_)
        AST.set(me, 2, node('Block', me.ln, stmts))
    end,

    _List_Exp_Any = function (me)
        me.tag = 'List_Exp'
    end,

    _Emit_ps__PRE = function (me)
        local exp = unpack(me)
        if exp and (exp.tag=='List_Exp' or exp.tag=='_List_Exp_Any') then
            return exp
        end
        local ret = node('List_Exp', me.ln)
        if exp then
            AST.set(ret, 1, exp)
        end
        return ret
    end,
    Exp_call = function (me)
        local _,_, ps = unpack(me)
        if ps and ps.tag == 'List_Exp' then
            -- ok
        else
            AST.set(me, 3, node('List_Exp', me.ln))
            if ps then
                AST.set(me[3], 1, ps)
error'TODO: luacov never executes this?'
            end
        end
    end,

    _Typelist__PRE = function (me)
        me.tag = 'Typelist'
        local Type, snd = unpack(me)
        local ID_prim, mod = unpack(Type)
        if (not snd) and
           ID_prim.tag=='ID_prim' and ID_prim[1]=='none' and (not mod)
        then
            AST.remove(me,1)
        end
    end,

-------------------------------------------------------------------------------

    _Nat_Exp__PRE = function (me)
        me.tag = 'ID_nat'
        AST.insert(me, 1, '_{}')
    end,

    ['Exp_:__PRE'] = function (me)
        local op, e, field = unpack(me)
        return node('Exp_.', me.ln, '.',
                node('Exp_1*', me.ln, '*', e),
                field)
    end,

    ID_prim = function (me)
        me.tag = 'ID_prim'
        if me[1]=='on/off' or me[1]=='yes/no' then
            me[1] = 'bool'
        elseif me[1]=='integer' then
            me[1] = 'int'
        end
    end,

    NUMBER = function (me)
        local v = unpack(me)
        me[1] = ASR(tonumber(v), me, 'malformed number')
    end,
}

AST.visit(F)

end

    
do
TYPES = {
}

function TYPES.noc (str)
    str = string.gsub(str, '%.',  '__dot__')
    str = string.gsub(str, '%,',  '__comma__')
    str = string.gsub(str, '%?',  '__ask__')
    str = string.gsub(str, '%&&', '__ptr__')
    str = string.gsub(str, '%(',  '__lpar__')
    str = string.gsub(str, '%)',  '__rpar__')
    return str
end

function TYPES.n2uint (n)
    if n < 2^8 then
        return 'u8'
    elseif n < 2^16 then
        return 'u16'
    elseif n < 2^32 then
        return 'u32'
    end
    error'out of bounds'
end

local function types_id (tp)
    local ID = unpack(tp)
    if ID.dcl and (ID.dcl.tag=='Code' or ID.dcl.tag=='Data') then
        return ID.dcl.id_ or 'TODO'
    else
        local id = unpack(ID)
        return id
    end
end

function TYPES.tostring (tp)
    if tp == true then
        return '*'
    elseif tp.tag == 'Typelist' then
        local ret = {}
        for i, tp in ipairs(tp) do
            ret[i] = TYPES.tostring(tp)
        end
        return '('..table.concat(ret,',')..')'
    end
    return types_id(tp) .. table.concat(tp,'',2)
end

function TYPES.dump (tp)
    DBG('TYPE', TYPES.tostring(tp))
end

function TYPES.toc (tp)
    assert(tp.tag == 'Type')
    local ID = unpack(tp)

    local pre = ''
    if TYPES.check(tp,'?') then
        pre = 'tceu_opt_'
    elseif ID.tag == 'ID_abs' then
        if ID.dcl.tag == 'Data' then
            pre = 'tceu_data_'
        else
            pre = 'tceu_code_mem_'
        end
    end

    local id = types_id(tp)
    id = string.gsub(id,'^_', '')
    id = TYPES.noc(id) -- data A.B -> A_B

    local mods = {}
    for i=2, #tp do
        local mod = tp[i]
        if mod == '&&' then
            if TYPES.check(tp,'?') then
                mod = '__ptr__'
            else
                mod = '*'
            end
        elseif mod == '?' then
            mod = ''
        end
        mods[i-1] = mod
    end

    return pre..id..table.concat(mods)
end

function TYPES.new (me, id, ...)
    local ID = (string.sub(id,1,1)==string.sub(string.upper(id),1,1) and
                'ID_abs' or 'ID_prim')
    return AST.node('Type', me.ln,
            AST.node(ID, me.ln,
                id),
            ...)
end

function TYPES.get (tp, n)
    assert(tp.tag == 'Type')
    tp = AST.copy(tp)
    for i=n+1, #tp do
        tp[i] = nil
    end
    return tp
end

function TYPES.pop (tp, mod)
    assert(tp.tag == 'Type')
    local v = tp[#tp]
    if mod and v~=mod then
        return tp
    end
    tp = AST.copy(tp)
    tp[#tp] = nil
    return tp
end

function TYPES.push (tp,v)
    assert(tp.tag == 'Type')
    tp = AST.copy(tp)
    tp[#tp+1] = v
    return tp
end

function TYPES.is_equal (tp1, tp2)
    assert(tp1.tag=='Type' and tp2.tag=='Type')
    if #tp1 ~= #tp2 then
        return false
    end
    for i=1, #tp1 do
        local v1, v2 = tp1[i], tp2[i]
        if i == 1 then
            v1, v2 = unpack(v1), unpack(v2)
        end
        if v1 ~= v2 then
            return false
        end
    end
    return true
end

function TYPES.check (tp, ...)
    if tp.tag == 'Typelist' then
        return false
    end
    assert(tp.tag == 'Type')

    local E = { ... }
    local j = 0
    for i=0, #E-1 do
        local J = #tp-j
        local v = tp[J]
        if J == 1 then
            assert(AST.is_node(v))
            v = unpack(v)
        end
        if v ~= E[#E-i] then
            return false
        end
        j = j + 1
    end
    return tp[#E]
end

function TYPES.is_num (tp)
    assert(tp.tag == 'Type')
    local blk = AST.asr(AST.root,'', 1,'Block')
    local dcl = DCLS.get(blk, types_id(tp), true)
    return TYPES.is_nat(tp)
        or dcl and (dcl.prim and dcl.prim.is_num and TYPES.check(tp,dcl.id))
end
function TYPES.is_int (tp)
    assert(tp.tag == 'Type')
    local blk = AST.asr(AST.root,'', 1,'Block')
    local dcl = DCLS.get(blk, types_id(tp), true)
    return TYPES.is_nat(tp)
        or dcl and (dcl.prim and dcl.prim.is_int and TYPES.check(tp,dcl.id))
end
function TYPES.is_nat (tp)
    assert(tp.tag == 'Type')
    local blk = AST.asr(AST.root,'', 1,'Block')
    local dcl = DCLS.get(blk, types_id(tp), true)
    return dcl and (dcl.tag=='Nat' or dcl.id=='_') and TYPES.check(tp,dcl.id)
        -- _char    yes
        -- _char&&  no
end
function TYPES.is_nat_plain (tp)
    assert(tp.tag == 'Type')
    if not TYPES.is_nat(tp) then
        return false
    end
    local ID_nat = AST.get(tp,'', 1,'ID_nat')
    if ID_nat then
        local mod = unpack(ID_nat.dcl)
        if mod == 'plain' then
            return true
        end
    end
    return false
end
function TYPES.is_nat_not_plain (tp)
    assert(tp.tag == 'Type')
    if not TYPES.is_nat(tp) then
        return false
    end
    local ID_nat = AST.get(tp,'', 1,'ID_nat')
    if ID_nat then
        local mod = unpack(ID_nat.dcl)
        if mod == 'plain' then
            return false
        end
    end
    return true
end

function TYPES.ID_plain (tp)
    return #tp==1 and tp[1]
end

function TYPES.abs_dcl (tp,kind)
    --assert(kind, 'bug found')
    local ID = TYPES.ID_plain(tp)
    return ID and ID.dcl and
            ((kind==nil and ID.dcl.tag=='Code' or ID.dcl.tag=='Data') or ID.dcl.tag==kind) and
                ID.dcl
end

do
    local __contains_num = {
        -- TODO: should 'int' be bottom?
        { 'r64','r32','real','int' },
        { 'u64','u32','u16','u8','int' },
        { 'usize','uint','int' },
        { 'ssize','int' },
        { 'ssize','usize' },
        { 's64','s32','s16','s8','int' },
        { 'int','byte','int' },
    }
    local function contains_num (id1, id2)
        for _, t in ipairs(__contains_num) do
            for i=1,#t do
                local t1 = t[i]
                if t1 == id1 then
                    for j=i,#t do
                        local t2 = t[j]
                        if t2 == id2 then
                            return true
                        end
                    end
                end
            end
        end
        return false
    end

    local function contains_data (ID_abs_1, ID_abs_2)
        local id1 = unpack(ID_abs_1)
        local id2 = unpack(ID_abs_2)
        return (string.find(id2..'.',id1..'.',1,true) == 1)
    end

    function TYPES.contains (tp1, tp2, is_alias)
        if tp1==true or tp2==true then
            return true
        end

        if tp1.tag=='Typelist' or tp2.tag=='Typelist' then
            if tp1.tag=='Typelist' and tp2.tag=='Typelist' then
                if #tp1 == #tp2 then
                    for i=1, #tp1 do
                        if not TYPES.contains(tp1[i],tp2[i],is_alias) then
                            return false
                        end
                    end
                    return true
                end
            end
            return false
        end

        if TYPES.check(tp1,'?') then
            tp1 = TYPES.pop(tp1)
            if TYPES.check(tp2,'?') then
                tp2 = TYPES.pop(tp2)
            end
        end

        local tp1_is_nat = TYPES.is_nat(tp1)
        local tp2_is_nat = TYPES.is_nat(tp2)

        local tp1_ID = TYPES.ID_plain(tp1)
        local tp2_ID = TYPES.ID_plain(tp2)

-- EQUAL TYPES
        if TYPES.is_equal(tp1, tp2) then
            return true

-- DATA vs DATA
        elseif tp1_ID and tp1_ID.tag=='ID_abs' and
               tp2_ID and tp2_ID.tag=='ID_abs'
        then
            return contains_data(tp1_ID, tp2_ID)

-- VOID <- _
        -- var& void ptr = &_f()
        -- var& void p = &v;
        elseif TYPES.check(tp1,'none') and tp2_ID then
            return true

-- NUMERIC TYPES
        elseif TYPES.is_num(tp1) and TYPES.is_num(tp2) then
            if TYPES.is_nat(tp1) or TYPES.is_nat(tp2) then
                return true
            elseif is_alias then
                return false
            else
                return contains_num(types_id(tp1),types_id(tp2))
            end

-- POINTER TYPES
        elseif (TYPES.check(tp1,'&&') or tp1_is_nat) and
               (TYPES.check(tp2,'&&') or tp2_is_nat)
        then
            if not tp1_is_nat then
                tp1 = TYPES.pop(tp1)
            end
            if not tp2_is_nat then
                tp2 = TYPES.pop(tp2)
            end
            if TYPES.check(tp1,'none') then
                -- none&& <- ?&&
                return true
            elseif TYPES.check(tp2,'null') then
                -- ?&& <- null
                return true
            elseif tp1_is_nat then
                -- _ <- ?&&
                return true
            elseif TYPES.contains(tp1,tp2) then
                return true
            end
        end
        return false
    end

    function TYPES.max (tp1, tp2)
        if TYPES.contains(tp1, tp2) then
            return tp1
        elseif TYPES.contains(tp2, tp1) then
            return tp2
        else
            return nil
        end
    end
end

end

    
do
EXPS = {}

-------------------------------------------------------------------------------

INFO = {}

function INFO.asr_tag (e, cnds, err_msg)
    ASR(e.info, e, err_msg..' : expected location')
    --assert(e.info.obj.tag ~= 'Val')
    local ok do
        for _, tag in ipairs(cnds) do
            if tag == e.info.tag then
                ok = true
                break
            end
        end
    end
    ASR(ok, e, err_msg..' : '..
                'unexpected context for '..AST.tag2id[e.info.tag]
                                         ..' "'..e.info.id..'"')
end

function INFO.copy (old)
    local new = {}
    for k,v in pairs(old) do
        new[k] = v
    end
    return new
end

function INFO.new (me, tag, id, tp, ...)
    if AST.is_node(tp) and (tp.tag=='Type' or tp.tag=='Typelist') then
        assert(not ...)
    else
        assert(type(tp) == 'string')
        tp = TYPES.new(me, tp, ...)
    end
    return {
        id  = id or 'unknown',
        tag = tag,
        tp  = tp,
        --dcl
    }
end

-------------------------------------------------------------------------------

function EXPS.check_tp (me, to_tp, fr_tp, err_msg, is_alias)
    local to_str = TYPES.tostring(to_tp)
    local fr_str = TYPES.tostring(fr_tp)
    ASR(TYPES.contains(to_tp,fr_tp,is_alias), me,
        err_msg..' : types mismatch : "'..to_str..'" <= "'..fr_str..'"')
end

function EXPS.check_tag (me, to_tag, fr_tag, err_msg)
    ASR(to_tag==fr_tag or (to_tag=='Var' and (fr_tag=='Val' or fr_tag=='Nat')), me,
        err_msg..' : types mismatch : "'..to_tag..'" <= "'..fr_tag..'"')
end

function EXPS.check_dim (to, fr)
    if to == '[]' then
        return true
    elseif AST.is_equal(fr,to) then
        return true
    else
        return false
    end
end

EXPS.F = {
    Loc = function (me)
        local e = unpack(me)
        me.info = e.info
    end,

-- IDs

    ID_nat = function (me)
        local id = unpack(me)
        me.info = {
            id  = id,
            tag = me.dcl.tag,
            tp  = me.dcl[2],
            dcl = me.dcl,
        }
    end,

    ID_int = function (me)
        local id = unpack(me)
        me.info = {
            id  = id,
            tag = me.dcl.tag,
            tp  = me.dcl[2],
            dcl = me.dcl,
        }
    end,

    ID_int__POS = function (me)
        local alias = unpack(me.info.dcl)
        if alias ~= '&?' then
            return
        end
        if me.__exps_ok then
            return
        end

        for watching in AST.iter'Watching' do
            local loc = AST.get(watching,'',1,'Par_Or',1,'Block',1,'Stmts',1,'Await_Int',1,'Loc',1,'')
                    or  AST.get(watching,'',1,'Par_Or',1,'Block',1,'Stmts',1,'Set_Await_many',1,'Await_Int',1,'Loc',1,'')
            if loc then
                if loc.tag=='ID_int' and AST.is_par(loc,me) then
                    break
                end
                if loc.info and loc.info.dcl==me.info.dcl then
                    ASR(me.__par.tag~='Exp_!', me, 'invalid operand to `!` : found enclosing matching `watching`')
                    me.__exps_ok = true
                    return AST.node('Exp_!', me.ln, '!', me)
                        -- TODO: inneficient: could access directly
                end
            end
        end
    end,

-- PRIMITIVES

    NULL = function (me)
        me.info = INFO.new(me, 'Val', 'null', 'null', '&&')
    end,

    NUMBER = function (me)
        local v = unpack(me)
        if math.type(tonumber(v)) == 'float' then
            me.info = INFO.new(me, 'Val', v, 'real')
        else
            me.info = INFO.new(me, 'Val', v, 'int')
        end
    end,

    BOOL = function (me)
        me.info = INFO.new(me, 'Val', me[1], 'bool')
    end,

    STRING = function (me)
        me.info = INFO.new(me, 'Val', me[1], '_char', '&&')
    end,

-- SIZEOF

    SIZEOF = function (me)
        local e = unpack(me)

        -- ctx
        if e.tag ~= 'Type' then
            if e.info.dcl.tag~='Evt' and TYPES.is_nat(TYPES.get(e.info.tp,1)) then
                INFO.asr_tag(e, {'Val','Nat','Var','Vec'}, 'invalid operand to `sizeof`')
            else
                INFO.asr_tag(e, {'Val','Nat','Var'}, 'invalid operand to `sizeof`')
            end
        end

        -- tp
        -- any

        -- info
        me.info = INFO.new(me, 'Val', nil, 'usize')
    end,

-- CALL

    Exp_call = function (me)
        local _, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var'}, 'invalid call')

        -- tp
        ASR(TYPES.is_nat(e.info.tp), me,
            'invalid call : expected native type')

        -- info
        me.info = e.info --INFO.new(me, 'Nat', nil, '_')
    end,

    Abs_Call = function (me)
        local ID_abs = AST.asr(me,'', 2,'Abs_Cons', 2,'ID_abs')
        local mods_dcl  = unpack(ID_abs.dcl)
        local mods_call = unpack(me)

        if mods_dcl.dynamic then
            ASR(mods_call.dynamic or mods_call.static, me,
                'invalid call : expected `/dynamic` or `/static` modifier')
        else
            local mod = (mods_call.dynamic or mods_call.static)
            ASR(not mod, me, mod and
                'invalid call : unexpected `/'..mod..'` modifier')
        end

        -- ctx
        ASR(ID_abs.dcl.tag=='Code', me,
                'invalid call : '..
                'unexpected context for '..AST.tag2id[ID_abs.dcl.tag]
                                         ..' "'..(ID_abs.dcl.id or '')..'"')
        ASR(mods_dcl.tight, me,
                'invalid call : '..
                'expected `code/tight` : got `code/await` ('..ID_abs.dcl.ln[1]..':'..ID_abs.ln[2]..')')

        -- info
        me.info = INFO.new(me, 'Val', nil,
                    AST.copy(AST.asr(ID_abs.dcl,'Code', 4,'Block', 1,'Stmts',
                                                        1,'Code_Ret',
                                                                    -- TODO: HACK_5
                                                        1,'', 2,'Type')))
    end,

    Abs_Cons = function (me)
        local Loc, ID_abs, Abslist = unpack(me)

        if Loc then
            -- var&? Ff f; f.Call(); // vs f!.Call()
            assert(Loc.info.dcl)
            local alias = unpack(Loc.info.dcl)
            ASR(alias~='&?', me,
                'invalid operand to `.` : unexpected option alias')
        end

        local err_str
        if ID_abs.dcl.tag == 'Data' then
            me.vars = AST.asr(ID_abs.dcl,'Data', 3,'Block').dcls
            err_str = 'invalid constructor'
        else
            me.vars = AST.asr(ID_abs.dcl,'Code').__adjs_1.dcls
            err_str = 'invalid call'
        end
        ASR(#me.vars == #Abslist, me, err_str..' : expected '..#me.vars..' argument(s)')

        -- check if dyn call is actually static (with "as")
        me.id  = ID_abs.dcl.id
        me.id_ = ID_abs.dcl.id_
        local mods = (ID_abs.dcl.tag=='Code' and ID_abs.dcl[2])
        local is_dyn do
            if mods and mods.dynamic then
                is_dyn = false
            end
        end

        for i=1, #me.vars do
            local var = me.vars[i]
            local val = Abslist[i]

            local var_alias, var_tp, var_id, var_dim = unpack(var)

            if mods and mods.dynamic and var_tp[1].dcl.hier and (not is_dyn) then
                if var_tp.tag=='Type' and var_tp[1].tag == 'ID_abs' then
                    if val.tag == 'Exp_as' then
                        me.id  = me.id..var.id_dyn
                        me.id_ = me.id_..var.id_dyn
                    else
                        is_dyn = true
                        me.id  = ID_abs.dcl.id
                        me.id_ = ID_abs.dcl.id_
                    end
                end
            end

            if var_alias then
                if not (var_alias=='&?' and val.tag=='ID_any') then
                    INFO.asr_tag(val, {'Alias'},
                        err_str..' : invalid binding : argument #'..i)
                end

                -- dim
                if var.tag=='Vec' or var[1]=='vector' then
                    local _,_,_,fr_dim = unpack(val.info.dcl)
                    ASR(EXPS.check_dim(var_dim,fr_dim), me,
                        err_str..' : invalid binding : argument #'..i..' : dimension mismatch')
                end
            else
                ASR(val.tag=='ID_any' or (not (val.info and val.info.tag=='Alias')), me,
                    'invalid binding : argument #'..i..' : expected declaration with `&`')
            end

            if val.tag == 'ID_any' then
                -- ok: ignore _

            elseif val.tag == 'Vec_Cons' then
assert(ID_abs.dcl.tag == 'Data', 'TODO')
error'TODO: remove below'
                EXPS.F.__set_vec(val, var)

            else
                -- ctx
                INFO.asr_tag(val, {'Alias','Val','Nat','Var'}, err_str..' : argument #'..i)
                if val.info.tag == 'Alias' then
                    INFO.asr_tag(val[2], {'Alias','Var','Vec','Pool','Evt'}, 'invalid binding')
                end

                -- tp
                if var_alias then
                    EXPS.check_tag(me, var.tag, val.info.dcl.tag, 'invalid binding')
                end
                EXPS.check_tp(me, var_tp, val.info.tp, err_str..' : argument #'..i,var_alias)

                -- abs vs abs
                local to_abs = TYPES.abs_dcl(var_tp, 'Data')
                if to_abs then
                    local is_alias = unpack(var)
                    if not is_alias then
                        local fr_abs = TYPES.abs_dcl(val.info.tp, 'Data')
                        local is_alias = unpack(val.info)
                        assert(not is_alias)

                        ASR(to_abs.n_vars == fr_abs.n_vars, me,
                            err_str..' argument #'..i..' : `data` copy : unmatching fields')

                        --ASR(to_abs.weaker=='plain', me,
                            --'invalid assignment : `data` copy : expected plain `data`')
                    end
                end
            end
        end

        me.info = INFO.new(me, 'Val', nil, ID_abs[1])
        me.info.tp[1].dcl = ID_abs.dcl
    end,

-- BIND

    ['Exp_1&'] = function (me)
        local op, e = unpack(me)

        -- ctx
        -- all?
        --INFO.asr_tag(e, {'Var','Evt','Pool','Nat','Vec'}, 'invalid operand to `'..op..'`')

        local par = me.__par
        if par.tag == 'Exp_as' then
            -- &y as X; (y is X.Y)
            par = par.__par
        end
        ASR(par.tag=='Set_Alias' or par.tag=='List_Exp' or par.tag=='Abslist', me,
            'invalid expression : unexpected context for operation `&`')

        if e.info.tag == 'Nat' then
            ASR(e.tag == 'Exp_call', me, 'invalid operand to `'..op..'` : expected native call')
        end

        -- tp
        -- any

        -- info
        me.info = INFO.copy(e.info)
        me.info.tag = 'Alias'
    end,

-- OPTION: !

    ['Exp_!'] = function (me)
        local op,e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var','Evt'}, 'invalid operand to `'..op..'`')

        -- tp
        ASR((e.info.dcl[1]=='&?') or TYPES.check(e.info.tp,'?'), me,
            'invalid operand to `'..op..'` : expected option type : got "'..
            TYPES.tostring(e.info.tp)..'"')

        -- info
        me.info = INFO.copy(e.info)
        if e.info.dcl[1] == '&?' then
            me.info.dcl = AST.copy(e.info.dcl,nil,true)
            me.info.dcl[1] = '&'
            me.info.dcl.orig = e.info.dcl.orig or e.info.dcl   -- TODO: HACK_3
        else
            me.info.tp = TYPES.pop(e.info.tp)
        end
    end,

-- INDEX

    ['Exp_idx'] = function (me)
        local _,vec,idx = unpack(me)

        -- ctx, tp

        local tp = AST.copy(vec.info.tp)
        tp[2] = nil
        if (vec.info.tag=='Var' or vec.info.tag=='Nat') and TYPES.is_nat(tp) then
            -- _V[0][0]
            -- var _char&&&& argv; argv[1][0]
            -- v[1]._plain[0]
            INFO.asr_tag(vec, {'Nat','Var'}, 'invalid vector')
        else
            INFO.asr_tag(vec, {'Vec'}, 'invalid vector')
        end

        -- info
        me.info = INFO.copy(vec.info)
        me.info.tag = 'Var'
        if vec.info.tag=='Var' and TYPES.check(vec.info.tp,'&&') then
            me.info.tp = TYPES.pop(vec.info.tp)
        end

        -- ctx
        INFO.asr_tag(idx, {'Val','Nat','Var'}, 'invalid index')

        -- tp
        ASR(TYPES.is_int(idx.info.tp), me,
            'invalid index : expected integer type')
    end,

-- MEMBER: .

    ['Exp_.'] = function (me)
        local _, e, member = unpack(me)

        if type(member) == 'number' then
            local abs = TYPES.abs_dcl(e.info.dcl[2], 'Data')
            ASR(abs, me, 'invalid constructor : TODO')
            local vars = AST.asr(abs,'Data', 3,'Block').dcls
            local _,_,id = unpack(vars[member])
            member = id
            me[3] = id
        end

        if e.tag == 'Outer' then
            EXPS.F.ID_int(me)
            me.info.id = 'outer.'..member
        else
            ASR(TYPES.ID_plain(e.info.tp), me,
                'invalid operand to `.` : expected plain type : got "'..
                TYPES.tostring(e.info.tp)..'"')

            if e.info.dcl then
                local alias = unpack(e.info.dcl)
                ASR(alias~='&?', me,
                    'invalid operand to `.` : unexpected option alias')

                local ID_abs = unpack(e.info.tp)
                if ID_abs and (ID_abs.dcl.tag=='Data' or ID_abs.dcl.tag=='Code') then
                    local Dcl
                    if ID_abs.dcl.tag == 'Data' then
                        -- data.member
                        local data = AST.asr(ID_abs.dcl,'Data')
                        Dcl = DCLS.asr(me,data,member,false,e.info.id)
                    else
                        local code = AST.asr(ID_abs.dcl,'Code')
                        Dcl = DCLS.asr(me,
                                       AST.asr(code,'',4,'Block',1,'Stmts',2,'Do', 3,'Block',1,'Stmts',2,'Block'),
                                       member,false,e.info.id)
                    end
                    me.info = {
                        id  = e.info.id..'.'..member,
                        tag = Dcl.tag,
                        tp  = Dcl[2],
                        dcl = Dcl,
                        blk = e.info.dcl.blk,
                        dcl_obj = e.info.dcl,
                    }
                else
                    me.info = INFO.copy(e.info)
                    me.info.id = e.info.id..'.'..member
                    me.info.dcl = AST.copy(e.info.dcl)
                    me.info.dcl[1] = false
                end
            else
                ASR(TYPES.is_nat(e.info.tp), me,
                    'invalid operand to `.` : expected native or data type')
            end
        end
    end,

    ['Exp_.__POS'] = function (me)
        if not me.info then
            return
        end
        local alias = unpack(me.info.dcl)
        if alias ~= '&?' then
            return
        end
        if me.__exps_ok then
            return
        end

        for watching in AST.iter'Watching' do
            local loc = AST.get(watching,'',1,'Par_Or',1,'Block',1,'Stmts',1,'Await_Int',1,'Loc',1,'')
                    or  AST.get(watching,'',1,'Par_Or',1,'Block',1,'Stmts',1,'Set_Await_many',1,'Await_Int',1,'Loc',1,'')
            if AST.is_par(loc,me) then
                break
            end
            if loc and loc.info.dcl==me.info.dcl then
                ASR(me.__par.tag~='Exp_!', me, 'invalid operand to `!` : found enclosing matching `watching`')
                me.__exps_ok = true
                return AST.node('Exp_!', me.ln, '!', me)
                    -- TODO: inneficient: could access directly
            end
        end
    end,

-- POINTERS

    ['Exp_&&'] = function (me)
        local op, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var','Pool','Vec','Val'}, 'invalid operand to `'..op..'`')

        -- tp
        if e.info.tag == 'Val' then
            ASR(TYPES.is_nat(e.info.tp), me, 'expected native type')
        else
            ASR(not (e.info.dcl[1]=='&?' or TYPES.check(e.info.tp,'?')), me,
                'invalid operand to `'..op..'` : unexpected option type')
        end

        -- info
        me.info = INFO.copy(e.info)
        me.info.tag = 'Val'
        me.info.tp = TYPES.push(e.info.tp,'&&')
    end,

    ['Exp_1*'] = function (me)
        local op,e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var','Pool','Val'}, 'invalid operand to `'..op..'`')
--DBG('TODO: remove pool')

        -- tp
        local _,mod = unpack(e.info.tp)
        local is_ptr = TYPES.check(e.info.tp,'&&')
        local is_nat = TYPES.is_nat(e.info.tp)
        ASR(is_ptr or is_nat, me,
            'invalid operand to `'..op..'` : expected pointer type : got "'..
            TYPES.tostring(e.info.tp)..'"')

        -- info
        me.info = INFO.copy(e.info)
        if is_ptr then
            me.info.tp = TYPES.pop(e.info.tp)
        end
    end,

-- OPTION: ?

    ['Exp_?'] = function (me)
        local op,e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Nat','Var','Evt'}, 'invalid operand to `'..op..'`')
        if e.info.dcl.tag == 'Evt' then
            ASR(e.info.dcl[1] == '&?', me,
                'invalid operand to `?` : unexpected context for event "'..e.info.dcl.id..'"')
        end

        -- tp
        ASR((e.info.dcl[1]=='&?') or TYPES.check(e.info.tp,'?'), me,
            'invalid operand to `'..op..'` : expected option type')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- VECTOR LENGTH: $$

    ['Exp_$$'] = 'Exp_$',
    ['Exp_$'] = function (me)
        local op,vec = unpack(me)

        -- ctx
        INFO.asr_tag(vec, {'Vec'}, 'invalid operand to `'..op..'`')

        -- tp
        -- any

        -- info
        me.info = INFO.copy(vec.info)
        me.info.tp = TYPES.new(me, 'usize')
        me.info.tag = 'Var'
    end,

-- NOT

    ['Exp_not'] = function (me)
        local op, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')

        -- tp
        ASR(TYPES.check(e.info.tp,'bool'), me,
            'invalid operand to `'..op..'` : expected boolean type')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- UNARY: +,-

    ['Exp_1+'] = 'Exp_num_num',
    ['Exp_1-'] = 'Exp_num_num',
    Exp_num_num = function (me)
        local op, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')

        -- tp
        ASR(TYPES.is_num(e.info.tp), me,
            'invalid operand to `'..op..'` : expected numeric type')

        -- info
        me.info = INFO.copy(e.info)
        me.info.tag = 'Val'
    end,

-- NUMERIC: +, -, %, *, /, ^

    ['Exp_+']  = 'Exp_num_num_num',
    ['Exp_-']  = 'Exp_num_num_num',
    ['Exp_%']  = 'Exp_num_num_num',
    ['Exp_*']  = 'Exp_num_num_num',
    ['Exp_/']  = 'Exp_num_num_num',
    ['Exp_^']  = 'Exp_num_num_num',
    Exp_num_num_num = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')

        -- tp
        ASR(TYPES.is_num(e1.info.tp) and TYPES.is_num(e2.info.tp), me,
            'invalid operand to `'..op..'` : expected numeric type')

        -- info
        local max = TYPES.max(e1.info.tp, e2.info.tp)
        ASR(max, me, 'invalid operands to `'..op..'` : '..
                        'incompatible numeric types : "'..
                        TYPES.tostring(e1.info.tp)..'" vs "'..
                        TYPES.tostring(e2.info.tp)..'"')
        me.info = INFO.new(me, 'Val', nil, AST.copy(max))
    end,

-- BITWISE

    ['Exp_|']  = 'Exp_int_int_int',
    ['Exp_&']  = 'Exp_int_int_int',
    ['Exp_<<'] = 'Exp_int_int_int',
    ['Exp_>>'] = 'Exp_int_int_int',
    Exp_int_int_int = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')

        -- tp
        ASR(TYPES.is_int(e1.info.tp) and TYPES.is_int(e2.info.tp), me,
            'invalid operand to `'..op..'` : expected integer type')

        -- info
        local max = TYPES.max(e1.info.tp, e2.info.tp)
        ASR(max, me, 'invalid operands to `'..op..'` : '..
                        'incompatible integer types : "'..
                        TYPES.tostring(e1.info.tp)..'" vs "'..
                        TYPES.tostring(e2.info.tp)..'"')
        me.info = INFO.new(me, 'Val', nil, AST.copy(max))
    end,

    ['Exp_~'] = function (me)
        local op, e = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')

        -- tp
        ASR(TYPES.is_int(e.info.tp), me,
            'invalid operand to `'..op..'` : expected integer type')

        -- info
        me.info = INFO.copy(e.info)
        me.info.tag = 'Val'
    end,

-- COMPARISON: >, >=, <, <=

    ['Exp_>='] = 'Exp_num_num_bool',
    ['Exp_<='] = 'Exp_num_num_bool',
    ['Exp_>']  = 'Exp_num_num_bool',
    ['Exp_<']  = 'Exp_num_num_bool',
    Exp_num_num_bool = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')

        -- tp
        ASR(TYPES.is_num(e1.info.tp) and TYPES.is_num(e2.info.tp), me,
            'invalid operand to `'..op..'` : expected numeric type')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- EQUALITY: ==, !=

    ['Exp_!='] = 'Exp_eq_bool',
    ['Exp_=='] = 'Exp_eq_bool',
    Exp_eq_bool = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')

        -- tp

        local ID1 = TYPES.ID_plain(e1.info.tp)
        local ID2 = TYPES.ID_plain(e2.info.tp)
        ASR( (not (ID1 and ID1.tag=='ID_abs')) and
             (not (ID2 and ID2.tag=='ID_abs')), me,
            'invalid operands to `'..op..'` : unexpected `data` value' )

        ASR(TYPES.contains(e1.info.tp,e2.info.tp) or
            TYPES.contains(e2.info.tp,e1.info.tp), me,
            'invalid operands to `'..op..'` : '..
            'incompatible types : "'..
                TYPES.tostring(e1.info.tp)..'" vs "'..
                TYPES.tostring(e2.info.tp)..'"')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- AND, OR

    ['Exp_or']  = 'Exp_bool_bool_bool',
    ['Exp_and'] = 'Exp_bool_bool_bool',
    Exp_bool_bool_bool = function (me)
        local op, e1, e2 = unpack(me)

        -- ctx
        INFO.asr_tag(e1, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')
        INFO.asr_tag(e2, {'Val','Nat','Var'}, 'invalid operand to `'..op..'`')

        -- tp
        ASR(TYPES.check(e1.info.tp,'bool') and TYPES.check(e2.info.tp,'bool'), me,
            'invalid operand to `'..op..'` : expected boolean type')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,

-- IS, AS/CAST

    Exp_as = function (me)
        local op,e,Type = unpack(me)
        if not e.info then return end   -- see EXPS below

        -- ctx
        INFO.asr_tag(e, {'Alias','Val','Nat','Var','Pool'},
                     'invalid operand to `'..op..'`')

        -- tp
        ASR(not TYPES.check(e.info.tp,'?'), me,
            'invalid operand to `'..op..'` : unexpected option type : got "'..
            TYPES.tostring(e.info.tp)..'"')

        local dcl = e.info.tp[1].dcl

        if dcl and dcl.tag=='Data' then
            if TYPES.check(Type,'int') then
                -- OK: "d as int"
                ASR(dcl.hier, me,
                    'invalid operand to `'..op..'` : expected `data` type in a hierarchy : got "'..TYPES.tostring(e.info.tp)..'"')
            else
                -- NO: not alias
                --  var Dx d = ...;
                --  (d as Ex)...
                local is_alias = unpack(dcl)
                ASR(is_alias, me,
                    'invalid operand to `'..op..'` : unexpected plain `data` : got "'..
                    TYPES.tostring(e.info.tp)..'"')

                -- NO:
                --  var Dx& d = ...;
                --  (d as Ex)...        // "Ex" is not a subtype of Dx
                -- YES:
                --  var Dx& d = ...;
                --  (d as Dx.Sub)...
                local cast = Type[1].dcl
                if cast and cast.tag=='Data' then
                    local ok = cast.hier and dcl.hier and
                                (DCLS.is_super(cast,dcl) or     -- to dyn/call super
                                 DCLS.is_super(dcl,cast))
                    ASR(ok, me,
                        'invalid operand to `'..op..'` : unmatching `data` abstractions')
                end
            end
        end

        -- info
        me.info = INFO.copy(e.info)
        if AST.is_node(Type) then
            me.info.tp = AST.copy(Type)
        else
            -- annotation (/plain, etc)
DBG'TODO: type annotation'
        end
    end,

    Exp_is = function (me)
        local op,e,cast = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Val','Nat','Var','Pool'}, 'invalid operand to `'..op..'`')

        -- tp
        local plain = TYPES.ID_plain(e.info.tp)
        ASR(plain and plain.dcl.tag=='Data', me,
            'invalid operand to `'..op..'` : expected plain `data` type : got "'..TYPES.tostring(e.info.tp)..'"')
        ASR(plain and plain.dcl.hier, me,
            'invalid operand to `'..op..'` : expected `data` type in some hierarchy : got "'..TYPES.tostring(e.info.tp)..'"')

        cast = cast[1].dcl
        ASR(cast and cast.hier and DCLS.is_super(plain.dcl,cast), me,
            'invalid operand to `'..op..'` : unmatching `data` abstractions')

        -- info
        me.info = INFO.new(me, 'Val', nil, 'bool')
    end,
}

--AST.visit(F)

end

    
do
DCLS = {}

local node = AST.node

local function iter_boundary (cur, id, can_cross)
    return function ()
        while cur do
            local c = cur
            local do_ = AST.get(c, 'Do')
            cur = cur.__par
            if c.tag == 'Block' then
                return c
            elseif can_cross then
                -- continue
            elseif string.match(c.tag,'^.?Async') or (do_ and do_[2]) or c.tag=='Ext_impl' then
                -- see if varlist matches id to can_cross the boundary
                -- async (a,b,c) do ... end
                local can_cross2 = false

                if string.match(c.tag,'^.?Async') and string.sub(id,1,1)==string.upper(string.sub(id,1,1))
                    and string.sub(id,1,1) ~= '_'
                then
                    ASR(false, cur, 'abstraction inside `async` : not implemented') -- TODO: ID_abs is ok
                    can_cross2 = true
                end

                local _,varlist = unpack(c)
                if varlist then
                    for _, ID_int in ipairs(varlist) do
                        if ID_int[1] == id then
                            can_cross2 = true
                            break
                        end
                    end
                end
                if not can_cross2 then
                    return nil
                end
            elseif c.tag=='Data' or c.tag=='Code'
                    -- or c.tag=='Ext_Code' or c.tag=='Ext_Req'
            then
                return nil
            end
        end
    end
end

local __do = function (me)
    return me.tag=='Do' and me[2]~=false
end

function DCLS.outer (me)
    local async = AST.par(me,'_Async_Isr') or AST.par(me,'Async_Isr')
    local do_   = AST.iter(__do)()
    local code  = AST.par(me,'Code')
    local ext   = AST.par(me,'Ext_impl')
    ASR(async or do_ or code or ext, me, 'invalid `outer`')

    local ret = async
    if do_ and ((not ret) or AST.depth(do_)>AST.depth(ret)) then
        ret = do_
    end
    if code and ((not ret) or AST.depth(code)>AST.depth(ret)) then
        ret = code
    end
    if ext and ((not ret) or AST.depth(ext)>AST.depth(ret)) then
        ret = ext
    end
    return ret
end

function DCLS.get (blk, id, can_cross, dont_use)
    AST.asr(blk, 'Block')
    for blk in iter_boundary(blk,id,can_cross) do
        local dcl = blk.dcls[id]
        if dcl then
            local no = AST.iter'Vec_Init'() or AST.iter'Pool_Init'()
            if (not no) and (not dont_use) then
                dcl.is_used = true
            end
            return dcl, AST.par(blk,'Code')
        end
    end
    return nil
end

function DCLS.asr (me, blk_or_data, id, can_cross, err)
    local data = AST.get(blk_or_data, 'Data')
    local blk = (data and AST.asr(data,'',3,'Block')) or blk_or_data
    local ret,n = DCLS.get(blk, id, can_cross)
    if ret then
        return ret,n
    else
        if data then
            ASR(false, me, 
                'invalid member access : "'..
                err..  '" has no member "'..id..'" : '..
                '`data` "'..data.id..
                '" ('..data.ln[1]..':'..  data.ln[2]..')')
        else
            -- recursive use
            for par in AST.iter'Code' do
                if par and par[2]==id then
                    return par
                end
            end
            ASR(false, me, err..' "'..id..'" is not declared')
        end
    end
end

local PSS = function () end

local function dcls_new (blk, me, can_cross, opts)
assert(can_cross==nil)
    AST.asr(blk, 'Block')

    if me.n and blk.dcls[me.n..'_'] then
        return  -- revisiting this node
    end

    local id = (opts and opts.id) or me.id

    local old = DCLS.get(blk, id, can_cross, true)

    if old and old.tag=='Ext' then
        EXPS.check_tp(me, me[2], old[2], 'invalid declaration')
        old.__dcls_old = true
    end

    local implicit = (me.is_implicit and 'implicit ') or ''
    if not old then
        F = PSS
    elseif old.is_predefined then
        F = PSS
    elseif me.__adjs_is_impl and (not old.__adjs_is_impl) or
           old.__adjs_is_impl and (not me.__adjs_is_impl) then
        -- make is_impl the main
        if old.__adjs_is_impl then
            old.__dcls_old = nil
            me.__dcls_old = true
        end
        F = PSS
    else
        if me.tag=='Nat' or me.tag=='Ext' then
            -- or me.tag=='Ext_Code' or me.tag=='Ext_Req'
            F = ASR
        else
            F = WRN
        end
        me.__dcls_dup = true
    end

    F(false, me, old and
        implicit..'declaration of "'..id..'" hides previous declaration'..
            ' ('..old.ln[1]..' : line '..old.ln[2]..')')

    blk.dcls[#blk.dcls+1] = me
if (not blk.dcls[id]) or (not blk.dcls[id].__adjs_is_impl) then
    blk.dcls[id] = me
end
    if me.n then
        blk.dcls[me.n..'_'] = true
    end

    me.blk = blk
    return me
end

function DCLS.is_super (super, sub)
    assert(super.hier and sub.hier)
    if super == sub then
        return true
    elseif sub.hier.up then
        return DCLS.is_super(super, sub.hier.up)
    else
        return false
    end
end

function DCLS.base (data)
    if data.hier then
        if data.hier.up then
            return DCLS.base(data.hier.up)
        else
            return data
        end
    else
        return false
    end
end

-- native declarations are allowed until `native/end`
local native_end = false

DCLS.F = {
    -- Primitive types: id / is_num
    __prims = function (blk)
        local prims = {
            bool  = { is_num=false, is_int=false },
            byte  = { is_num=true,  is_int=true  },
            r32   = { is_num=true,  is_int=false },
            r64   = { is_num=true,  is_int=false },
            real  = { is_num=true,  is_int=false },
            int   = { is_num=true,  is_int=true  },
            s16   = { is_num=true,  is_int=true  },
            s32   = { is_num=true,  is_int=true  },
            s64   = { is_num=true,  is_int=true  },
            s8    = { is_num=true,  is_int=true  },
            ssize = { is_num=true,  is_int=true  },
            u16   = { is_num=true,  is_int=true  },
            u32   = { is_num=true,  is_int=true  },
            u64   = { is_num=true,  is_int=true  },
            u8    = { is_num=true,  is_int=true  },
            uint  = { is_num=true,  is_int=true  },
            usize = { is_num=true,  is_int=true  },
            none  = { is_num=false, is_int=false },
            null  = { is_num=false, is_int=false },
            _     = { is_num=true,  is_int=true  },
        }
        for id, t in pairs(prims) do
            dcls_new(blk, {
                            tag   = 'Prim',
                            id    = id,
                            prim  = t,
                            is_used = true,
                          })
        end
    end,
    Block__PRE = function (me)
        me.dcls = {}
        if DCLS.F.__prims then
            DCLS.F.__prims(me)
            DCLS.F.__prims = nil
        end
    end,
    Block__POS = function (me)
        if AST.par(me,'Data') then
            return
        end
        local Code = AST.par(me,'Code')
        if Code and ((not Code.is_impl) or Code.is_dyn_base) then
            return
        end

        for _, dcl in ipairs(me.dcls) do
            if dcl.tag=='Data' and string.sub(dcl.id,1,1)=='_' then
                -- auto generated
            else
                local f = WRN
                if CEU.opts.ceu_err_unused then
                    f = ASR_WRN_PASS(CEU.opts.ceu_err_unused)
                end
                if dcl.tag=='Nat' and CEU.opts.ceu_err_unused_native then
                    f = ASR_WRN_PASS(CEU.opts.ceu_err_unused_native)
                elseif dcl.tag=='Code' and CEU.opts.ceu_err_unused_code then
                    f = ASR_WRN_PASS(CEU.opts.ceu_err_unused_code)
                end
                if not (dcl.is_used or dcl.is_predefined or dcl.__dcls_unused or dcl.__dcls_old) then
                    dcl.__dcls_unused = true
                    f(false, dcl,
                      AST.tag2id[dcl.tag]..' "'..dcl.id..'" declared but not used')
                end
            end
        end
    end,
    __pass = function () end,

    ---------------------------------------------------------------------------

-- NEW

    -- LOC

    __no_abs = function (tp, class, mod)
        local ID = unpack(tp)
        if ID.tag == 'ID_abs' then
            local ok do
                if class then
                    if ID.dcl.tag==class then
                        if mod then
                            if ID.dcl[2][mod] then
                                ok = false
                            else
                                ok = true
                            end
                        else
                            ok = false
                        end
                    else
                        ok = true
                    end
                else
                    ok = false
                end
            end
            ASR(ok, tp,
                'invalid declaration : unexpected context for `'..AST.tag2id[ID.dcl.tag]..'` "'..
                    (ID.dcl.id or ID.dcl[2])..'"')
        end
    end,

    Var__POS = function (me)
        local alias,Type,id = unpack(me)

        me.id = id
        dcls_new(AST.par(me,'Block'), me)

        if alias then
            local ID = unpack(Type)
            if ID.tag=='ID_abs' and ID.dcl.tag=='Code' and ID.dcl[1].await then
                if alias == '&' then
                    local tp = AST.get(ID.dcl,'Code', 4,'Block', 1,'Stmts',
                                                      1,'Code_Ret', 1,'', 2,'Type')
                    ASR(not tp, me, 'invalid declaration : `code/await` must execute forever')
                end
                me.__dcls_code_alias = alias
                -- ok
            end
            if alias == '&?' then
                me.is_read_only = true
                ASR(not TYPES.check(Type,'?'), me,
                    'invalid declaration : option type : not implemented')
            end
        else
            DCLS.F.__no_abs(Type, 'Code')
        end

        if alias then
            -- NO: alias to pointer
            --  var& int&& x = ...;
            ASR(not TYPES.check(Type,'&&'), me,
                'invalid declaration : unexpected `&&` : cannot alias a pointer')
        end

        local ID_prim,mod = unpack(Type)
        if ID_prim.tag=='ID_prim' and ID_prim[1]=='none' and (not mod) then
            ASR(alias, me,
                'invalid declaration : variable cannot be of type `none`')
        end

        local inits = DCLS.F.Var__POS__POS(me)
        if inits then
            return node('Stmts', me.ln, me, inits)
        end
    end,

-------------------------------------------------------------------------------

    Var__POS__POS = function (me, t)
        local is_alias,Type,id = unpack(me)

        if ((not t) and AST.par(me,'Data')) or is_alias
            or AST.par(me,'Code_Ret')
        then
            return
        end

        if me.__dcls_ok then
            return
        end
        me.__dcls_ok = true

        local abs = TYPES.abs_dcl(Type,'Data')
        if not abs then
            return
        end

        local blk = AST.asr(abs,'', 3,'Block')

        local is_top = (not t)
        t = t or {}
        t.stmts = t.stmts or node('Stmts', me.ln)
        t.base  = t.base or node('ID_int', me.ln, id)

        for _, dcl in ipairs(blk.dcls) do
            local is_alias,tp,id,dim = unpack(dcl)
            local base = node('Exp_.', dcl.ln, '.',
                            AST.copy(t.base),
                            id)

            -- initialize vecs
            if dcl.tag == 'Var' then
                DCLS.F.Var__POS__POS(dcl, {stmts=t.stmts,base=base})
            elseif dcl.tag == 'Vec' then
                if is_alias or TYPES.is_nat(TYPES.get(tp,1)) then
                    --
                else
                    AST.insert(t.stmts, #t.stmts+1,
                        node(dcl.tag..'_Init', dcl.ln,
                            base))
                end
            end

            -- default vaules
            local stmts = AST.asr(dcl,1,'Stmts')
            local set = AST.get(stmts,'', 2,'Set_Exp') or
                        AST.get(stmts,'', 2,'Set_Any') or
                        AST.get(stmts,'', 2,'Set_Abs_Val')
            if set then
                set = AST.copy(set)
                set.__dcls_defaults = true
                AST.set(set, 2, AST.copy(base))
                AST.insert(t.stmts, #t.stmts+1, set)
            end
        end

        return t.stmts
    end,

    Pool__PRE = 'Vec__PRE',
    Vec__PRE = function (me)
        local is_alias,tp,id,dim = unpack(me)

        if (dim == '[]') and (not is_alias) then
            ASR(CEU.opts.ceu_features_dynamic, me, 'dynamic allocation support is disabled')
        end
        if me.tag == 'Pool' then
            ASR(CEU.opts.ceu_features_pool, me, 'pool support is disabled')
        end

        if AST.par(me,'Data') or is_alias or TYPES.is_nat(TYPES.get(tp,1)) then
            return
        end

        if me.__dcls_ok then
            return
        end
        me.__dcls_ok = true

        return node('Stmts', me.ln,
                me,
                node(me.tag..'_Init', me.ln,
                    node('ID_int', me.ln, id)))
    end,

------------------------------------------------------------------------------

    Vec = function (me)
        local is_alias,Type,id,dim = unpack(me)
        me.id = id
        dcls_new(AST.par(me,'Block'), me)
        DCLS.F.__no_abs(Type, 'Code', 'tight')

        local code = AST.par(me, 'Code')
        if code and code[1].tight and (not is_alias) then
            ASR(false, me,
                'invalid declaration : vector inside `code/tight`')
        end

        -- vector[] none vec;
        local ID_prim,mod = unpack(Type)
        if ID_prim.tag=='ID_prim' and ID_prim[1]=='none' and (not mod) then
            ASR(false, me,
                'invalid declaration : vector cannot be of type `none`')
        end
    end,

    Pool = function (me)
        local _,_,id,_ = unpack(me)
        me.id = id
        dcls_new(AST.par(me,'Block'), me)
    end,

    Evt = function (me)
        local _,Typelist,id = unpack(me)
        me.id = id

        -- no modifiers allowed
        for _, Type in ipairs(Typelist) do
            DCLS.F.__no_abs(Type)

            local id, mod = unpack(Type)
            assert(id.dcl,'bug found')
            ASR(id.dcl.tag=='Prim' or TYPES.is_nat_plain(Type), me,
                'invalid event type : must be primitive')
            ASR(not mod, me,
                mod and 'invalid event type : cannot use `'..mod..'`')
        end

        dcls_new(AST.par(me,'Block'), me)
    end,

-------------------------------------------------------------------------------

    -- NATIVE

    Nat_End = function (me)
        native_end = true
    end,
    Nat__PRE = function (me)
        local mod,_,id = unpack(me)
        me.id = id
        me.is_read_only = (mod == 'const')
        local blk = AST.asr(AST.root,'', 1,'Block')
        dcls_new(blk, me)

        ASR(not native_end, me,
            'native declarations are disabled')

        if id=='_{}' or id=='_char' then
            me.is_predefined = true
        end
    end,

    -- EXT

    Ext = function (me)
        local _, _, id = unpack(me)
        me.id = id
        local blk = AST.asr(AST.root,'', 1,'Block')
        dcls_new(blk, me)
    end,

    Ext_impl = function (me)
        local _, block = unpack(me)
        me.__dcls_vars = {}
        local stmts = AST.asr(block,'Block',1,'Stmts')
        for i,var in ipairs(stmts) do
            if var.tag == 'Var' then
                me.__dcls_vars[var.id] = i
            else
                AST.asr(var, 'Do')
            end
        end
    end,

    --Ext_Code = 'Code',

    -- CODE / DATA

    Code_Pars = function (me)
        local Code = AST.par(me,'Code')
        local mods = unpack(Code)

        -- check types only
--[[
        do
AST.dump(me)
            local tps = node('Typelist',me.ln)
            for i, dcl in ipairs(me) do
DBG('>>>', dcl[2])
                tps[i] = dcl[2]
            end
            DCLS.F.Typelist(tps)
error'oi'
        end
]]

        -- multi-methods: changes "me.id" on Code
        me.ids_dyn = ''
        for i, dcl in ipairs(AST.par(me,'Block').dcls) do
            local _,_,_,dcl_mods = unpack(dcl)
            if dcl_mods and dcl_mods.dynamic then
                ASR(mods.dynamic, me,
                    'invalid `dynamic` modifier : expected enclosing `code/dynamic`')
                local is_alias,Type = unpack(dcl)
                dcl.id_dyn = '_'..i..'_'..dcl.tag..
                             '_'..(is_alias and 'y' or 'n')..
                             '_'..TYPES.tostring(Type)
                dcl.id_dyn = TYPES.noc(dcl.id_dyn)
                me.ids_dyn = me.ids_dyn..dcl.id_dyn
            end
        end

        if mods.dynamic and #me>0 then
            ASR(me.ids_dyn ~= '', me,
                'invalid `dynamic` declaration : expected dynamic parameters')
        end
    end,

    -- detect "base" dynamic multimethod: create dummy copy with plain "id"
    Code__PRE = function (me)
        local mods,id = unpack(me)
        if not mods.dynamic then
            return  -- not dynamic code
        end

        local old = DCLS.get(AST.par(me,'Block'), id)
        if old then
            ASR(me.is_impl, me, 'not implemented : prototype for non-base dynamic code')
            return  -- not first appearence
        end

        if me.is_dyn_base then
            return  -- not first appearence
        end

        if not me.is_impl then
            -- "base" method with plain "id"
            me.id = id
            me.is_dyn_base = true
            return
        end

        local proto_body = AST.asr(me,'', 4,'Block', 1,'Stmts', 2,'Do', 3,'Block', 1,'Stmts', 2,'Block',1,'Stmts')
        local orig = proto_body[2]
        AST.set(proto_body, 2, node('Stmts', me.ln))
        local new = AST.copy(me)
        AST.set(proto_body, 2, orig)

        -- "base" method with plain "id"
        new.id = id
        new.is_dyn_base = true
        new.dyns = {}

        local s = node('Stmts', me.ln, new, me)
        return s
    end,

    Code = function (me)
        local mods1,id,_,body1 = unpack(me)

        --ASR(not AST.par(me,'Code'), me,
            --'invalid `code` declaration : nesting is not allowed')

        me.depth = 0
        local par = AST.par(me, 'Code')
        while par do
            par = AST.par(par, 'Code')
            me.depth = me.depth + 1
        end

        local blk = AST.par(me, 'Block')
        local proto1 = AST.asr(body1,'Block', 1,'Stmts', 2,'Do', 3,'Block', 1,'Stmts', 1,'Code_Pars')

        if (not me.is_dyn_base) and mods1.dynamic and me.is_impl then
            me.id = id..proto1.ids_dyn
            me.dyn_base = DCLS.asr(me,blk,id)
-- TODO: check if both are still needed
            me.dyn_base.dyn_last = me
            me.dyn_base.dyn_first = me.dyn_base.dyn_first or me
            if me.dyn_base.dyns then
                me.dyn_base.dyns[#me.dyn_base.dyns+1] = me
            end
        else
            me.id = id
        end

        local old = DCLS.get(blk, me.id)

        do
            local _n = ''
            local blk1 = AST.par(me, 'Block')
            local blk2 = AST.par(blk1,'Block') or blk1
            if blk2.__par.tag ~= 'ROOT' then
                _n = '_'..((old and old.n) or me.n)
            end
            if me.dyn_base then
                me.id_ = id.._n..proto1.ids_dyn
            else
                me.id_ = id.._n
            end
        end

        if old then
            ASR(old.tag == 'Code', me, 'invalid `code` declaration')
            local mods2,_,_,body2 = unpack(old)
            if me.is_impl then
                ASR(not (old.is_impl or old.__impl), me,
                    'invalid `code` declaration : body for "'..id..'" already exists')
                old.__impl = true
            end

            -- compare ins
            local proto2 = AST.asr(body2,'Block',1,'Stmts',2,'Do',3,'Block',1,'Stmts',1,'Code_Pars')
            local ok = AST.is_equal(proto1, proto2)

            -- compare mods
            do
                for k,v in pairs(mods1) do
                    if mods2[k] ~= v then
                        ok = false
                        break
                    end
                end
                for k,v in pairs(mods2) do
                    if mods1[k] ~= v then
                        ok = false
                        break
                    end
                end
            end

            ASR(ok, me,
                'invalid `code` declaration : unmatching prototypes '..
                '(vs. '..proto1.ln[1]..':'..proto2.ln[2]..')')
        else
            dcls_new(blk,me)
            assert(me == DCLS.get(blk,me.id))

            if not mods1.dynamic then
                dcls_new(blk,me,nil,{id=id})
                assert(me == DCLS.get(blk,id))
            end
        end
        me.is_used = (old and old.is_used)
                        or (mods1.dynamic and (not me.is_dyn_base))
    end,

    Data__PRE = function (me)
        local id, num, blk = unpack(me)
        me.id = id
        local par = AST.par(me, 'Block')

        if id == 'Exception' then
            me.hier = { down={} }
        end

        -- check "super" path
        local super,_ = string.match(me.id, '(.*)%.(.*)')
        if super then
            local dcl = DCLS.get(par, super, true)
            ASR(dcl, me,
                'invalid declaration : abstraction "'..super..'" is not declared')
            dcl.hier = dcl.hier or { down={} }
            dcl.hier.down[#dcl.hier.down+1] = me
            me.hier = { up=dcl, down={} }

            local mines = AST.asr(me,'',  3,'Block', 1,'Stmts')
            local hiss  = AST.asr(dcl,'', 3,'Block', 1,'Stmts')

            -- copy all super vars to myself
            local I = 1
            for i=1, #hiss do
                local his = AST.get(hiss,'Stmts', i,'Stmts', 1,'')

                local skip = false
                for j=I, #mines do
                    local mine = AST.asr(mines,'Stmts', j,'Stmts', 1,'Var')
                    if mine[3] == his[3] then
                        skip = true
                        break
                    end
                end

                if not skip then
                    AST.insert(mines, I, AST.copy(AST.asr(his,1,'Stmts')))
                    I = I + 1
                end
            end
        end

        me.n_vars = #AST.asr(me,'', 3,'Block', 1,'Stmts')
        dcls_new(par, me)

        me.id_ = me.id
        local stmts = AST.par(me, 'Stmts')
        if (stmts ~= ADJS.stmts) and (AST.is_par(ADJS.stmts,me)) then
            me.id_ = me.id..'_'..me.n
        end
    end,

    Data = function (me)
        me.weaker = 'plain'
        for _, dcl in ipairs(AST.asr(me,'',3,'Block').dcls) do
            local is_alias, tp = unpack(dcl)
            if TYPES.check(tp,'&&') then
                me.weaker = 'pointer'
                break   -- can't be worse
            elseif is_alias then
                me.weaker = 'alias'
            else
                local ID = TYPES.ID_plain(tp)
                if ID and ID.tag=='ID_abs' and ID.dcl.tag=='Data' then
                    if ID.dcl.weaker == 'pointer' then
                        me.weaker = 'pointer'
                        break   -- can't be worse
                    elseif ID.dcl.weaker == 'alias' then
                        me.weaker = 'alias'
                    end
                end
            end
        end
    end,

    Typelist = function (me)
        if #me == 1 then
            return
        end
        for _, Type in ipairs(me) do
            if Type.tag == 'Type' then
                local ID_prim,mod = unpack(Type)
                if ID_prim.tag=='ID_prim' and ID_prim[1]=='none' and (not mod) then
                    ASR(false, me,
                        'invalid declaration : unexpected type `none`')
                end
            end
        end
    end,

    ---------------------------------------------------------------------------
    -- HACK_02: very ugly
    ---------------------------------------------------------------------------

    --  call Ff(Dd(...));
    -- to
    --  var Dd x = Dd(...);
    --  call FF(x);

    Abs_Cons = function (me)
        local obj, code, Abslist = unpack(me)

        if code.dcl.tag ~= 'Code' then
            EXPS.F.Abs_Cons(me)
            return
        end

        if me.__dcls_ok then
            EXPS.F.Abs_Cons(me)
            return
        else
            me.__dcls_ok = true
        end

        local is_pending = false
        for i, v in ipairs(Abslist) do
            local id = '_'..code.n..'_'..v.n..'_abs'
            local xxx, yyy

            local data = AST.get(v,'Abs_Cons', 2,'ID_abs')
            if data and data.dcl.tag == 'Data' then
                xxx = data
                yyy = node('Set_Abs_Val', v.ln,
                        node('Abs_Val', v.ln, 'val', v),
                        node('Loc', v.ln,
                            node('ID_int', v.ln, id)))
            elseif v.tag == 'ID_any' then
                local vars = AST.asr(code.dcl,'Code', 4,'Block', 1,'Stmts', 2,'Do', 3,'Block').dcls
                if vars[i] then
                    local is_alias,tp = unpack(vars[i])
                    if not is_alias then
                        if TYPES.abs_dcl(tp,'Data') then
                            xxx = tp[1]
                            yyy = node('Set_Any', v.ln,
                                    v,
                                    node('Loc', v.ln,
                                        node('ID_int', v.ln, id)))
                        end
                    end
                end
            end

            if xxx then
                local set =
                    node('Stmts', v.ln,
                        node('Var', v.ln,
                            false,
                            node('Type', v.ln,
                                AST.copy(xxx)),
                            id),
                        yyy)

                local get = node('ID_int', v.ln, id)

                local stmts, j = AST.par(code,'Stmts')
                local t = stmts.__dcls_cons or {}
                stmts.__dcls_cons = t
                t[#t+1] = { j, set, get }
                t.conss = t.conss or {}
                t.conss[#t.conss+1] = me
                is_pending = true

                AST.set(Abslist,i,get)
            end
        end
        if not is_pending then
            EXPS.F.Abs_Cons(me)
        end
    end,

    Stmts__POS = function (me)
        local t = me.__dcls_cons
        if t then
            for i=#t, 1, -1 do
                local j, set, get = unpack(t[i])

                AST.insert(me, j, set)
                AST.visit_fs(set)

                get[DCLS.F] = nil
                AST.visit_fs(get)
            end

            for _, cons in ipairs(t.conss) do
                cons[DCLS.F] = nil
                AST.visit_fs(cons)
            end
        end
    end,

    ---------------------------------------------------------------------------

-- GET: ID -> DCL

    ID_prim = function (me)
        local id = unpack(me)
        me.dcl = DCLS.asr(me, AST.par(me,'Block'), id, true, 'primitive identifier')
    end,

    ID_nat = function (me)
        local id = unpack(me)
        me.dcl = DCLS.asr(me, AST.par(me,'Block'), id, true, 'native identifier')
        EXPS.F.ID_nat(me)
    end,

    ID_ext = function (me)
        local id = unpack(me)
        me.dcl = DCLS.asr(me, AST.par(me,'Block'), id, true, 'external identifier')
    end,

    ID_abs = function (me)
        local id = unpack(me)
        local blk do
            local obj = AST.get(me,1,'Abs_Cons', 1,'Loc')
            if obj then
                assert(obj.info.tp)
                local Code = TYPES.abs_dcl(obj.info.tp, 'Code')
                blk = AST.asr(Code,'Code', 4,'Block', 1,'Stmts', 2,'Do', 3,'Block', 1,'Stmts', 2,'Block', 1,'Stmts', 2,'Block')
            else
                blk = AST.par(me,'Block')
            end
        end
        me.dcl = DCLS.asr(me, blk, id, true, 'abstraction')
    end,

    ID_int = function (me)
        local id = unpack(me)
        local blk = AST.par(me,'Block')
        local can_cross = false
        do
            -- escape should refer to the parent "a"
            -- var int a = do var int a; ... escape ...; end;
            local set = AST.par(me,'Set_Exp')
            if set and set.__dcls_is_escape and AST.is_par(set[2],me) then
                -- __dcls_is_escape holds the enclosing "do" node
                blk = AST.par(set.__dcls_is_escape, 'Block')
                can_cross = true
            end
        end
        me.dcl = DCLS.asr(me, blk, id, can_cross, 'internal identifier')
        EXPS.F.ID_int(me)
    end,

    Loc = function (me)
        local e = unpack(me)
        me.dcl = e.dcl
        EXPS.F.Loc(me)
    end,

    ['Exp_.'] = function (me)
        local _, e, member = unpack(me)
        if e.tag == 'Outer' then
            local code
            local out = DCLS.outer(me)
            me.dcl,code = DCLS.asr(me, AST.par(out,'Block'), member, true, 'internal identifier')
            e.__dcls_outer = code  -- how many "code" crosses?
        elseif e.dcl and e.dcl.tag == 'Var' then
            local abs = AST.get(e.dcl,'Var', 2,'Type', 1,'ID_abs')
            if abs then
                local dcl = AST.get(abs.dcl,'Data',3,'Block')
                if dcl then
                    me.dcl = DCLS.asr(me, dcl, member, false, 'field')
                else
                    dcl = AST.asr(abs.dcl,'Code',4,'Block',1,'Stmts',2,'Do',3,'Block',1,'Stmts',2,'Block')
                    me.dcl = DCLS.asr(me, dcl, member, false, 'parameter')
                end
            else
                ASR(AST.get(e.dcl,'Var', 2,'Type', 1,'ID_nat'), me,
                    'invalid member access')
            end
        end
        EXPS.F['Exp_.'](me)
    end,

    Set_Any = function (me)
        local _, to = unpack(me)
        local alias = unpack(to.info.dcl)
        if alias then
            me.tag = 'Set_Alias'
        end
    end,

    ---------------------------------------------------------------------------

    Loop_Num = function (me)
        local _, i = unpack(me)
        i.dcl.is_read_only = true
    end,

    __loop = function (me)
        return me.tag=='Loop' or me.tag=='Loop_Num' or me.tag=='Loop_Pool'
    end,
    __outer = function (me)
        local lbl = unpack(me)
        for loop in AST.iter(DCLS.F.__loop) do
            if not lbl then
                return loop
            else
                local _, id = unpack(loop)
                if id and id.dcl==lbl.dcl then
                    return loop
                end
            end
        end
    end,
    Break = function (me)
        me.outer = DCLS.F.__outer(me)
        ASR(me.outer, me,
            'invalid `break` : expected matching enclosing `loop`')
    end,
    Continue = function (me)
        me.outer = DCLS.F.__outer(me)
        ASR(me.outer, me,
            'invalid `continue` : expected matching enclosing `loop`')
    end,

    TODO__POS = function (me)
        local id = unpack(me)
        if id == 'escape' then
            local _, esc = unpack(me)
            local id_int1 = (esc[1]==true) or esc[1][1]
            local do_ = nil
            for n in AST.iter() do
                if string.sub(n.tag,1,5)=='Async' or n.tag=='Data' or n.tag=='Code'
                    -- or n.tag=='Ext_Code_impl' or n.tag=='Ext_Req_impl'
                then
                    break
                end
                if n.tag == 'Do' then
                    local id_int2 = (n[1]==true) or n[1][1]
                    if id_int1 == id_int2 then
                        do_ = n
                        break
                    end
                end
            end
            ASR(do_, esc, 'invalid `escape` : no matching enclosing `do`')
            esc.outer = do_
            local _,outer,_,to = unpack(do_)
            local set = AST.get(me.__par,'Set_Exp') or AST.asr(me.__par,'Set_Alias')
            set.__dcls_is_escape = do_
            local fr = unpack(set)
            if to and type(to)~='boolean' then
                ASR(type(fr)~='boolean', me,
                    'invalid `escape` : expected expression')
                to.__dcls_is_escape = true
                return AST.copy(to)
            else
                ASR(type(fr)=='boolean', me,
                    'invalid `escape` : unexpected expression')
                set.tag = 'Nothing'
                return node('Nothing', me.ln)
            end
        else
            error'bug found'
        end
    end,
}

for k,v in pairs(EXPS.F) do
    if DCLS.F[k] then
        --DBG('>>>', k)
    else
        DCLS.F[k] = v
    end
end

AST.visit(DCLS.F)

end

    
do
CONSTS = {
    t2n = {
         us = 10^0,
         ms = 10^3,
          s = 10^6,
        min = 60*10^6,
          h = 60*60*10^6,
    },
}

F = {
    NUMBER = function (me)
        me.is_const = (TYPES.is_int(me.info.tp) and 'int') or 'real'
    end,

    SIZEOF = function (me)
        me.is_const = 'int'
    end,

    ID_nat = function (me)
        local mod = unpack(me.dcl)
        me.is_const = (mod == 'const')
    end,

    ['Exp_|'] = '__Exp_num_num',
    ['Exp_&'] = '__Exp_num_num',
    ['Exp_*'] = '__Exp_num_num',
    ['Exp_+'] = '__Exp_num_num',
    ['Exp_-'] = '__Exp_num_num',
    __Exp_num_num = function (me)
        local _, e1, e2 = unpack(me)
        if e1.is_const and e2.is_const then
            if e1.is_const=='real' or e2.is_const=='real' then
                me.is_const = 'real'
            elseif e1.is_const=='int' or e2.is_const=='int' then
                me.is_const = 'int'
            else
                assert(e1.is_const==true and e2.is_const==true)
                me.is_const = true
            end
        end
    end,

    ['Exp_1~'] = '__Exp_num',
    ['Exp_1+'] = '__Exp_num',
    ['Exp_1-'] = '__Exp_num',
    __Exp_num = function (me)
        local _, e = unpack(me)
        me.is_const = e.is_const
    end,

    ['Exp_$$'] = function (me)
        local dcl = AST.asr(me,'', 2,'').info.dcl
        local _,_,_,len = unpack(dcl)
        me.is_const = (len ~= '[]' and 'int')
    end,

    Exp_as = function (me)
        local _,e = unpack(me)
        me.is_const = e.is_const
    end,

    Loc = function (me)
        local e = unpack(me)
        me.is_const = e.is_const
    end,

    ---------------------------------------------------------------------------

    WCLOCKK = function (me)
        local h,min,s,ms,us = unpack(me)
        local T = CONSTS.t2n
        me.us = us*T.us + ms*T.ms + s*T.s + min*T.min + h*T.h
        ASR(me.us>0 and me.us<=2000000000, me,
            'invalid wall-clock time : constant is out of range')
    end,

    Vec = function (me)
        local is_alias,_,_,dim = unpack(me)
        if dim == '[]' then
            return
        end

        if is_alias or AST.par(me,'Data') then
            -- vector[n] int vec;
            ASR(dim.is_const=='int' or dim.is_const==true, dim,
                'invalid declaration : vector dimension must be an integer constant')
        else
            -- vector[1.5] int vec;
            ASR(TYPES.is_int(dim.info.tp), me,
                'invalid declaration : vector dimension must be an integer')
        end
    end,

    Pool = function (me)
        local _,_,_,dim = unpack(me)
        if dim == '[]' then
            return
        end
        ASR(dim.is_const, me, 'not implemented : dynamic limit for pools')
    end,

    Loop_Num = 'Loop',
    Loop = function (me)
        local max = unpack(me)
        if max then
            ASR(max.is_const=='int' or max.is_const==true, max,
                'invalid `loop` : limit must be an integer constant')
        end
    end,

    Data = function (me)
        local _, num = unpack(me)
        if num and num~='nothing' then
            ASR(num.is_const=='int' or num.is_const==true, num,
                'invalid `data` declaration : after `is` : expected integer constant')
        end
    end,
}

AST.visit(F)

end

    
do
local node = AST.node

F = {
    _Finalize__PRE = function (me)
        if #me == 3 then
            return      -- ok, already handled
        end

        local now,list,fin,pse,res,depth = unpack(me)

        local t = {}
        if #AST.asr(fin,'Block',1,'Stmts') > 0 then
            t[#t+1] = node('Finalize_Case', me.ln, 'CEU_INPUT__FINALIZE', fin)
        end
        if pse then
            t[#t+1] = node('Finalize_Case', me.ln, 'CEU_INPUT__PAUSE', pse)
        end
        if res then
            t[#t+1] = node('Finalize_Case', me.ln, 'CEU_INPUT__RESUME', res)
        end

        if #t == 0 then
            return node('Finalize',me.ln,now,list)
        end

        local x
        if #t <= 1 then
            x = unpack(t)
        else
            x = node('Par', me.ln, unpack(t))
        end

        return node('_Finalize_X',me.ln,now,list,x)
    end,

    Vec_Init__PRE = function (me)
        local vec = unpack(me)
        local _,_,_,dim = unpack(vec.info.dcl)
        if dim.is_const then
            return
        end

        if me.__fins_ok then
            return
        end
        me.__fins_ok = true

        local id = (me.tag=='Vec_Init' and 'Vec_Finalize') or 'Pool_Finalize'

        return node('Stmts', me.ln,
                me,
                node('_Finalize', me.ln,
                    false,
                    false,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node(id, me.ln,
                                AST.copy(vec)))),
                    false,
                    false))
    end,
    Pool_Init__PRE = 'Vec_Init__PRE',

    _Var_set_fin_X__PRE = function (me)
        local alias, Type, __ID_int, Exp_call = unpack(me)

        --  var & Type __ID_int = & Exp_call finalize with ... end
        -->>>
        --  var & Type __ID_int;
        --  do
        --      ID_int = & Exp_call;
        --  finalize with
        --      ...
        --  end

        return node('_Finalize', me.ln,
                node('Set_Alias', me.ln,
                    node('Exp_1&', Exp_call.ln, '&',
                        Exp_call),
                    node('Loc', Type.ln,
                        node('ID_int', Type.ln, __ID_int))),
                unpack(me,5))
    end,

    _Async_Isr__PRE = function (me)
        me.tag = 'Async_Isr'
        return node('Stmts', me.ln,
                me,
                node('_Finalize', me.ln,
                    false,
                    false,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Finalize_Async_Isr', me.ln))),
                    false,
                    false))
    end,

    _Lua_Do__PRE = function (me)
        me.tag = 'Lua_Do'
        return node('Block', me.ln,
                node('Stmts', me.ln,
                    node('Lua_Do_Open', me.ln, me.n),
                    node('_Finalize', me.ln,
                        false,
                        false,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('Lua_Do_Close', me.ln, me.n))),
                        false,
                        false),
                    me))
    end,
}

AST.visit(F)

end

    
do
local node = AST.node

SPAWNS = {}

SPAWNS.F = {
    Stmts__POS = function (me)
        return SPAWNS.F.__stmts_flatten(me), true
    end,
    __stmts_flatten = function (stmts, new)
        local new = new or node('Stmts', stmts.ln)
        for _, sub in ipairs(stmts) do
            if AST.is_node(sub) and sub.tag=='Stmts' then
                SPAWNS.F.__stmts_flatten(sub, new)
            else
                AST.set(new, #new+1, sub)
            end
        end
        return new
    end,
}
AST.visit(SPAWNS.F)

SPAWNS.G = {
    _SPAWN = function (par, I, spawn)
        -- all statements after myself
        local par_stmts = AST.asr(par, 'Stmts')
        local cnt_stmts = { unpack(par_stmts, I+1) }
        for i=I, #par_stmts do
            par_stmts[i] = nil
        end

        local ret =
            node('Par_Or', spawn.ln,
                node('Stmts', spawn.ln,
                    spawn,
                    node('Await_Forever', spawn.ln)),
                node('Stmts', spawn.ln,
                    unpack(cnt_stmts)))
        ret.__spawns = true
        return ret
    end,

    _Spawn_Block__PRE = function (me)
        me.tag = 'Stmts'
        return SPAWNS.G._SPAWN(me.__par, me.__i, me)
    end,

    Set_Abs_Spawn__PRE = function (me)
        if me.__spawns_ok then
            return
        else
            me.__spawns_ok = true
        end
        if AST.get(me,'', 1,'Abs_Spawn') then
            local block = AST.par(me,'Block')
            local ret = SPAWNS.G._SPAWN(me.__par, me.__i, me)
            if block.__adjs_is_abs_await then
                local awt = ret[2]
                AST.set(ret, 2, ret[1])
                AST.set(ret, 1, awt)
            end
            return ret
        end
    end,
    Abs_Spawn__PRE = function (me)
        if me.__spawns_ok or AST.get(me,1,'Set_Abs_Spawn') then
            return
        else
            me.__spawns_ok = true
        end
        -- par/or do <CEU_INPUT__PROPAGATE_CODE> with ... end
        return SPAWNS.G._SPAWN(me.__par, me.__i, me)
    end,

    _Finalize_X__PRE = function (me)
        me.tag = 'Finalize'
        return SPAWNS.G._SPAWN(me.__par, me.__i, me)
    end,

-- TODO: var&? Ff f1 = &f2;
    Var__PRE = function (me)
        if me.__spawns_ok then
            return
        else
            me.__spawns_ok = true
        end
        if (me.__dcls_code_alias == '&?') and (not me.__adjs_is_abs_await) then
            return SPAWNS.G._SPAWN(me.__par, me.__i, me)
        end
    end,

    Pool__PRE = function (me)
        if me.__spawns_ok then
            return
        else
            me.__spawns_ok = true
        end
        local alias = unpack(me)
        if not alias then
            return SPAWNS.G._SPAWN(me.__par, me.__i, me)
        end
    end,
}

AST.visit(SPAWNS.G)

end

    
do
STMTS = {}

STMTS.F = {

-- SETS

    Set_Exp = function (me)
        local fr, to = unpack(me)

        local err do
            if AST.get(me.__par,'Stmts', me.__i+1,'Escape') then
                err = 'invalid `escape`'
            else
                err = 'invalid assignment'
            end
        end

        if to.info.dcl.is_read_only then
            ASR(me.set_read_only, me,
                'invalid assignment : read-only variable "'..to.info.id..'"')
        end

        -- ctx
        INFO.asr_tag(to, {'Nat','Var','Pool'}, err)
        INFO.asr_tag(fr, {'Val','Nat','Var'}, err)
        ASR((not fr.info.dcl) or (fr.info.dcl[1]~='&?'), me,
            err..' : expected operator `!`')

        -- tp
        EXPS.check_tp(me, to.info.tp, fr.info.tp, err)

        if not TYPES.check(to.info.tp,'?') then
            ASR(not TYPES.check(fr.info.tp,'?'), me,
                'invalid assignment : expected operator `!`')
        end

        -- abs vs abs
        local to_abs = TYPES.abs_dcl(to.info.tp, 'Data')
        if to_abs then
            local is_alias = unpack(to.info)
            if not is_alias then
                local fr_abs = TYPES.abs_dcl(fr.info.tp, 'Data')
                local is_alias = unpack(fr.info)
                assert(not is_alias)

                EXPS.check_tp(me, to.info.tp, fr.info.tp, 'invalid assignment')
                ASR(to_abs.n_vars == fr_abs.n_vars, me,
                    'invalid assignment : `data` copy : unmatching fields')

                --ASR(to_abs.weaker=='plain', me,
                    --'invalid assignment : `data` copy : expected plain `data`')
            end
        end
    end,

    __set_vec = function (fr, to_info)
        AST.asr(fr, 'Vec_Cons')

        -- ctx
        for i, e in ipairs(fr) do
            local is_vec = (e.info and e.info.tag=='Vec')
            if e.tag == 'Vec_Tup' then
                -- tp
                local ps = unpack(e)
                if ps then
                    AST.asr(ps,'List_Exp')
                    for j, p in ipairs(ps) do
                        EXPS.check_tp(fr, to_info.tp, p.info.tp,
                            'invalid constructor : item #'..i..' : '..
                            'invalid expression list : item #'..j)
                    end
                end
            elseif e.tag == 'Lua' then
                -- TODO
            elseif TYPES.check(to_info.tp,'byte') and (not is_vec) then
                ASR(TYPES.check(e.info.tp,'_char','&&'), fr,
                    'invalid constructor : item #'..i..' : expected "_char&&"')
            else
                INFO.asr_tag(e, {'Vec'}, 'invalid constructor')
                assert(is_vec)
                EXPS.check_tp(fr, to_info.tp, e.info.tp,
                    'invalid constructor : item #'..i)
            end
        end
    end,
    Set_Vec = function (me)
        local fr, to = unpack(me)
        INFO.asr_tag(to, {'Vec'}, 'invalid constructor')
        STMTS.F.__set_vec(fr, to.info)

        ASR(not TYPES.is_nat(TYPES.get(to.info.tp,1)), me,
            'invalid constructor : expected internal type : got "'..TYPES.tostring(to.info.tp)..'"')

        -- OK: v1 = v1 ..
        -- NO: v1 = v2 ..
        -- NO: v1 = .. v1

        local loc = AST.get(fr,'',1,'Loc')
        if loc then
            ASR(AST.is_equal(to,loc), me,
                'invalid constructor : item #1 : '..
                'expected destination as source')
        end

        for i=2, #fr do
            local e = fr[i]
            ASR(not AST.is_equal(AST.asr(to,'Loc',1,''),e), me,
                'invalid constructor : item #'..i..' : '..
                'unexpected destination as source')
        end
    end,

    Set_Any = function (me)
        local _, to = unpack(me)
        --INFO.asr_tag(to, {'Var'}, 'invalid assignment')
        --ASR(TYPES.check(to.info.tp,'?'), me,
            --'invalid assignment : expected option destination')
    end,

    Set_Alias = function (me)
        local fr, to = unpack(me)
        local alias = unpack(to.info.dcl)

        if fr.tag == 'ID_any' then
            ASR(alias == '&?', me, 'invalid binding : expected option alias')
            return
        end

        -- ctx
        INFO.asr_tag(to, {'Var','Vec','Pool','Evt'}, 'invalid binding')
        INFO.asr_tag(fr, {'Alias'}, 'invalid binding')

        if fr[2].info.tag == 'Val' then
            ASR(fr[2].tag == 'Abs_Call', me, 'invalid binding : expected native type')
        end

        -- NO: var int x = &...
        -- NO: d.x = &...
        -- NO: x! = &...
        local Loc = AST.asr(to,'Loc')
        local ID_int = AST.get(Loc,'', 1,'ID_int')
        local op = unpack(Loc[1])
        ASR(ID_int, me, 'invalid binding : unexpected context for operator `'..op..'`')
        ASR(ID_int.dcl[1], me, 'invalid binding : expected declaration with `&`')

        -- NO: f1 = &f              // f may die
        if to.info.tag=='Var' and TYPES.abs_dcl(to.info.tp,'Code') then
            --ASR(alias == '&?', me, 'invalid binding : expected `spawn`')
        end

        -- tp

        EXPS.check_tp(me, to.info.tp, fr.info.tp, 'invalid binding', true)

        local is_call = false
        if fr[2].tag=='Exp_call' or fr[2].tag=='Abs_Call' then
            is_call = true
            if fr[2].tag == 'Exp_call' then
                assert(fr.info.dcl and fr.info.dcl.tag=='Nat')
                ASR(TYPES.is_nat(to.info.tp), me,
                    'invalid binding : expected `native` type')
            else
                local ID_abs = AST.asr(fr,'', 2,'Abs_Call', 2,'Abs_Cons',
                                              2,'ID_abs')
                local tp = AST.asr(ID_abs.dcl,'Code', 4,'Block', 1,'Stmts',
                                                      1,'Code_Ret', 1,'', 2,'Type')
                EXPS.check_tp(me, to.info.tp, tp, 'invalid binding', true)
            end
        else
            EXPS.check_tag(me, to.info.tag, fr.info.dcl.tag, 'invalid binding')

            -- NO: ... = &_V        // native ID
            ASR(fr.info.dcl.tag~='Nat', me,
                'invalid binding : unexpected native identifier')

            if fr.info.dcl[1] then
                ASR(to.info.dcl[1]=='&?' or to.info.dcl[1]==fr.info.dcl[1], me,
                    'invalid binding : unmatching alias `&` declaration')
            end
        end

        -- option type
        if TYPES.check(to.info.tp,'?') then
            --if TYPES.check(fr.info.tp,'_') and
               --TYPES.is_nat(TYPES.pop(to.info.tp,'?'))
            --then
            if is_call and TYPES.is_nat(TYPES.pop(to.info.tp,'?')) then
                -- OK:
                --  var& _TP? = &_f();
                --  var& _TP? = &Ff();
            else
                -- NO:
                -- var  int  x;
                -- var& int? i = &x;
                ASR(TYPES.check(fr.info.tp,'?'), me,
                    'invalid binding : types mismatch : "'..TYPES.tostring(to.info.tp)..
                                                  '" <= "'..TYPES.tostring(fr.info.tp)..'"')
            end
        end

        -- dim
        if to.info.tag == 'Vec' then
            local _,_,_,to_dim = unpack(to.info.dcl)
            local _,_,_,fr_dim = unpack(fr.info.dcl)
            ASR(EXPS.check_dim(to_dim,fr_dim), me,
                'invalid binding : dimension mismatch')
        end
    end,

    Set_Lua = function (me)
        local _,to = unpack(me)
        INFO.asr_tag(to, {'Nat','Var'}, 'invalid Lua assignment')
    end,

    Set_Async_Thread = function (me)
        local _,to = unpack(me)

        -- ctx
        INFO.asr_tag(to, {'Nat','Var'}, 'invalid `async/thread` assignment')

        -- tp
        ASR(TYPES.check(to.info.tp,'bool'), me,
            'invalid `async/thread` assignment : expected `bool` destination')
    end,

-- ABS

    Set_Abs_Val = function (me)
        local fr, to = unpack(me)
        local Abs_Cons = AST.asr(fr,'Abs_Val', 2,'Abs_Cons')
        local _,ID_abs = unpack(Abs_Cons)

        -- ctx
        INFO.asr_tag(to, {'Var'}, 'invalid constructor')
        ASR(ID_abs.dcl.tag == 'Data', me,
            'invalid constructor : expected `data` abstraction : got `code` "'..
            ID_abs.dcl.id..'" ('..ID_abs.dcl.ln[1]..':'..ID_abs.dcl.ln[2]..')')

        -- tp
        EXPS.check_tp(me, to.info.tp, Abs_Cons.info.tp, 'invalid constructor')

        -- NO: instantiate "nothing" data
        --  data Dd as nothing;
        --  var Dd d = val Dd();
        local _, num = unpack(ID_abs.dcl)
        ASR(num ~= 'nothing', me,
            'invalid constructor : cannot instantiate `data` "'..ID_abs.dcl.id..'"')

        -- exact match on constructor
        local to_str = TYPES.tostring(to.info.tp)
        local fr_str = TYPES.tostring(Abs_Cons.info.tp)
        if to_str ~= fr_str then
            local _,_,blk = unpack(ID_abs.dcl)
            -- or source has no extra fields
            local super = to.info.tp[1]
            ASR(#AST.asr(ID_abs.dcl,'Data',3,'Block').dcls ==
                #AST.asr(super.dcl ,'Data',3,'Block').dcls, me,
                'invalid constructor : types mismatch : "'..to_str..'" <= "'..fr_str..'"')
        end
    end,
    Set_Abs_New = function (me)
        local _, to = unpack(me)

        -- ctx
        INFO.asr_tag(to, {'Var','Pool'}, 'invalid constructor')
    end,
    Set_Abs_Spawn = function (me)
        local _, to = unpack(me)

        -- ctx
        INFO.asr_tag(to, {'Var'}, 'invalid constructor')

        -- tp
        local cons = AST.asr(me,'', 1,'', 2,'Abs_Cons')
        EXPS.check_tp(me, to.info.tp, cons.info.tp, 'invalid constructor')
    end,

-- EMIT

    Set_Emit_Ext_emit = function (me)
        local ID_ext = AST.asr(me,'', 1,'Emit_Ext_emit', 1,'ID_ext')
        local io,_ = unpack(ID_ext.dcl)
        ASR(io=='output', me,
            'invalid assignment : `input`')
    end,

    Set_Await_one = function (me)
        local fr, to = unpack(me)
        assert(fr.tag=='Await_Wclock' or fr.tag=='Abs_Spawn' or fr.tag=='Await_Int')

        EXPS.check_tp(me, to.info.tp, fr.tp or fr.info.tp, 'invalid assignment')

        if me.__adjs_is_watching then
            -- var int? us = watching 1s do ... end
            ASR(TYPES.check(to.info.tp,'?'), me,
                'invalid `watching` assignment : expected option type `?` : got "'..TYPES.tostring(to.info.tp)..'"')
        end
    end,

    Set_Await_many = function (me)
        local fr, to = unpack(me)

        -- ctx
        for _, Loc in ipairs(to) do
            if Loc.tag ~= 'ID_any' then
                INFO.asr_tag(Loc, {'Nat','Var'}, 'invalid assignment')
            end
        end

        -- tp
        if fr.tag == 'Await_Int' then
            ASR(fr.tp, me,
                'invalid assignment : `code` executes forever')
        end

        EXPS.check_tp(me, to.tp, fr.tp, 'invalid assignment')

        if me.__adjs_is_watching then
            for _, e in ipairs(to) do
                -- var int? us = watching 1s do ... end
                ASR(TYPES.check(e.info.tp,'?'), me,
                    'invalid `watching` assignment : expected option type `?` : got "'..TYPES.tostring(e.info.tp)..'"')
            end
        end
    end,

-- AWAITS

    __await_ext_err = function (ID_ext, inout_expected)
        if ID_ext.tag ~= 'ID_ext' then
            return false, 'expected external identifier'
        end

        local inout_have = unpack(ID_ext.dcl)

        if inout_have == inout_expected then
            return true
        else
            return false, 'expected `'..inout_expected..'` external identifier'
        end
    end,

    Await_Ext = function (me)
        local ID_ext = unpack(me)

        -- ctx
        local ok, msg = STMTS.F.__await_ext_err(ID_ext, 'input')
        ASR(ok, me, msg and 'invalid `await` : '..msg)

        me.tp = ID_ext.dcl[2]
    end,

    Await_Pause = function (me)
        me.tp = AST.node('Typelist', me.ln, TYPES.new(me, 'bool'))
    end,

    Await_Wclock = function (me)
        local e = unpack(me)
        if e.tag == 'WCLOCKE' then
            local n = unpack(e)
            ASR(TYPES.is_int(n.info.tp), me, 'invalid expression : expected integer type')
        end
        me.tp = TYPES.new(me, 'int')
    end,

    Abs_Spawn = function (me)
        local mods_call,Abs_Cons = unpack(me)
        local ID_abs = AST.asr(Abs_Cons,'Abs_Cons', 2,'ID_abs')
        me.__code = AST.asr(ID_abs.dcl,'Code')

        local mods_dcl = unpack(me.__code)
        ASR(mods_dcl.await, me,
            'invalid `'..AST.tag2id[me.tag]..'` : expected `code/await` declaration '..
                '('..me.__code.ln[1]..':'..me.__code.ln[2]..')')

        if mods_dcl.dynamic then
            ASR(mods_call.dynamic or mods_call.static, me,
                'invalid `'..AST.tag2id[me.tag]..'` : expected `/dynamic` or `/static` modifier')
        else
            local mod = (mods_call.dynamic or mods_call.static)
            ASR(not mod, me, mod and
                'invalid `'..AST.tag2id[me.tag]..'` : unexpected `/'..mod..'` modifier')
        end

        ASR(AST.par(me,'Code') ~= me.__code, me,
            'invalid `'..AST.tag2id[me.tag]..'` : unexpected recursive invocation')

        local ret = AST.get(me.__code,'', 4,'Block', 1,'Stmts',
                                          1,'Code_Ret', 1,'', 2,'Type')
        me.tp = ret and AST.copy(ret)

        local watch = AST.par(me, 'Watching')
        if watch then
            local me1 = AST.get(watch,'', 1,'Par_Or', 1,'Block', 1,'Stmts',
                                          1,'Block',  1,'Stmts',
                                          1,'Par_Or', 2,'Stmts', 1,'Par_Or',
                                          1,'Stmts',  1,'Set_Abs_Spawn',
                                          1,'Abs_Spawn')
            if me1 == me then
                --ASR(ret, watch, 'invalid `watching` : `code` executes forever')
            end
        end
     end,

    Await_Int = function (me, tag)
        local e = unpack(me)
        local alias, _ = unpack(e.info.dcl)

        -- ctx
        INFO.asr_tag(e, {'Var','Evt','Pool'}, 'invalid `await`')
        if e.info.tag == 'Var' then
            ASR(e.info.dcl[1] == '&?', me,
                'invalid `await` : expected `var` with `&?` modifier')
        end

        -- tp
        if e.info.tag == 'Var' then
            local abs = TYPES.abs_dcl(e.info.tp, 'Code')
            ASR(abs, me, 'invalid `await` : expected `code/await` abstraction')
            assert(alias == '&?')
            local tp = AST.get(abs,'Code', 4,'Block', 1,'Stmts',
                                           1,'Code_Ret', 1,'', 2,'Type')
            if tp then
                local ID = AST.get(me,'', 1,'Loc', 1,'ID_int')
                if string.sub(ID[1],1,5) ~= '_spw_' then
                    tp = TYPES.push(tp, '?')
                end
                me.tp = AST.node('Typelist', me.ln, AST.copy(tp))
            else
                -- will fail in Set_Await_many
            end
        else
            me.tp = e.info.tp
        end
    end,

    Kill = function (me)
        local loc, e = unpack(me)
        local alias = unpack(loc.info.dcl)

        -- ctx
        INFO.asr_tag(loc, {'Var'}, 'invalid `kill`')

        -- tp
        local abs = TYPES.abs_dcl(loc.info.tp, 'Code')
        ASR(abs, me, 'invalid `kill` : expected `code/await` abstraction')
        ASR(alias=='&?', me, 'invalid `kill` : expected `&?` alias')
        local tp = AST.get(abs,'Code', 4,'Block', 1,'Stmts',
                                       1,'Code_Ret', 1,'', 2,'Type')
        ASR(tp, me, 'invalid kill : `code/await` executes forever')
        -- TODO: check e vs tp
    end,

-- STATEMENTS

    Await_Until = function (me)
        local _, cond = unpack(me)
        if cond then
            ASR(TYPES.check(cond.info.tp,'bool'), me,
                'invalid expression : `until` condition must be of boolean type')
        end
    end,

    Pause_If = function (me)
        local e = unpack(me)

        -- ctx
        local ok, msg = STMTS.F.__await_ext_err(e, 'input')
        if not ok then
            INFO.asr_tag(e, {'Evt'}, 'invalid `pause/if`')
        end

        -- tp
        local Typelist = AST.asr((e.dcl and e.dcl[2]) or e.info.tp,'Typelist')
        ASR(#Typelist==1 and TYPES.check(Typelist[1],'bool'), me,
            'invalid `pause/if` : expected event of type `bool`')
    end,

    Do = function (me)
        local _,_,_,e = unpack(me)
        if e then
            INFO.asr_tag(e, {'Nat','Var'}, 'invalid assignment')
        end
    end,

    If = function (me)
        local cnd = unpack(me)
        ASR(TYPES.check(cnd.info.tp,'bool'), me,
            'invalid `if` condition : expected boolean type')
    end,

    Loop_Num = function (me)
        local _, i, range = unpack(me)
        local fr,_,to,step = unpack(range)
        local i_tp, fr_tp, to_tp, s_tp = i.info.tp,
                                         fr.info.tp,
                                         (to.info and to.info.tp or step.info.tp),
                                         step.info.tp
        ASR(TYPES.is_num(i_tp), me, 'invalid `loop` : expected numeric variable')
        ASR(TYPES.contains(i_tp,fr_tp), me,
            'invalid control variable : types mismatch : "'..TYPES.tostring(i_tp)..'" <= "'..TYPES.tostring(fr_tp)..'"')
        ASR(TYPES.contains(i_tp,to_tp), me,
            'invalid control variable : types mismatch : "'..TYPES.tostring(i_tp)..'" <= "'..TYPES.tostring(to_tp)..'"')
        ASR(TYPES.contains(i_tp,s_tp), me,
            'invalid control variable : types mismatch : "'..TYPES.tostring(i_tp)..'" <= "'..TYPES.tostring(s_tp)..'"')
    end,

    Loop_Pool = function (me)
        local _,i,pool = unpack(me)

        -- ctx
        INFO.asr_tag(pool, {'Pool'}, 'invalid `pool` iterator')

        -- tp
        if i.tag ~= 'ID_any' then
            ASR(TYPES.contains(i.info.tp, pool.info.tp), me,
                'invalid control variable : types mismatch : "'..TYPES.tostring(i.info.tp)..'" <= "'..TYPES.tostring(pool.info.tp)..'"')
        end
    end,

-- CALL, EMIT

    Emit_Evt = function (me)
        local e, ps = unpack(me)

        -- ctx
        INFO.asr_tag(e, {'Evt'}, 'invalid `emit`')

        -- tp
        EXPS.check_tp(me, e.info.tp, ps.tp, 'invalid `emit`')

        ASR(e.info.dcl[1] ~= '&?', me,
            'invalid `emit` : unexpected `event` with `&?` modifier')
    end,

    Emit_Ext_emit = function (me)
        local ID_ext, ps = unpack(me)

        -- ctx
        local have = unpack(ID_ext.dcl)
        local expects do
            if ID_ext.dcl.tag ~= 'Ext' then
                expects = 'error'
            elseif AST.par(me,'Async') or AST.par(me,'Async_Isr') then
                expects = 'ok'
            else
                expects = 'output'
            end
        end

        ASR(have==expects or expects=='ok', me,
            'invalid `emit` : '..
            'unexpected context for '..AST.tag2id[ID_ext.dcl.tag]..' `'..
            have..'` "'..ID_ext.dcl.id..'"')

        -- tp
        EXPS.check_tp(me, ID_ext.dcl[2], ps.tp, 'invalid `emit`')
    end,

    Emit_Ext_call = function (me)
        local ID_ext, ps = unpack(me)

        -- tp
        local _,_,_,ins = unpack(ID_ext.dcl)
        local Typelist = AST.node('Typelist', me)
        for i, item in ipairs(ins) do
            local Type = AST.asr(item,'', 4,'Type')
            Typelist[i] = Type
        end
        EXPS.check_tp(me, Typelist, ps.tp, 'invalid call')
    end,

    Stmt_Call = function (me)
        local f = unpack(me)
        ASR(f.tag=='Exp_call' or f.tag=='Abs_Call', me, 'invalid call')
    end,
    Exp_call = function (me)
        local _, e, ps = unpack(me)

        -- tp
        for _,p in ipairs(ps) do
            -- tp
            local is_opt = (p.info.dcl and p.info.dcl[1]=='&?')
            ASR(not (is_opt or TYPES.check(p.info.tp,'?')), me,
                'invalid call : unexpected context for operator `?`')

            if p.info.tag ~= 'Nat' then
                local is_alias = unpack(p.info)
                ASR(not is_alias, me,
                    'invalid call : unexpected context for operator `&`')
            end
        end
    end,

-- VARLIST, EXPLIST

    __typelist = function (me)
        local Typelist = AST.node('Typelist', me.ln)
        for i, e in ipairs(me) do
            if e.tag == 'ID_any' then
                Typelist[i] = true
            else
                Typelist[i] = AST.copy(e.info.tp)
            end
        end
        return Typelist
    end,

    List_Exp = function (me)
        -- ctx
        for i, e in ipairs(me) do
            if e.tag == 'ID_any' then
                -- ok
            elseif AST.par(me,'Exp_call') then
                INFO.asr_tag(e, {'Val','Nat','Var'},
                    'invalid expression list : item #'..i)
            else
                INFO.asr_tag(e, {'Val','Nat','Var','Alias'},
                    'invalid expression list : item #'..i)
            end
        end

        -- tp
        me.tp = STMTS.F.__typelist(me)
    end,

    List_Loc = function (me)
        -- ctx
        for _, var in ipairs(me) do
            if var.tag ~= 'ID_any' then
                INFO.asr_tag(var, {'Var','Vec','Nat'}, 'invalid variable')
            end
        end

        -- tp
        me.tp = STMTS.F.__typelist(me)
    end,

    List_Var = function (me)
        -- ctx
        for _, var in ipairs(me) do
            if var.tag ~= 'ID_any' then
                INFO.asr_tag(var, {'Var','Vec','Evt'}, 'invalid variable')
            end
        end

        -- tp
        me.tp = STMTS.F.__typelist(me)
    end,
}

AST.visit(STMTS.F)

end

    
do
local function err_inits (dcl, stmt, msg, endof)
    endof = (endof and 'end of ') or ''
    ASR(false, dcl,
        'uninitialized '..AST.tag2id[dcl.tag]..' "'..dcl.id..'" : '..
        'reached '..(msg or (endof..'`'..AST.tag2id[stmt.tag]..'`'))..
                ' ('..stmt.ln[1]..':'..stmt.ln[2]..')')
end

local function run_inits (par, i, Dcl, stop, dont_await)
    local me = par[i]
    if me == nil then
        if par == stop then
            return false
        elseif par.__par == nil then
            return false
        elseif par.tag == 'Code' then
            return 'Code', par, true
        else
            return run_inits(par.__par, par.__i+1, Dcl, stop, dont_await)
        end
    elseif not AST.is_node(me) then
        return run_inits(par, i+1, Dcl, stop, dont_await)
    end
    --assert(not __detect_cycles[me], me.n)
    --__detect_cycles[me] = true

    local is_last_watching do
        if me.tag=='Par_Or' and me.__par.tag=='Watching' then
            local x = me
            is_last_watching = true
            while x.__par.tag ~= 'Code' do
                if x.__i ~= #x.__par then
                    local do_int = AST.get(x.__par,'Do',4,'Loc',1,'ID_int')
                    if do_int and do_int[1]=='_ret' and x.__i==3 then
                        break   -- ok, last in ROOT
                    end

-- HACK_04: check escape/set_exp (will fix with exceptions)
                    -- check if all statements after myself are code dcls or escape
                    for i=x.__i+1, #x.__par do
                        if x.__par[i].tag~='Code' and x.__par[i].tag~='Escape' and x.__par[i].tag~='Set_Exp' and x.__par[i].tag~='Var' and x.__par[i].tag~='Set_Abs_Val' and x.__par[i].tag~='Throw' then
                            is_last_watching = false        -- no: error
                            break
                        elseif x.__par[i].tag ~= 'Code' then
-- HACK_04
                            run_inits(x.__par[i], 1, Dcl, x.__par[i])
                        end
                    end

                    if not is_last_watching then
                        break
                    end
                end
                x = x.__par
            end
        end
    end

    if dont_await and me.tag=='Y' then
        err_inits(Dcl, me, 'yielding statement')

    elseif me.tag == 'Code' then
        -- skip nested code
        return run_inits(par, i+1, Dcl, stop, dont_await)

    elseif me.tag == 'Escape' then
        local blk = AST.asr(me.outer,'',3,'Block')
        if AST.depth(blk) <= AST.depth(Dcl.blk) then
            return 'Escape', me
        else
            return run_inits(blk, #blk+1, Dcl, stop, dont_await)
        end

    elseif me.tag == 'Break' then
        local blk = AST.get(me.outer,'',2,'Block')
                or  AST.asr(me.outer,'',4,'Block')
        if AST.depth(blk) <= AST.depth(Dcl.blk) then
            return 'Break', me
        else
            return run_inits(blk, #blk+1, Dcl, stop, dont_await)
        end

    -- error: access to Dcl
    elseif me.tag == 'ID_int' then
        local async = AST.par(me, 'Async')
        local list = async and AST.get(async,'',2,'List_Var')
        if me.__par.tag == 'Do' then
            -- ok: do/a ... end
        elseif async and list and AST.is_par(list,me) then
            -- ok: async(a) do ... end
        elseif me.dcl == Dcl then
            local ok = AST.par(me,'Vec_Init') or AST.par(me,'Vec_Finalize')
            local set = AST.par(me,'Set_Exp') or AST.par(me,'Set_Any') or
                        AST.par(me,'Set_Abs_Val') or AST.par(me,'Set_Abs_Spawn')
            if not (ok or (set and set.__dcls_defaults)) then
                err_inits(Dcl, me, 'read access')
            end
        end

    elseif me.__spawns and (AST.get(me,'Par_Or', 1,'Stmts', 1,'Finalize')  or
                            AST.get(me,'Par_Or', 1,'Stmts', 1,'Var') or
                            AST.get(me,'Par_Or', 1,'Stmts', 1,'Set_Abs_Spawn') or
                            AST.get(me,'Par_Or', 1,'Stmts', 1,'Pool'))
    then
        -- f = spawn Ff();
        -- f1 = &f2
        local s1, s2 = unpack(me)
        local ok1,stmt1 = run_inits(s1, 1, Dcl, s1, dont_await)
        if ok1 then
            return true, me
        end
        return run_inits(s2, 1, Dcl, stop, dont_await)

    elseif (me.__spawns and AST.get(me,'Par_Or', 1,'Stmts', 1,'Abs_Spawn'))
            or is_last_watching
    then
        -- spawn Ff();
        -- do ... watching f do ... end end
        if not is_last_watching then
            local spw = AST.asr(me,'Par_Or', 1,'Stmts', 1,'Abs_Spawn')
            run_inits(spw, 1, Dcl, spw, dont_await)
        end
        local s1, s2 = unpack(me)
        return run_inits(s2, 1, Dcl, stop, dont_await)

    elseif me.tag=='If' or me.tag=='Par_Or' or me.tag=='Par_And' or me.tag=='Par' then
        local s1, s2 do
            if me.tag == 'If' then
                _, s1, s2 = unpack(me)
            elseif me.tag=='Par_Or' or me.tag=='Par_And' or me.tag=='Par' then
                s1, s2 = unpack(me)
            else
                error 'bug found'
            end
        end

        local ok1,stmt1 = run_inits(s1, 1, Dcl, s1, dont_await)
        local ok2,stmt2 = run_inits(s2, 1, Dcl, s2, dont_await)

        if ok1 or ok2 then
            if (ok1=='Escape' or ok2=='Escape') and Dcl.blk.__adjs_2 then
                return me.tag, (ok1=='Escape' and stmt1 or stmt2)
            elseif ok1 and ok2 then
                return true, me
            else
                -- don't allow only one because of alias binding (2x)
                err_inits(Dcl, me, 'end of `'..AST.tag2id[me.tag]..'`')
            end
        else
            return run_inits(me, #me, Dcl, stop, dont_await)
        end

    -- ok: found assignment
    elseif me.tag=='Loop_Num' or me.tag=='Loop_Pool' then
        local _,i = unpack(me)
        if i.dcl == Dcl then
            return true, me
        end

    -- ok: found assignment
    elseif string.sub(me.tag,1,4)=='Set_' then
        local alias = unpack(Dcl)

        local fr, to = unpack(me)
        if me.tag == 'Set_Exp' then
            -- var int a = a+1;
            local ok = run_inits(me, 1, Dcl, fr, dont_await)
            assert(not ok)
        end

        -- equalize all with Set_Await_many
        if to.tag ~= 'List_Loc' then
            to = { to }
        end

        for _, sub in ipairs(to) do
            if sub.tag ~= 'ID_any' then
                if AST.get(sub,'', 1,'ID_int') then
                    -- ID = ...;
                    local ID_int = AST.asr(sub,'Loc', 1,'ID_int')
                    if ID_int.dcl == Dcl then
                        if alias == '&' then
                            local loop = AST.par(me, DCLS.F.__loop)
                            if loop then
                                ASR(AST.depth(loop) < AST.depth(Dcl), me,
                                    'invalid binding : crossing `loop` ('..loop.ln[1]..':'..loop.ln[2]..')')
                            end
                            ASR(me.tag=='Set_Alias' or me.tag=='Set_Abs_Spawn', me,
                                'invalid binding : expected operator `&` in the right side')
                        else
                            --assert(me.tag ~= 'Set_Alias')
                        end

                        me.is_init = true
                        return true, me                 -- stop, found init
                    end
                else
                    -- ID.field = ...;  // ERR: counts as read, not write
                    if sub.info.dcl == Dcl then
                        err_inits(Dcl, sub, 'read access')
                    end
                end
            end
        end

    elseif me.tag == 'Do' then
        -- a = do ... end
        local _,_,body,Loc = unpack(me)
        if Loc then
            local ID_int = AST.asr(Loc,'Loc', 1,'ID_int')
            if ID_int.dcl == Dcl then
                return true, me                     -- stop, found init
            end
        end
    end

    return run_inits(me, 1, Dcl, stop, dont_await)
end

F = {
    Pool = 'Var',
    Vec  = 'Var',
    Evt  = 'Var',
    Var  = function (me)
        local alias,tp = unpack(me)
        local code = AST.par(me, 'Code')

        -- RUN_INITS
        if me.is_implicit                   or      -- compiler defined
           AST.get(me.blk,1,'Ext_impl')     or      -- "output" parameter
           AST.get(me.blk,4,'Code')         or      -- "code" parameter
           AST.par(me,'Data')               or      -- "data" member
           code and code.is_dyn_base        or      -- base dynamic class
           alias == '&?'                    or      -- option alias
           TYPES.check(tp,'?') and (not alias)      -- optional initialization
        then
            -- ok: don't need initialization
        else
            if me.tag=='Var' or     -- all vars must be inited
               alias == '&'  or     -- all aliases must be bound
               tp.tag=='Type' and TYPES.is_nat(tp) and assert(me.tag=='Vec')
            then
                -- var x = ...
                -- event& e = ...
                --__detect_cycles = {}
                local dont_await = AST.get(me.blk,6,'Code') -- mid param
                local ok,stmt,endof = run_inits(me, #me+1, me, AST.par(me,'Code'), dont_await)
                if ok and ok~=true then
                    if (ok=='Code' or ok=='Escape') and me.__dcls_unused
                        and (not (code and code[2].await and me.blk.__adjs_2))
                    then
                        -- ok, warning generated (unless in init list)
                    --elseif ok=='Escape' and me.blk.__adjs_2 then
                    elseif me.blk.__adjs_2 then
                    else
                        err_inits(me, stmt, nil, endof) --, 'end of '..AST.tag2id[me.tag])
                    end
                end
            end
        end
    end,

--[[
    Set_Abs_Spawn = 'Set_Alias',
    Set_Alias = function (me)
        local _,to = unpack(me)
        if me.is_init or to.__dcls_is_escape then
            return  -- I'm the one who created the binding
        end

        ASR(false, me,
            'invalid binding : '..
            AST.tag2id[to.info.dcl.tag]..
            ' "'..to.info.dcl.id..'" is already bound')
    end,
]]

    ID_int = function (me)
        local is_alias = unpack(me.dcl)
        if is_alias then
            return
        end

        -- NO
        for par in AST.iter() do
            if par.tag == 'Do' then
                local lbl,_,_,to = unpack(par)
                if to then
                    local set = AST.par(me, 'Set_Exp')
                    set = set and set.__dcls_is_escape and AST.is_par(set[2],me)
                    ASR(me.__par.tag=='Escape' or lbl==me or AST.is_par(to,me) or
                        set or (not (AST.is_equal(to.info.dcl,me.info.dcl) and to.info.dcl.blk==me.info.dcl.blk)),
                        --set or (to.info.dcl~=me.info.dcl),
                        me,
                        'invalid access to '..AST.tag2id[me.info.dcl.tag]
                            ..' "'..me.info.dcl.id..'" : '
                            ..'assignment in enclosing `do` ('
                            ..to.ln[1]..':'..to.ln[2]..')')
                end
            end
        end
    end,
}

AST.visit(F)

end

    
do
local __is_set = function (me) return string.sub(me.tag,1,4)=='Set_' end

local function run_ptrs (par, i, Dcl, stop)
    local me = par[i]
    if me == nil then
        if par == stop then
            return true                     -- no stop found, continue with pointer accesses
        else
            return run_ptrs(par.__par, par.__i+1, Dcl, stop)
        end
    elseif not AST.is_node(me) then
        return run_ptrs(par, i+1, Dcl, stop)
    end

    -- yielding statement: stop?
    if me.tag=='Y' or me.tag=='A' then
        local set = AST.par(me,__is_set)
        local ok = false
        if set then
            local _,to = unpack(set)
            if to.tag ~= 'List_Loc' then
                to = { to }
            end
            for _, v in ipairs(to) do
                if v.info.dcl == Dcl then
                    ok = true
                    break
                end
            end
        end
        if ok then
            -- continue: this is a Set on me
        else
            -- stop
            Dcl.__run_ptrs_yield = me
            return false                    -- stop with pointer acesses
        end

    -- If: take the two branches independently
    elseif me.tag == 'If' then
        local c, t, f = unpack(me)
        local ok = run_ptrs(c, 1, Dcl, c)
        assert(ok)
        local ok1 = run_ptrs(t, 1, Dcl, t)
        local ok2 = run_ptrs(f, 1, Dcl, f)
        if ok1 and ok2 then
            return run_ptrs(me, #me, Dcl, stop)   -- continue with pointer accesses
        else
            return false                    -- stopped in one of the branches
        end

    -- access to Dcl: mark as safe
    elseif me.tag=='ID_int' and me.dcl==Dcl then
        me.__run_ptrs_ok = true

    -- skip all |a = do ... end|
    elseif me.tag == 'Do' then
        local _,_,_,Loc = unpack(me)
        if Loc then
            assert(Loc.info.dcl, 'bug found')
            if Loc.info.dcl == Dcl then
                return run_ptrs(me, #me, Dcl, stop)   -- skip
            end
        end
    end

    return run_ptrs(me, 1, Dcl, stop)
end

F = {
    Vec  = 'Var',
    Var  = function (me)
        local _,tp = unpack(me)

        local is_ptr = TYPES.check(tp,'&&') or TYPES.is_nat_not_plain(tp)
        if not is_ptr then
            local ID = TYPES.ID_plain(tp)
            is_ptr = ID and ID.tag=='ID_abs' and
                        ID.dcl.tag=='Data' and ID.dcl.weaker=='pointer'
        end

        if is_ptr then
            run_ptrs(me, #me+1, me)
        end
    end,

    ['Exp_.'] = function (me)
        local _, e, member = unpack(me)
        if e.tag=='Outer' and me.info.tag=='Var' then
            local out = DCLS.outer(me)
            local is_ptr = TYPES.check(me.info.tp,'&&') or TYPES.is_nat_not_plain(me.info.tp)
            if not is_ptr then
                local ID = TYPES.ID_plain(me.info.tp)
                is_ptr = ID and ID.tag=='ID_abs' and
                            ID.dcl.tag=='Data' and ID.dcl.weaker=='pointer'
            end
            if is_ptr then
                ASR(false, me,
                    'invalid pointer access : crossed '..
                    'yielding statement '..
                    --AST.tag2id[yield.tag]..'` '..
                    '('..out.ln[1]..':'..out.ln[2]..')')
            end
        end
    end,

    -- skiped by run_ptrs with tag=='Do'
    Stmts__PRE = function (me)
        local Set_Exp, Escape = unpack(me, #me-1)
        if #me>=2 and Set_Exp.tag=='Set_Exp' and Escape.tag=='Escape' then
            local ID_int = AST.get(Set_Exp,'', 2,'Loc', 1,'ID_int')
            if ID_int then
                ID_int.__run_ptrs_ok = true
            end
        end
    end,

    ID_int = function (me)
        if me.dcl.tag=='Evt' or me.dcl.tag=='Pool' then
            return
        end

        local is_alias = unpack(me.dcl)
        if is_alias then
            return
        end

        local tp = me.dcl[2]
        local is_ptr = TYPES.check(tp,'&&') or TYPES.is_nat_not_plain(tp)
        if not is_ptr then
            local ID = TYPES.ID_plain(tp)
            is_ptr = ID and ID.tag=='ID_abs' and
                        ID.dcl.tag=='Data' and ID.dcl.weaker=='pointer'
        end

        if is_ptr then
            local yield = me.dcl.__run_ptrs_yield
            ASR(me.__run_ptrs_ok, me,
                'invalid pointer access : crossed '..
                'yielding statement '..
                --AST.tag2id[yield.tag]..'` '..
                '('..yield.ln[1]..':'..yield.ln[2]..')')
        end
    end,
}

AST.visit(F)

end

    
do
--  NO: big = &&small
local function check_blk (to_blk, fr_blk)
    local Code = AST.par(fr_blk,'Code')
    local Stmts = Code and AST.get(Code,'',4,'Block',1,'Stmts',4,'Block',1,'Stmts')

    -- changes nested watchings to pars
    local watch = AST.par(fr_blk, 'Watching')
    while watch do
        fr_blk = AST.par(watch, 'Block')
        watch = AST.par(watch, 'Watching')
    end

    -- changes fr_blk from body->mid
    local ok = false
    if Code and fr_blk==Code.__adjs_3 then
        ok = true
        fr_blk = Code.__adjs_2
    end

    if AST.depth(to_blk) >= AST.depth(fr_blk) then
        assert(ok or AST.is_par(fr_blk,to_blk), 'bug found')
        return true
    elseif Stmts and (
                AST.get(Stmts,'',1,'Do', 3,'Block')==fr_blk -- code ... -> ...
            or
                AST.get(Stmts,'',1,'Block')==fr_blk         -- code ... -> FOREVER
            ) then
        return 'maybe'
    else
        --assert(AST.is_par(to_blk,fr_blk), 'bug found')
        return false
    end
end

local function f2mod (f)
    if f.tag == 'Exp_as' then
        local _,_,mod = unpack(f)
        return mod
    else
        local nat = AST.get(f.info.dcl,'Nat')
        if nat then
            local mod = unpack(AST.asr(f.info.dcl,'Nat'))
            return mod
        else
            return nil
        end
    end
end

F = {
    Set_Exp = function (me)
        local fr, to = unpack(me)

        local fr_ptr = TYPES.check(fr.info.tp,'&&')
        local to_ptr = TYPES.check(TYPES.pop(to.info.tp,'?'),'&&')
        local to_nat = TYPES.is_nat_not_plain(TYPES.pop(to.info.tp,'?'))

        -- NO:
        --  d1; do d2=d1 end;   // d1>d2 and d1-has-pointers
        local ID = TYPES.ID_plain(fr.info.tp)
        local fr_data_ptr = ID and ID.tag=='ID_abs' and
                                ID.dcl.tag=='Data' and ID.dcl.weaker~='plain'

        -- ptr = _f()
        if fr.tag=='Exp_call' and (to_ptr or to_nat) then
            local mod = f2mod(fr[2])
            ASR(mod=='nohold' or mod=='pure' or mod=='plain', me,
                'invalid assignment : expected binding for "'..fr.info.dcl.id..'"')
        end

        if to_ptr or fr_ptr or fr_data_ptr then
            local fr_nat = TYPES.is_nat(fr.info.tp)
            --assert((to_ptr or to_nat) and (fr_ptr or fr_nat) or fr_data_ptr, 'bug found')

            local to_blk, fr_blk
            local ok do
                if (not fr.info.dcl) or (fr.info.dcl.tag=='Nat') then
                    ok = true   -- var int&& x = _X/null/""/...;
                else
                    fr_blk = fr.info.dcl_obj and fr.info.dcl_obj.blk or
                                fr.info.dcl.blk
                    if to_nat then
                        ok = false  -- _X = &&x;
                    else
                        to_blk = to.info.dcl_obj and to.info.dcl_obj.blk or
                                    to.info.dcl.blk
                        ok = check_blk(to_blk, fr_blk)
                        if to.info.dcl.id=='_ret' and ok=='maybe' then
                            ok = false
                        end
                    end
                end
            end 
            if not ok then
                local stmts = AST.get(me,1,'Stmts')
                if stmts and AST.get(stmts,'', #stmts,'Escape') and stmts[#stmts-1]==me then
                    ASR(false, me, 'invalid `escape` : incompatible scopes')
                elseif fr_data_ptr then
                    ASR(false, me,
                        'invalid assignment : incompatible scopes : `data` "'..
                            ID.dcl.id..'" is not plain')
                else
                    local fin = AST.par(me, 'Finalize')
                    ASR(fin and fin[1]==me, me,
                        'invalid pointer assignment : expected `finalize` for variable "'..fr.info.id..'"')
                    assert(not fin.__fin_vars, 'TODO')
                    fin.__fin_vars = {
                        blk = assert(fr_blk),
                        assert(fr.info.dcl_obj or fr.info.dcl)
                    }
                end
            end
        end
    end,

    Set_Alias = function (me)
        local fr, to = unpack(me)

        if fr.tag == 'ID_any' then
            return
        end

        local _, call = unpack(fr)
        if (call.tag=='Exp_call' or call.tag=='Abs_Call') then
            ASR(to.info.dcl[1], me,
                'invalid binding : expected option alias `&?` as destination : got "'
                ..TYPES.tostring(to.info.tp)..'"')

            local fin = AST.par(me, 'Finalize')
            ASR(fin, me,
                'invalid binding : expected `finalize`')

            -- all finalization vars must be in the same block
            local blk = to.info.dcl_obj and to.info.dcl_obj.blk or
                            to.info.dcl.blk
            blk.needs_clear = true

            if fin.__fin_vars then
                --ASR(check_blk(blk,fin.__fin_vars.blk), me,
                ASR(blk == fin.__fin_vars.blk, me,
                    'invalid `finalize` : incompatible scopes')
                fin.__fin_vars[#fin.__fin_vars+1] = assert(to.info.dcl)
            else
                fin.__fin_vars = { blk=blk, assert(to.info.dcl) }
            end
        else
            ASR(is_call or to.info.dcl.__dcls_code_alias or
                check_blk(to.info.dcl.blk, (fr.info.dcl_obj or fr.info.dcl).blk),
                me, 'invalid binding : incompatible scopes')
        end
    end,

    Abs_Spawn_Pool = function (me)
        local _, Abs_Cons, pool = unpack(me)
        local ps = AST.asr(Abs_Cons,'Abs_Cons', 3,'Abslist')
        for _, p in ipairs(ps) do
            if p.info and p.info.dcl then
                if p.info.tag == 'Alias' then
                    ASR(check_blk(pool.info.dcl.blk, p.info.blk or p.info.dcl.blk), me,
                        'invalid binding : incompatible scopes')
                end
            end
        end
    end,

    ['Exp_.'] = function (me)
        -- NO: x = &f!.*            // f may die (unless surrounded by "watching f")
        -- NO:
        if AST.par(me,'Exp_1&') and me.info.dcl_obj and me.info.dcl_obj.orig and me.info.dcl_obj.orig[1]=='&?' then
            if AST.par(me, 'Abs_Call') then
                return      -- call Ff(&obj!.x)
            end

            local to do
                local set   = AST.par(me, 'Set_Alias')
                local spawn = AST.par(me, 'Abs_Spawn_Pool')
                if set then
                    _,to = unpack(set)
                elseif spawn then
                    to = AST.asr(spawn,'', 3,'Loc')
                else
                    --return
                end
            end

            local watch = AST.par(me, 'Watching')
            local ok = false
            while watch do
                local awt = watch and AST.get(watch,'', 1,'Par_Or', 1,'Block', 1,'Stmts', 1,'Await_Int', 1,'')
                                   or AST.get(watch,'', 1,'Par_Or', 1,'Block', 1,'Stmts', 1,'Set_Await_many',1,'Await_Int', 1,'')
                if awt and awt.info.dcl==me.info.dcl_obj.orig then
                    if to then
                        -- watching.depth < to.dcl.blk.depth
                        if to.info.dcl.blk.__adjs_2 then
                            -- ok: allow mid destination binding even outliving source
                            -- TODO: check it is not accessed outside the watching
                            ok = true
                        else
                            ok = check_blk(to.info.dcl.blk, watch)
                            ASR(ok, me, 'invalid binding : incompatible scopes')
                        end
                    else
                        -- var&? Tx t = spawn Tx();
                        -- watching t do
                        --    spawn Ux(&t!.e);
                        -- end
                        ok = true   -- Ux is scoped inside watching
                    end
                    break
                end
                watch = AST.par(watch, 'Watching')
            end
            ASR(ok, me,
                'invalid binding : unexpected source with `&?` : destination may outlive source')
        end
    end,

    Exp_call = function (me)
        local _,f,ps = unpack(me)

        -- ignore if "f" is "nohold" or "pure"
        local mod = f2mod(f)
        if mod=='nohold' or mod=='pure' then
            return
        end

        for _, p in ipairs(ps) do
            if p.info.dcl and (p.info.dcl.tag ~= 'Nat') -- OK: _f(&&_V)
                and (TYPES.check(p.info.tp,'&&') or     -- NO: _f(&&v)
                     TYPES.is_nat_not_plain(p.info.tp)) -- NO: _f(_ptr)
            then
                local fin = AST.par(me, 'Finalize')
                local ok = fin and (
                            (AST.get(fin,'',1,'Stmt_Call',1,'Exp_call')    == me) or
                            (AST.get(fin,'',1,'Set_Alias',1,'Exp_1&',2,'') == me) or
                            (AST.get(fin,'',1,'Set_Exp',1,'')              == me) )

                    -- _f(...);
                    -- x = &_f(...);
                    -- x = _f(...);
                ASR(ok, me,
                    'invalid `call` : expected `finalize` for variable "'..p.info.id..'"')
                -- all finalization vars must be in the same block
                local blk = p.info.dcl_obj and p.info.dcl_obj.blk or
                                p.info.dcl.blk
                if fin.__fin_vars then
                    ASR(blk == fin.__fin_vars.blk, me,
                        'invalid `finalize` : incompatible scopes')
                    fin.__fin_vars[#fin.__fin_vars+1] = assert(p.info.dcl)
                else
                    fin.__fin_vars = { blk=blk, p.info.dcl }
                end
            end
        end
    end,

    --------------------------------------------------------------------------

    __stmts = { Set_Exp=true, Set_Alias=true,
                Emit_Ext_emit=true, Emit_Ext_call=true,
                Stmt_Call=true },

    Finalize = function (me)
        local Stmt, List_Loc = unpack(me)
        if not Stmt then
            ASR(List_Loc==false, me,
                'invalid `finalize` : unexpected `varlist`')
            me.blk = AST.par(me, 'Block')
            return
        end
        assert(Stmt)

        -- NO: |do r=await... finalize...end|
        local tag_id = AST.tag2id[Stmt.tag]
        ASR(F.__stmts[Stmt.tag], Stmt,
            'invalid `finalize` : unexpected '..
            (tag_id and '`'..tag_id..'`' or 'statement'))

        ASR(me.__fin_vars, me,
            'invalid `finalize` : nothing to finalize')
        ASR(List_Loc and List_Loc.tag=='List_Loc', List_Loc or me,
            'invalid `finalize` : expected `varlist`')

        for _, v1 in ipairs(me.__fin_vars) do
            ASR(v1.tag=='Nat' or v1.tag=='Var' or v1.tag=='Vec', Stmt,
                'invalid `finalize` : expected identifier : got "'..v1.id..'"')

            local ok = false
            for _, v2 in ipairs(List_Loc) do
                if v2.info.dcl==v1 or v2.info.dcl==v1.orig then
                                        -- TODO: HACK_3
                    ok = true
                    break
                end
            end
            ASR(ok, List_Loc,
                'invalid `finalize` : unmatching identifiers : expected "'..
                v1.id..'" (vs. '..Stmt.ln[1]..':'..Stmt.ln[2]..')')
        end

        me.blk = assert(me.__fin_vars.blk)
    end,
}

AST.visit(F)

end

    
do
TIGHT_ = {}

local awaits = {
    Par           = true,
    Async         = true,
    Async_Thread  = true,
    Async_Isr     = true,
    Await_Ext     = true,
    Await_Wclock  = true,
    Await_Forever = true,
}

local function run (me, Loop)
    assert(AST.is_node(me))

    local int_await do
        if me.tag == 'Await_Int' then
            local parand = AST.par(me, 'Par_And')
            local paror  = AST.par(me, 'Par_Or')
            if parand and AST.depth(parand)>AST.depth(Loop) or
               paror  and AST.depth(paror)>AST.depth(Loop)
            then
                -- TIGHT
                --  loop do
                --      par/and do
                --          await int;
                --      with
                --          ... // possibly "emit int"
                --      end
                --  end
                int_await = false
            else
                int_await = true
            end
        end
    end

    if awaits[me.tag] or int_await or (me.tag=='Loop' and me.tight=='awaits') then
        return 'awaits'

    elseif me.tag=='Break' or me.tag=='Escape' then
        if AST.depth(Loop) >= AST.depth(me.outer) then
            return 'breaks'
        end

    elseif me.tag=='If' or me.tag=='Par_Or' then
        local T do
            if me.tag == 'If' then
                local _,t,f = unpack(me)
                T = { t, f }
            else
                T = me
            end
        end
        local awaits = true
        for _,sub in ipairs(T) do
            local ret = run(sub, Loop)
            if ret == 'tight' then
                return 'tight'              -- "tight" if found at least one tight
            elseif ret == 'breaks' then
                awaits = false
            else
                assert(ret == 'awaits')
            end
        end
        if awaits then
            return 'awaits'                 -- "awaits" if all await
        else
            return 'breaks'                 -- "breaks" otherwise
        end

    elseif me.tag == 'Loop' then
        if me.tight == 'breaks' then
            return 'tight'
        else
            return 'awaits'
        end

    else
        for _, child in ipairs(me) do
            if AST.is_node(child) then
                local ret = run(child, Loop)
                if ret and ret~='tight' then
                    return ret
                end
            end
        end
        return 'tight'
    end
end

TIGHT_.F = {
    __loop = function (me, body, is_bounded)
        me.tight = run(body, me)

        if me.tight == 'tight' then
            if is_bounded or max then
                me.tight = 'bounded'
            end
        end
        if me.tight ~= 'tight' then
            return
        end

        local in_async = AST.par(me,'Async') or AST.par(me,'Async_Thread')
                            or AST.par(me,'Async_Isr')
        WRN(in_async, me,
            'invalid tight `loop` : unbounded number of non-awaiting iterations')
    end,

    Loop = function (me)
        local max, body = unpack(me)
        TIGHT_.F.__loop(me, body, max)
    end,

    Loop_Num = function (me)
        local max, _, range, body = unpack(me)
        local fr,_,to,_ = unpack(range)
        TIGHT_.F.__loop(me, body, max or (fr.is_const and to.is_const))
    end,
}

AST.visit(TIGHT_.F)

local impls = {}

G = {
    Code = function (me)
        if not me.is_impl then
            return
        end
        local _,id = unpack(me)
        local blk = AST.par(me, 'Block')
        local old = DCLS.get(blk, id)
        impls[old] = true
    end,

    Abs_Call = function (me)
        local mods_call, Abs_Cons = unpack(me)
        local Code = AST.asr(Abs_Cons,'Abs_Cons', 2,'ID_abs').dcl
        local mods_dcl = unpack(Code)

        local Par = AST.par(me,'Code')

        -- calling known Code (or not calling from a tight)
        if impls[Code] then --or (not (Par and Par[1].tight)) then
            if mods_call.recursive then
                ASR(mods_dcl.recursive, me,
                    'invalid `call` : unexpected `/recursive`')
            else
                ASR(not mods_dcl.recursive, me,
                    'invalid `call` : expected `/recursive`')
            end

        -- calling unknown Code
        else
            -- Code must be '/recursive'
            ASR(mods_dcl.recursive, Code,
                'invalid `code` declaration : expected `/recursive` : `call` to unknown body ('..me.ln[1]..':'..me.ln[2]..')')

            -- Call must be '/recursive'
            ASR(mods_call.recursive, me,
                'invalid `call` : expected `/recursive` : `call` to unknown body')
        end

        -- calling from Par code with '/recursive'
        if Par and mods_call.recursive then
            -- Par must be '/recursive'
            local mods_dcl = unpack(Par)
            ASR(mods_dcl.await or mods_dcl.recursive, Par,
                'invalid `code` declaration : expected `/recursive` : nested `call/recursive` ('..me.ln[1]..':'..me.ln[2]..')')
        end
    end,
}

AST.visit(G)

end

    
do
PROPS_ = {}

local sync = {
    Await_Forever=true, Await_Ext=true, Await_Int=true, Await_Wclock=true,
    Abs_Spawn=true,
    Emit_Evt=true,
    Every=true, Finalize=true, Pause_If=true,
    Par=true, Par_And=true, Par_Or=true, Watching=true,
    Async=true, Async_Thread=true,
    Throw=true, Catch=true,
}

local NO = {
    {Every     = sync},
    --{Loop_Pool = sync},
    {Async     = sync},
    {Finalize  = sync},
    {Code      = sync},   -- only code/tight
}

PROPS_.F = {
    Node = function (me)
        for _,T in ipairs(NO) do
            local k,t = next(T)
            local par = AST.par(me,k)

            if par and t[me.tag] then
                local sub = par
                if par.tag == 'Every' then
                    local Await = unpack(AST.asr(par,'', 1,'Loop', 2,'Block', 1,'Stmts'))
                    if AST.is_par(Await,me) then
                        return -- ok: await for the every itself
                    end

                    local paror = AST.get(me,2,'Par_Or')
                    local var = AST.get(me,'Par_Or', 1,'Stmts', 1,'Var')
                    if me.tag=='Await_Forever' and paror and paror.__spawns then
                        return -- ok: var&? inside every
                    elseif me.__spawns and var and var[1] then
                        return -- ok: var&? inside every

                    elseif me.tag=='Finalize' or me.tag=='Par_Or' then
                        if me.tag == 'Finalize' then
                            if AST.get(me,3,'Stmts', 1,'Vec') then
                                return -- ok: vector[] inside every
                            end
                        else
                            if AST.get(me,1,'Stmts', 1,'Vec') then
                                return -- ok: vector[] inside every
                            end
                        end
                    elseif me.tag=='Emit_Evt' or me.tag=='Throw' then
                        return -- ok
                    end
                elseif par.tag == 'Code' then
                    local mods = unpack(par)
                    if mods.await then
                        return -- ok: code/await
                    elseif me.tag == 'Finalize' then
                        return -- ok (this an empty finalizer for sure)
                    end
                elseif par.tag=='Finalize' then
                    if AST.get(par,'Finalize',3,'Par')==me then
                        return -- ok: finalize par fin/pse/res
                    elseif me.tag=='Emit_Evt' or me.tag=='Throw' then
                        return -- ok
                    end
                end

                ASR(false, me,
                    'invalid `'..AST.tag2id[me.tag]..
                    '` : unexpected enclosing `'..AST.tag2id[par.tag]..'`')
            end
        end
    end,

    --------------------------------------------------------------------------

    Emit_Wclock = function (me)
        ASR(AST.par(me,'Async') or AST.par(me,'Async_Isr'), me,
            'invalid `emit` : expected enclosing `async` or `async/isr`')
    end,

    __escape = function (me)
-- TODO: join all possibilities (thread/isr tb)
        local Async = AST.par(me,'Async')
        if Async then
            ASR(AST.depth(me.outer) > AST.depth(Async), me,
                'invalid `'..AST.tag2id[me.tag]..'` : unexpected enclosing `async`')
        end

--[[
        local Every = AST.par(me,'Every')
        if Every then
            ASR(me.outer.__depth > Every.__depth, me,
                'invalid `'..AST.tag2id[me.tag]..'` : unexpected enclosing `every`')
        end
]]

        local Finalize = AST.par(me,'Finalize')
        if Finalize then
            local _,_,later = unpack(Finalize)
            if AST.is_par(later,me) then
                ASR(AST.depth(me.outer) > AST.depth(Finalize), me,
                    'invalid `'..AST.tag2id[me.tag]..'` : unexpected enclosing `finalize`')
            end
        end
    end,
    Break = function (me)
        PROPS_.F.__escape(me)
        if me.outer then
            me.outer.has_break = true       -- avoids unnecessary CLEAR
        end
    end,
    Continue = function (me)
        PROPS_.F.__escape(me)
        if me.outer then
            me.outer.has_continue = true    -- avoids unnecessary CLEAR
        end
    end,
    Escape = function (me)
        PROPS_.F.__escape(me)
        if me.outer then
            me.outer.has_escape = true      -- avoids unnecessary CLEAR
        end
    end,

    List_Var = function (me)
        local watch = AST.par(me,'Loop_Pool') or AST.par(me,'Watching')
        for _, ID in ipairs(me) do
            if ID.tag ~= 'ID_any' then
                ID.dcl.__no_access = watch  -- no access outside watch
            end
        end
    end,
    Set_Alias = function (me)
        local fr, to = unpack(me)
        local watch = AST.par(me,'Loop_Pool') or AST.par(me,'Watching')
        if watch then
            to.info.dcl.__no_access = watch -- no access outside watch
        end
    end,

    --------------------------------------------------------------------------

    Code = function (me)
        local mods1,_,_,body = unpack(me)
        if mods1.dynamic and body then
            local Pars_Block = AST.asr(body,'Block', 1,'Stmts', 2,'Do', 3,'Block')
            for i, dcl in ipairs(Pars_Block.dcls) do
                local _,_,_,mods2 = unpack(dcl)
                if mods2.dynamic then
                    local _,Type,id = unpack(dcl)
                    local data = AST.get(Type,'',1,'ID_abs')
                    ASR(data and data.dcl.hier, me,
                        'invalid `dynamic` declaration : parameter #'..i..
                        ' : expected `data` in hierarchy')
                end
            end
        end
    end,

    __check = function (me)
        local _,num = unpack(me)
        ASR(num, me, 'invalid `data` declaration : missing `as`')
        for _, sub in ipairs(me.hier.down) do
            PROPS_.F.__check(sub)
        end
    end,

    Data = function (me)
        local _,num = unpack(me)
        if num then
            ASR(me.hier, me, 'invalid `as` declaration : expected `data` hierarchy')
            if num ~= 'nothing' then
                PROPS_.F.__check(DCLS.base(me))
            end
        end
    end,

    --------------------------------------------------------------------------

    Catch = function (me)
        ASR(CEU.opts.ceu_features_exception, me, '`exception` support is disabled')
    end,
    Throw = function (me, tp)
        if not tp then
            local v1 = unpack(me)
            tp = v1.info.tp
        end
        PROPS_.F.Catch(me)
        for node in AST.iter() do
            if node.tag == 'Catch' then
                local v2 = unpack(node)
                if TYPES.contains(v2.info.tp, tp) then
                    return
                end
            elseif node.tag == 'Code' then
                local mods,_,throws = unpack(node)
                if mods.tight then
                    return  -- error anyways: "invalid `throw` : unexpected enclosing `code`"
                end
                local f = ASR
                if CEU.opts.ceu_err_uncaught_exception then
                    f = ASR_WRN_PASS(CEU.opts.ceu_err_uncaught_exception)
                end
                if TYPES.check(tp,'Exception.Lua') and CEU.opts.ceu_err_uncaught_exception_lua then
                    local f_ = ASR_WRN_PASS(CEU.opts.ceu_err_uncaught_exception_lua)
                    f = ASR_WRN_PASS_MIN(f, f_)
                end
                f(throws, me, 'uncaught exception')
                if throws then
                    for _, v2 in ipairs(throws) do
                        if TYPES.is_equal(TYPES.new(me,v2.dcl.id), tp) then
                            return
                        end
                    end
                end
            end
        end

        local f = WRN
        if CEU.opts.ceu_err_uncaught_exception_main then
            f = ASR_WRN_PASS(CEU.opts.ceu_err_uncaught_exception_main)
        end
        if CEU.opts.ceu_err_uncaught_exception then
            f = ASR_WRN_PASS(CEU.opts.ceu_err_uncaught_exception)
        end
        if TYPES.check(tp,'Exception.Lua') and CEU.opts.ceu_err_uncaught_exception_lua then
            local f_ = ASR_WRN_PASS(CEU.opts.ceu_err_uncaught_exception_lua)
            f = ASR_WRN_PASS_MIN(f, f_)
        end
        f(false, me, 'uncaught exception')
    end,
    Abs_Cons = function (me)
        local _,ID_abs = unpack(me)
        local throws = AST.get(ID_abs.dcl,'', 3,'List_Throws')
        if throws then
            for _, throw in ipairs(throws) do
                PROPS_.F.Throw(me, TYPES.new(me,throw.dcl.id))
            end
        end
    end,

    Lua_Do = 'Lua',
    Lua = function (me)
        ASR(CEU.opts.ceu_features_lua, me, '`lua` support is disabled')
        if CEU.opts.ceu_features_exception then
            PROPS_.F.Throw(me, TYPES.new(me,'Exception.Lua'))
        end
    end,

    Async_Thread = function (me)
        ASR(CEU.opts.ceu_features_thread, me, '`async/thread` support is disabled')
    end,
    Async_Isr = function (me)
        ASR(CEU.opts.ceu_features_isr, me, '`async/isr` support is disabled')
    end,
    Atomic = function (me)
        ASR(CEU.opts.ceu_features_thread or CEU.opts.ceu_features_isr, me,
            '`atomic` support is disabled: enable `--ceu-features-thread` or `--ceu-features-isr`')
    end,
}

AST.visit(PROPS_.F)

end

    
do
TRAILS = {}

local function MAX (v1, v2)
    return (v1 > v2) and v1 or v2
end

local function MAX_all (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if AST.is_node(sub) then
            me.trails_n = MAX(me.trails_n, sub.trails_n)
        end
    end
end

TRAILS.F = {
    Node__PRE = function (me)
        me.trails_n = 1
    end,
    Node__POS = function (me)
        if not TRAILS.F[me.tag] then
            MAX_all(me)
        end
    end,

    Loop_Pool = function (me)
        local _, _, _, body = unpack(me)
        me.trails_n = body.trails_n + 2
    end,

    Pause_If = function (me)
        local _, body = unpack(me)
        me.trails_n = 1 + body.trails_n
    end,

    Async_Thread = function (me)
        local body = unpack(me)
        me.trails_n = 1 + body.trails_n
    end,

    If = function (me)
        local c, t, f = unpack(me)
        MAX_all(me, {t,f})
    end,

    Par_And = 'Par',
    Par_Or  = 'Par',
    Par = function (me)
        me.trails_n = 0
        for _, sub in ipairs(me) do
            me.trails_n = me.trails_n + sub.trails_n
        end
    end,

    Code = function (me)
        MAX_all(me)
        if me.dyn_base then
            me.dyn_base.max_trails_n = MAX(me.dyn_base.max_trails_n or 0, me.trails_n)
        end
    end,
}

AST.visit(TRAILS.F)

-------------------------------------------------------------------------------

G = {
    ROOT__PRE = function (me)
        me.trails = { 0, me.trails_n-1 }     -- [0, N]
    end,
    Code__PRE = 'ROOT__PRE',

    Node__PRE = function (me)
        if (not me.trails) and me.__par then
            me.trails = { unpack(me.__par.trails) }
        end
    end,

    Loop_Pool__PRE = function (me)
        local _, _, _, body = unpack(me)
        body.trails = { unpack(me.trails) }
        body.trails[1] = body.trails[1] + 2
    end,

    Pause_If__PRE = function (me)
        local _,body = unpack(me)
        body.trails = { unpack(me.trails) }
        body.trails[1] = body.trails[1] + 1
    end,

    Par_Or__PRE  = 'Par__PRE',
    Par_And__PRE = 'Par__PRE',
    Par__PRE = function (me)
        for i, sub in ipairs(me) do
            sub.trails = {}
            if i == 1 then
                sub.trails[1] = me.trails[1]
            else
                local pre = me[i-1]
                sub.trails[1] = pre.trails[1] + pre.trails_n
            end
            sub.trails[2] = sub.trails[1] + sub.trails_n-1
        end
    end,

    -- invert pool/finalize b/c finalize frees pool before last iteration
    __ok = false,
    Pool = function (me)
        local is_alias,_,_,dim = unpack(me)
        if (not dim.is_const) and (not is_alias) then
            TRAILS.F.__ok = true
            me.trails[1] = me.trails[1] + 1
            me.trails[2] = me.trails[2] + 1
        end
    end,
    Pool_Finalize = function (me)
        if TRAILS.F.__ok then
            TRAILS.F.__ok = false
            local fin = AST.par(me, 'Finalize_Case')
            fin.trails[1] = fin.trails[1] - 1
            fin.trails[2] = fin.trails[2] - 1
        end
    end,
}

AST.visit(G)


end

    
do
LABELS = {
    list = {},      -- { [lbl]={}, [i]=lbl }
}

local function new (lbl)
    if lbl[2] then
        lbl.id = 'CEU_LABEL_'..lbl[1]
    else
        local Code = AST.iter'Code'()
        Code = (Code and Code.id..'_') or ''
        lbl.id = 'CEU_LABEL_'..Code..lbl[1]..'_'..(#LABELS.list+1)
    end
    if not LABELS.list[lbl.id] then
        LABELS.list[lbl.id] = true
        LABELS.list[#LABELS.list+1] = lbl
        lbl.n = #LABELS.list+1                   -- starts from 2
    end

    return lbl
end

F = {
    ROOT__PRE = function (me)
        me.lbl_in = new{'ROOT', true}
    end,

    Block = function (me)
        me.lbl_clr = new{'Block__CLR'}
    end,

    Do = function (me)
        local _,_,set = unpack(me)
        me.lbl_out = new{'Do__OUT'}
        me.lbl_clr = new{'Do__CLR'}
    end,

    Finalize_Case = function (me)
        me.lbl_in = new{'Finalize_Case__IN'}
    end,

    Var = function (me)
        if (me.__dcls_code_alias == '&?') and (not me.__adjs_is_abs_await) then
            me.lbl = new{'Alias__CLR'}
        end
    end,

    Loop_Pool = function (me)
        F.Loop(me)
        me.lbl_clr  = new{'Loop_Pool__CLR'}
        me.lbl_fin  = new{'Loop_Pool__FIN'}
        me.lbl_null = new{'Loop_Pool__NULL'}
    end,
    Loop = function (me)
        me.lbl_clr = new{'Loop__CLR'}
        me.lbl_cnt = new{'Loop_Continue__CNT'}
        me.lbl_cnt_clr = new{'Loop_Continue__CLR'}
        me.lbl_out = new{'Loop_Break__OUT'}
        if AST.par(me,'Async') then
            me.lbl_asy = new{'Loop_Async__CNT'}
        end
    end,
    Loop_Num = 'Loop',

    Code = function (me)
        local mods = unpack(me)
        me.lbl_in = new{'Code_'..me.id_, true}
        if mods.await then
            me.lbl_clr = new{'Code__CLR'}
        end
    end,

    ---------------------------------------------------------------------------

    Par_Or__PRE  = 'Par__PRE',
    Par_And__PRE = 'Par__PRE',
    Par__PRE = function (me)
        me.lbls_in = {}
        for i, sub in ipairs(me) do
            me.lbls_in[i] = new{me.tag..'_sub_'..i..'_IN'}
        end
        if me.tag ~= 'Par' then
            me.lbl_out = new{me.tag..'__OUT'}
        end
        if me.tag == 'Par_Or' then
            me.lbl_clr = new{me.tag..'__CLR'}
        end
    end,

    ---------------------------------------------------------------------------

    Abs_Spawn = function (me)
        me.lbl_out = new{'Await_Spawn__OUT'}
    end,
    Await_Wclock = function (me)
        me.lbl_out = new{'Await_Wclock__OUT'}
    end,
    Await_Pause = function (me)
        me.lbl_out = new{'Await_Pause__OUT'}
    end,
    Await_Resume = function (me)
        me.lbl_out = new{'Await_Resume__OUT'}
    end,
    Await_Ext = function (me)
        local ID_ext = unpack(me)
        me.lbl_out = new{'Await_'..ID_ext.dcl.id..'__OUT'}
    end,
    Await_Int = function (me)
        local Loc = unpack(me)
        me.lbl_out = new{'Await_'..Loc.info.dcl.id..'__OUT'}
    end,
    Await_Exception = function (me)
        me.lbl_out = new{'Await_Exception__OUT'}
    end,

    Emit_Wclock = function (me)
        me.lbl_out = new{'Emit_Wclock__OUT'}
    end,
    Emit_Ext_emit = function (me)
        local ID_ext = unpack(me)
        local inout = unpack(ID_ext.dcl)
        if inout=='input' and AST.par(me,'Async_Isr') then
            return
        end
        me.lbl_out = new{'Emit_Ext_emit__'..ID_ext.dcl.id..'__OUT'}
    end,

    Async = function (me)
        me.lbl_in = new{'Async__IN'}
    end,

    Async_Thread = function (me)
        me.lbl_fin = new{'Async_Thread__FIN'}
        me.lbl_abt = new{'Async_Thread__ABT'}
        me.lbl_out = new{'Async_Thread__OUT'}
    end,

    Async_Isr = function (me)
        me.lbl_fin = new{'Async_Isr__FIN'}
    end,
}

AST.visit(F)

end

    
do
local _ceu2c = { ['&&']='&', ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

local F

function CUR (field, ctx)
    ctx = ctx or {}
    local Isr  = AST.iter'Async_Isr'()
    local Code = AST.iter'Code'()
    local Ext  = AST.iter'Ext_impl'()
    local data do
        if ctx.outer then
            if Isr and Code then
                data = '(*((tceu_code_mem_'..Code.id_..'*)_ceu_mem))'
            else
                if ctx.outer.depth then
                    local mem = 'ceu_outer(_ceu_mem, '..(ctx.outer.depth or 0)..')'
                    data = '(*(tceu_code_mem_'..ctx.outer.id_..'*)('..mem..'))'
                else
                    data = 'CEU_APP.root'
                end
            end
        elseif Isr then
            data = '_ceu_loc'
        elseif Code then
            data = '(*((tceu_code_mem_'..Code.id_..'*)_ceu_mem))'
        elseif Ext then
            if ctx.is_local then
                data = '_ceu_loc'
            else
                local ext = unpack(Ext)
                data = '(*((tceu_output_'..ext.id..'*)p2.ptr))'
                field = '_'..Ext.__dcls_vars[field]
            end
        else
            data = 'CEU_APP.root'
        end
    end
    local base = ctx.base or ''
    return '('..data..'.'..base..field..')'
end

function TRACE (n)
    local Isr  = AST.iter'Async_Isr'()
    local Ext  = AST.iter'Ext_impl'()
    if Isr or Ext then
        return 'trace'
    else
        return 'CEU_TRACE('..n..')'
    end
end

function V (me, ctx)
    ctx = ctx or {}
    local f = assert(F[me.tag], 'bug found : V('..me.tag..')')
    while type(f) == 'string' do
        f = assert(F[f], 'bug found : V('..me.tag..')')
    end

    local ret = f(me, ctx)

    if type(ret) == 'string' then
        return string.gsub(ret, '%(%&%(%*', '((')
    end

    return ret
end

F = {
    Loc = function (me, ctx)
        local e = unpack(me)
        return V(e, ctx)
    end,

-- PRIMITIVES

    ID_any = function (me)
        return 'NULL'
        --return '{ .is_set=0 }'
    end,

    NULL = function (me)
        return 'NULL'
    end,

    NUMBER = function (me)
        return me[1]
    end,

    BOOL = function (me)
        return me[1]
    end,

    STRING = function (me)
        return me[1]
    end,

-- WCLOCK

    WCLOCKK = function (me)
        return me.us
    end,

    WCLOCKE = function (me)
        local e, unit = unpack(me)
        return '('.. V(e) .. ')*' .. CONSTS.t2n[unit]
    end,

-- SIZEOF

    SIZEOF = function (me)
        local e = unpack(me)
        if e.tag == 'Type' then
            return '(sizeof('..TYPES.toc(e)..'))'
        else
            return '(sizeof('..V(e)..'))'
        end
    end,

-- CALL

    Exp_call = function (me)
        local _, e, ps = unpack(me)
        return V(e)..'('..table.concat(V(ps),',')..')'
    end,

    Abs_Call = function (me)
        local _, Abs_Cons = unpack(me)
        local obj, ID_abs, _ = unpack(Abs_Cons)
        local mods = unpack(ID_abs.dcl)
        assert(mods.tight)

        local mem do
            if obj then
                mem = '(&'..V(obj)..')'
            else
                mem = '_ceu_mem'
            end
        end
        assert(mem)

        mem = '((tceu_code_mem*)'..mem..')'
        local args = ''
        if CEU.opts.ceu_features_trace then
            local v = '__ceu_'..me.n
            args = args .. [[,

#if defined(__GNUC__) && defined(__cplusplus)
({tceu_trace ]]..v..';'..v..'.up=&_ceu_mem->trace;'..v..'.file="'..me.ln[1]..'";'..v..'.line='..me.ln[2]..'; __ceu_'..me.n..[[;})

#else
(tceu_trace) { &_ceu_mem->trace, "]]..me.ln[1]..'",'..me.ln[2]..[[ }

#endif
]]
        end
        if CEU.opts.ceu_features_lua then
            args = args..','..LUA(me)
        end
        return [[
CEU_CODE_]]..ID_abs.dcl.id_..'('..V(Abs_Cons)..','..mem..args..[[)
]]
    end,

    Abs_Cons = function (me, ctx)
        local obj, ID_abs, Abslist = unpack(me)

        local id_struct do
            if ID_abs.dcl.tag == 'Data' then
                id_struct = 'tceu_data_'..ID_abs.dcl.id_
            else
                id_struct = 'tceu_code_mem_'..ID_abs.dcl.id_
            end
            if ctx.to_tp then
                id_struct = ctx.to_tp
            end
        end

        local ps = {}

        if ID_abs.dcl.tag == 'Data' then
            if ID_abs.dcl.hier then
                ps[1] = { '_enum', 'CEU_DATA_'..ID_abs.dcl.id_ }
            end
        end

        local mods = (ID_abs.dcl.tag=='Code' and ID_abs.dcl[1])

        assert(#me.vars == #Abslist)
        for i=1, #me.vars do
            local var = me.vars[i]
            local val = Abslist[i]

            local var_is_alias, var_tp = unpack(var)

            -- var Ee.Xx ex = ...;
            -- code Ff (var& Ee e)
            -- Ff(&ex)
            local cast = ''
            if var_tp.tag=='Type' and var_tp[1].tag=='ID_abs' and var_tp[1].dcl.tag=='Data' then
                local op = '->'
                if TYPES.check(var_tp,'&&') then
                    cast = '('..TYPES.toc(var_tp)..')'
                elseif var_is_alias then
                    cast = '('..TYPES.toc(var_tp)..'*)'
                else
                    op = '.'
                end

--[[
                if mods and mods.dynamic and var_tp[1].dcl.hier then
                    if val.tag == 'Exp_as' then
                        ps[#ps+1] = { '_data_'..i, 'CEU_DATA_'..val.info.tp[1].dcl.id }
                    else
                        ps[#ps+1] = { '_data_'..i, V(val,ctx)..op..'_enum' }
                    end
                end
]]
            end

            local var_is_opt = TYPES.check(var_tp,'?')

            if TYPES.check(var_tp,'?') and (not var_is_alias) and
               (not (val.info and TYPES.check(val.info.tp,'?')))
            then
                if val.tag == 'ID_any' then
                    ps[#ps+1] = { var.id_, '{ .is_set=0 }' }
                else
                    ps[#ps+1] = { var.id_, '{ .is_set=1, .value='..V(val)..'}' }
                end
            else
                local to_val = ctx.to_val
                if val.tag == 'ID_any' then
                    -- HACK_09: keep what is there
                    --  data Dd with
                    --      vector[] int x;
                    --  end
                    --  var Dd d = val Dd(_);   // x is implicitly init'd
                    if to_val then  -- only set for Set_Abs_Val ("data")
                        if var.tag=='Evt' or var.tag=='Vec' and TYPES.is_nat(var_tp) then
                            -- don't initialize
                            --  event ...;
                            --  vector[] _int x;
                        else
                            ps[#ps+1] = { var.id_, to_val..'.'..var.id_ }
                        end
                    end
                else
                    local ctx = {}
                    if val.tag == 'Abs_Cons' then
                        -- typecast: "val Xx = val Xx.Yy();"
                        --ctx.to_tp  = TYPES.toc(var_tp)
                        ctx.to_tp  = TYPES.toc(val.info.tp)
                        if to_val then  -- only set for Set_Abs_Val ("data")
                            ctx.to_val = '('..to_val..'.'..var.id_..')'
                        end
                    end

                    local val_val = V(val,ctx)

                    -- Base <- Super
-- TODO: unify-01
                    do
                        local var_tp = var_tp
                        if var_is_opt then
                            --var_tp = TYPES.pop(var_tp,'?')
                        end
                        local to_abs = TYPES.abs_dcl(var_tp, 'Data')
                        if to_abs and (not var_is_alias) then
                            --  var Super y;
                            --  var Base  x;
                            --  x = y;
                            -- to
                            --  x = Base(y)
                            local name = 'CEU_'..TYPES.toc(val.info.tp)..'__TO__'..TYPES.toc(var_tp)
                            val_val = name..'('..val_val..')'

                            if not MEMS.datas.casts[name] then
                                MEMS.datas.casts[name] = true
                                MEMS.datas.casts[#MEMS.datas.casts+1] = [[
]]..TYPES.toc(var_tp)..' '..name..[[ (]]..TYPES.toc(val.info.tp)..[[ x)
{
    return (*(]]..TYPES.toc(var_tp)..[[*)&x);
}
]]
                            end
                        else
                            val_val = cast..val_val
                        end
                    end

                    ps[#ps+1] = { var.id, val_val }
                                    -- proto has no var.id_
                end
            end
        end

        local ps1='' do
            for i, t in ipairs(ps) do
                local to, fr = unpack(t)
                ps1 = ps1..'.'..to..' = '..fr
                if i < #ps then
                    ps1 = ps1..','
                end
            end
        end
        local ps2='' do
            for _, t in ipairs(ps) do
                local to, fr = unpack(t)
                ps2 = ps2..'__ceu_'..me.n..'.'..to..' = '..fr..';'
            end
        end

        return [[

#if defined(__GNUC__) && defined(__cplusplus)
({]]..id_struct..' __ceu_'..me.n..';'..ps2..'; __ceu_'..me.n..[[;})

#else
(]]..id_struct..') { '..ps1..[[ }

#endif
]]
    end,

    List_Exp = function (me)
        local vs = {}
        for i, p in ipairs(me) do
            vs[i] = V(p)
        end
        return vs
    end,

    ---------------------------------------------------------------------------

    ID_ext = function (me)
        return '((tceu_evt){'..me.dcl.id_..',{NULL}})'
    end,

    ID_nat = function (me)
        local v1,v2 = unpack(me)
        if v1 == '_{}' then
            -- { nat }
            local ret = ''
            for i=2, #me do
                local str = me[i]
                local exp = AST.get(str,'')
                if exp then
                    str = V(exp)
                end
                ret = ret .. str
            end

            -- unescape `##` => `#`
            ret = string.gsub(ret, '\n%s*##', '\n#')
            ret = string.gsub(ret, '^%s*##',  '#')

            return ret
        else
            -- _nat
            return string.sub(v1, 2)
        end
    end,

    Evt = function (me, ctx)
        local is_alias = unpack(me)
        if is_alias then
            return CUR(me.id_,ctx)
        else
            return '((tceu_evt){'..me.id_..',{_ceu_mem}})'
        end
    end,

    Pool = 'Var',
    Vec = 'Var',
    Var = function (me, ctx)
        local id_suf = ctx.id_suf or ''
        local alias, tp = unpack(me)
        local ptr = ''
        if alias=='&' and (not ctx.is_bind) then
            --  var&? _t_ptr x = &_f(); ... x!
            --  var& _t_ptr xx = &x!;   ... xx
            ptr = '*'
        end

        local Ext = AST.par(me, 'Ext_impl')
        if Ext and (not Ext.__dcls_vars[me.id]) then
            ctx.is_local = true
        end

        return '('..ptr..CUR(me.id_..id_suf,ctx)..')'
    end,

    ID_int = function (me, ctx)
        local f = F[me.dcl.tag]
        if type(f) == 'string' then
            f = F[f]
        end
        return f(me.dcl, ctx)
    end,

    ---------------------------------------------------------------------------

-- MEMBER: .

    ['Exp_.'] = function (me,ctx)
        local _, e, member = unpack(me)
        member = string.gsub(member, '^_', '')  -- _nat._data (data is a keyword)

        local is_alias = unpack(me.info.dcl)

        if me.info.dcl.tag=='Evt' and (not is_alias) then
            if e.tag == 'Outer' then
                local outer = e.__dcls_outer
                local mem do
                    if outer and assert(outer.depth) then
                        mem = 'ceu_outer(_ceu_mem, '..(outer.depth or 0)..')'
                    else
                        mem = '&CEU_APP.root'
                    end
                end
                return '((tceu_evt){ '..me.info.dcl.id_..', {'..mem..'} })'
            else
                return '((tceu_evt){ '..me.info.dcl.id_..', {&'..V(e)..'} })'
            end
        elseif e.tag == 'Outer' then
            return F.ID_int(me,{outer=e.__dcls_outer or AST.root})
        else
            local ptr = ''
            if is_alias=='&' and (not ctx.is_bind) and (me.info.dcl.tag~='Evt') then
                ptr = '*'
            end
            local suf = (ctx and ctx.id_suf) or ''
            return '('..ptr..'('..V(e)..'.'..member..suf..'))'
        end
    end,

-- BIND

    ['Exp_1&'] = function (me)
        local _, e = unpack(me)
        local dcl = e.info.dcl
        if dcl and dcl.tag == 'Evt' then
            return V(e)
        elseif e.tag=='Exp_call' or e.tag=='Abs_Call' then
            -- x = &_f();
            return V(e)
        elseif dcl[1] == '&?' then
            return V(e)
        else
            return '(&'..V(e)..')'
        end
    end,

-- INDEX

    ['Exp_idx'] = function (me)
        local _,arr,idx = unpack(me)
        if TYPES.is_nat(TYPES.get(arr.info.tp,1)) then
            return '('..V(arr)..'['..V(idx)..'])'
        elseif AST.get(me,1,'Exp_&&',2,'')==me then
            return [[
(*(]]..TYPES.toc(me.info.tp)..[[*) ceu_vector_buf_get(&]]..V(arr)..','..V(idx)..[[))
]]
        else
            return [[
(*(]]..TYPES.toc(me.info.tp)..[[*) ceu_vector_geti(&]]..V(arr)..','..V(idx)..[[))
]]
        end
    end,

-- OPTION: ?, !

    ['Exp_?'] = function (me)
        local _, e = unpack(me)
        local alias, tp = unpack(e.info.dcl)
        if alias == '&?' then
            return '('..V(e)..' != NULL)'
        else
            return '('..V(e)..'.is_set)'
        end
    end,

    ['Exp_!'] = function (me)
        local _, e = unpack(me)
        local alias, tp = unpack(e.info.dcl)
        if alias == '&?' then
            if e.info.dcl.tag == 'Var' then
                return '(*CEU_OPTION_'..TYPES.toc(e.info.tp)..'('..V(e)..', '..TRACE(0)..'))'
            elseif e.info.dcl.tag == 'Evt' then
                return '(*CEU_OPTION_EVT('..V(e)..'.alias, '..TRACE(0)..'))'
            else
                error 'not implemented'
            end
        else
            return '(CEU_OPTION_'..TYPES.toc(e.info.tp)..'(&'..V(e)..', '..TRACE(0)..')->value)'
        end
    end,

-- VECTOR LENGTH: $, $$

    ['Exp_$$'] = function (me)
        local _, e = unpack(me)
        return '('..V(e)..'.max)'
    end,
    ['Exp_$'] = function (me)
        local _, e = unpack(me)
        return '('..V(e)..'.len)'
    end,

-- UNARY

    ['Exp_1*']  = 'Exp_1',
    ['Exp_&&']  = 'Exp_1',
    ['Exp_1+']  = 'Exp_1',
    ['Exp_1-']  = 'Exp_1',
    ['Exp_not'] = 'Exp_1',
    ['Exp_~']   = 'Exp_1',
    Exp_1 = function (me)
        local op,e = unpack(me)
        return '('..ceu2c(op)..V(e)..')'
    end,

-- BINARY

    ['Exp_+']   = 'Exp_2',
    ['Exp_-']   = 'Exp_2',
    ['Exp_*']   = 'Exp_2',
    ['Exp_/']   = 'Exp_2',
    ['Exp_%']   = 'Exp_2',
    ['Exp_|']   = 'Exp_2',
    ['Exp_&']   = 'Exp_2',
    ['Exp_==']  = 'Exp_2',
    ['Exp_!=']  = 'Exp_2',
    ['Exp_or']  = 'Exp_2',
    ['Exp_and'] = 'Exp_2',
    ['Exp_>']   = 'Exp_2',
    ['Exp_<']   = 'Exp_2',
    ['Exp_<=']  = 'Exp_2',
    ['Exp_>=']  = 'Exp_2',
    ['Exp_>>']  = 'Exp_2',
    ['Exp_<<']  = 'Exp_2',
    ['Exp_^']   = 'Exp_2',
    Exp_2 = function (me)
        local op,e1,e2 = unpack(me)
        return '('..V(e1)..ceu2c(op)..V(e2)..')'
    end,

-- IS, AS/CAST

    Exp_is = function (me)
        local _, e, Type = unpack(me)
        local base = DCLS.base(Type[1].dcl)
        return 'ceu_data_is(CEU_DATA_SUPERS_'..base.id_..','..
                            V(e)..'._enum, CEU_DATA_'..Type[1].dcl.id_..')'
    end,

    Exp_as = function (me)
        local _, e, Type = unpack(me)

        if Type.tag ~= 'Type' then
            return V(e)
        end

        -- data Xx=1; (x as int);
        local plain = TYPES.ID_plain(e.info.tp)
        if plain and plain.dcl and plain.dcl.tag=='Data'
            and TYPES.check(Type,'int')
        then
            local base = DCLS.base(plain.dcl)
            return '(CEU_DATA_NUMS_'..base.id_..'['..V(e)..'._enum])'
        end

        local ret do
            local base = (Type[1].tag=='ID_abs' and Type[1].dcl.tag=='Data')
                            and DCLS.base(Type[1].dcl)
            if base then
                local ptr1,ptr2,ptr3 = '*', '*', '&'
                if TYPES.check(Type,'&&') then
                    ptr1, ptr2, ptr3 = '', '', ''
                elseif e.info.tag == 'Alias' then
                    ptr1, ptr2, ptr3 = '', '*', ''
                end
                ret = [[
(]]..ptr1..[[(
(]]..TYPES.toc(Type)..ptr2..[[)
ceu_data_as(CEU_DATA_SUPERS_]]..base.id_..[[,
            (tceu_ndata*)]]..ptr3..V(e)..', CEU_DATA_'..Type[1].dcl.id_..[[,
            ]]..TRACE(-4)..[[)
))
]]
            else
                ret = '(('..TYPES.toc(Type)..')('..V(e)..'))'
            end
        end
        if TYPES.check(Type,'bool') then
            ret = '('..ret..'? 1 : 0)'
        end
        return ret
    end,
}

end

    
do
MULTIS = {}

local function down (T, i, sup, ret)
    local t = T[i]
    local dyn = unpack(T[i])
    local up = ret[#ret]
    for _, dcl in ipairs(sup.hier.down) do
        local me = {
            data = 'CEU_DATA_'..TYPES.noc(dcl.id),
            dyn  = string.gsub(t.dyn, '_'..t.base.id_,
                                      '_'..TYPES.noc(dcl.id_)),
            id   = dcl.id,

            idx  = #ret+1,
            left = ret,
            up   = up,
        }
        ret[#ret+1] = me
        down(T, i, dcl, ret)
        fff(T, i+1, me)
    end
end

function fff (T , i, ret)
    if i > #T then
        return
    end
    assert(#ret == 0)

    local t = T[i]
    local me = {
        data = 'CEU_DATA_'..TYPES.noc(t.base.id),
        dyn  = t.dyn,
        id   = t.base.id,

        idx  = #ret+1,
        left = ret,
        up   = nil,
    }
    ret[#ret+1] = me
    down(T, i, t.base, ret)
    fff(T, i+1, me)
end

--[[
function dump (ret, spc)
    spc = spc or ''
    if #ret == 0 then
        local dyn = ret.dyn
        while ret.left.dyn do
            dyn = ret.left.dyn..dyn
            ret = ret.left
        end
        local has = DCLS.get(AST.par(AST.iter()(),'Block'), dyn)
        print(spc..dyn)
        print(spc..'('..tostring(has)..')')
    else
        for i, t in ipairs(ret) do
            local spc = spc..'  '
            --print(spc..'{ id='..t.id..',')
            print(spc..'['..i..'] = { data='..t.data..', id='..t.id..
                                    ', up='..(t.up and t.up.id or '')..
                                    ', left='..(t.left.id or '')..',')
            dump(t, spc..' ')
            print(spc..'}')
        end
    end
end
]]

function get (Code, ret, goleft)
    local dyn = ret.dyn
    local cur = ret
    while cur.left.dyn do
        dyn = cur.left.dyn..dyn
        cur = cur.left
    end
    dyn = Code.id..dyn

    local dcl = DCLS.get(AST.par(Code,'Block'), dyn)
    if dcl then
        return dcl
    end

    if ret.up then
        dcl = get(Code, ret.up, false)
        if dcl then
            return dcl
        end
    end

    if goleft then
        local idxs = { ret.idx }
        local left = assert(ret.left)
        while not left.up do
            left = ASR(left.left, Code, 'missing implementation')
            idxs[#idxs+1] = 1
        end
        local t = left.up
        for i=#idxs,1,-1 do
            t = t[ idxs[i] ]
        end
        dcl = get(Code, t, true)
        return assert(dcl)
    end
end

--[[
function dump2 (Code, ret, spc)
    spc = spc or ''
    if #ret == 0 then
        return (spc..get(Code,ret,true).id)..'\n'
    else
        local str = ''
        for i, t in ipairs(ret) do
            local spc = spc..'  '
            --print(spc..'{ id='..t.id..',')
            str = str .. (spc..'['..i..'] = { data='..t.data..', id='..t.id..
                            --', me='..string.sub(tostring(t),8)..
                            --', left='..string.sub(tostring(t),8)..
                            ', up='..(t.up and t.up.id or '')..
                            ', left='..(t.left.id or '')..',') .. '\n'
            str = str .. dump2(Code, t, spc..' ')
            str = str .. (spc..'}') .. '\n'
        end
        return str
    end
end
]]

function dump3 (Code, f, ret, spc)
    spc = spc or ''
    if #ret == 0 then
        return spc..f(get(Code,ret,true).id_)..',\n'
    else
        local str = ''
        for i, t in ipairs(ret) do
            local spc = spc..' '
            if #t > 0 then
                str = str..spc..'{\n'..dump3(Code,f,t,spc..' ')..spc..'},\n'
            else
                str = str..dump3(Code,f,t,spc)
            end
        end
        return str
    end
end

function dims (ret)
    if #ret > 0 then
        return '['..#ret..']'..dims(ret[1])
    else
        return ''
    end
end

local f1 = function (id)
    return 'CEU_LABEL_Code_'..id
end
local f2 = function (id)
    return 'offsetof(tceu_code_mem_'..id..', _params)'
end

function MULTIS.tostring (Code, T)
    local ret = {}
    fff(T, 1, ret)
    return dims(ret), dump3(Code,f1,ret), dump3(Code,f2,ret)
end

end

    
do
MEMS = {
    isrs = '',
    exts = {
        types       = '',
        enum_input  = '',
        enum_output = '',
        defines_input_output = '',
    },
    evts = {
        types = '',
        enum  = '',
    },
    codes = {
        mems     = '',
        wrappers = '',
--[[
        args     = '',
        [1] = {
            mem     = '',
            wrapper = '',
            args    = '',
        }
]]
    },
    datas = {
        id    = 1,
        mems  = '',
        hiers = '',
        bases = {},
        casts = {},     -- see code.lua
    },
    opts = {
        -- avoids duplications
        --[TYPES.tostring(tp)] = true,
        ['Exception?'] = true,
    },
}

local EVENT_SUFIX_EXISTS = {}

local function CUR ()
    for n in AST.iter() do
        if n.tag == 'Async_Isr' or
           n.tag == 'Code'      or
           n.tag == 'Ext_impl'  or
           n.tag == 'Data'
        then
            return n.mems
        end
    end
    return AST.root.mems
end

F = {
    ROOT__PRE = function (me)
        me.mems = { mem='' }
    end,
    ROOT__POS = function (me)
        me.mems.mem = [[
typedef struct tceu_code_mem_ROOT {
    tceu_code_mem _mem;
    tceu_trl      _trails[]]..me.trails_n..[[];
    byte          _params[0];
    ]]..me.mems.mem..[[
} tceu_code_mem_ROOT;
]]..'\n'
        MEMS.codes[#MEMS.codes+1] = me.mems
    end,

    ---------------------------------------------------------------------------

    Code__PRE = function (me)
        me.mems = { me=me, mem='' }
    end,
    Code__POS = function (me)
        local mods = unpack(me)

        if me.is_dyn_base or me.is_impl then
            MEMS.codes[#MEMS.codes+1] = me.mems
        end

        if not me.is_impl then
            return
        end

        me.mems.mem = [[
typedef struct tceu_code_mem_]]..me.id_..[[ {
    tceu_code_mem _mem;
    tceu_trl      _trails[]]..(me.dyn_base and me.dyn_base.max_trails_n or me.trails_n)..[[];
    byte          _params[0];
    ]]..me.mems.mem..[[
} tceu_code_mem_]]..me.id_..[[;
]]
    end,

    Code = function (me)
        local mods, _, _, body = unpack(me)

        me.mems.wrapper = ''

        if (not me.is_dyn_base) and ((not me.is_impl) or mods.dynamic) then
            --me.mems.args = ''
            --me.mems.wrapper = ''
            return
        end

        local multis = {}
        if mods.dynamic then
            local Code_Pars = AST.asr(body,'', 1,'Stmts', 2,'Do', 3,'Block', 1,'Stmts', 1,'Code_Pars')
            for i, dcl in ipairs(AST.par(Code_Pars,'Block').dcls) do
                local _,_,_,dcl_mods = unpack(dcl)
                if dcl_mods.dynamic then
                    local _,Type,id = unpack(dcl)
                    local data = AST.asr(Type,'',1,'ID_abs')
                    ASR(data.dcl.hier and (not data.dcl.hier.up), me,
                        'invalid `code` declaration : missing base case')
--[=[
                    me.mems.args = me.mems.args .. [[
tceu_ndata _data_]]..i..[[;     /* force multimethod arg data id */
]]
]=]

                    -- arg "i" is dynamic:
                    multis[#multis+1] = {
                        base = data.dcl,    -- datatype for the argument
                        dyn  = dcl.id_dyn,  -- identifier considering the "base" value
                        id   = id,          -- argument identifier
                        dcl  = dcl,
                        --i    = i,           -- position in the parameter list
                    }
                end
            end
            assert(#multis > 0)

            local dims, lbls, params = MULTIS.tostring(me, multis);

            -- LBL
            do
                multis.lbl = [[
static tceu_ndata multis_lbl]]..dims..[[ = {
]] .. lbls .. [[
};
tceu_nlbl lbl = multis_lbl
]]
                for _, t in ipairs(multis) do
                    local is_alias, tp = unpack(t.dcl)
                    local op = ((is_alias or TYPES.check(tp,'&&')) and '->') or '.'
                    multis.lbl = multis.lbl..'[ mem->'..t.dcl.id_..op..'_enum ]'
                end
                multis.lbl = multis.lbl..';\n'
            end

            -- WATCH
--[=[
            do
                multis.params = [[
static tceu_ndata multis_params]]..dims..[[ = {
]] .. params .. [[
};
usize params = multis_params
]]
                for _, t in ipairs(multis) do
                    multis.params = multis.params..'[ args->_data_'..t.i..' ]'
                end
                multis.params = multis.params..';\n'
            end
]=]
        end

        --me.mems.args = me.mems.args..'} tceu_code_args_'..me.id_..';\n'

        -- CEU_CODE_xxx

        local Type = AST.get(body,'Block', 1,'Stmts', 1,'Code_Ret', 1,'', 2,'Type')
        if mods.tight then
            me.mems.wrapper = me.mems.wrapper .. [[
static ]]..TYPES.toc(assert(Type))..[[ /* space */
CEU_CODE_]]..me.id_..[[ (tceu_code_mem_]]..me.id_..[[ mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_]]..me.id_..[[* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = ]]..me.depth..[[;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
]]
            if mods.dynamic then
                me.mems.wrapper = me.mems.wrapper .. multis.lbl
            else
                me.mems.wrapper = me.mems.wrapper .. [[
    tceu_nlbl lbl = ]]..me.lbl_in.id..[[;
]]
            end
            me.mems.wrapper = me.mems.wrapper .. [[
    ceu_lbl(NULL, NULL, (tceu_code_mem*)mem, 0, lbl);
]]
            if Type and (not TYPES.check(Type,'none')) then
                me.mems.wrapper = me.mems.wrapper..[[
    return mem_._ret;
]]
            end
            me.mems.wrapper = me.mems.wrapper..[[
}
]]
        else
            me.mems.wrapper = me.mems.wrapper .. [[
static void CEU_CODE_]]..me.id_..[[ (tceu_stk* stk, tceu_ntrl trlK,
                                     tceu_code_mem_]]..me.id_..[[* mem)
{
]]
            if mods.dynamic then
                me.mems.wrapper = me.mems.wrapper .. multis.lbl
            else
                me.mems.wrapper = me.mems.wrapper .. [[
    tceu_nlbl lbl = ]]..me.lbl_in.id..[[;
]]
            end
            me.mems.wrapper = me.mems.wrapper .. [[
    tceu_stk __ceu_stk = { 1, 0, stk, {(tceu_code_mem*)mem,]]..me.trails[1]..','..me.trails[2]..[[} };
    ceu_lbl(NULL, &__ceu_stk, (tceu_code_mem*)mem, trlK, lbl);
    CEU_LONGJMP_JMP_((&__ceu_stk));
]]
            me.mems.wrapper = me.mems.wrapper .. [[
}
]]
        end
    end,

    ---------------------------------------------------------------------------

    Data__PRE = function (me)
        me.id_ = TYPES.noc(me.id_)
        me.mems = {
            mem  = '',
            hier = nil, -- only for base class
        }
    end,
    Data__POS = function (me)
        local _,num = unpack(me)
        local mem = me.mems.mem
        me.mems.mem = [[
typedef struct tceu_data_]]..me.id_..[[ {
]]
        if me.hier or num then
assert(me.hier)
            me.mems.mem = me.mems.mem..[[
    tceu_ndata _enum;
]]
        end
        me.mems.mem = me.mems.mem..[[
    ]]..mem..[[
} tceu_data_]]..me.id_..[[;
]]..'\n'

        MEMS.datas.mems = MEMS.datas.mems..me.mems.mem

        if me.hier and (not me.hier.up) then
            MEMS.datas.bases[#MEMS.datas.bases+1] = me
        end
    end,

    __opt = function (alias,tp)
        local str = TYPES.tostring(tp)
        if not MEMS.opts[str] then
            MEMS.opts[str] = true
            local cc = TYPES.toc(tp)
            local c = TYPES.toc(TYPES.pop(tp,'?'))

            MEMS.datas.mems = MEMS.datas.mems..[[
#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_]]..cc..[[(a,b) CEU_OPTION_]]..cc..[[_(a,b)
#else
#define CEU_OPTION_]]..cc..[[(a,b) CEU_OPTION_]]..cc..[[_(a)
#endif
]]

            if alias == '&?' then
                if TYPES.abs_dcl(tp) then
                    MEMS.datas.mems = MEMS.datas.mems..[[
struct ]]..cc..[[;
static struct ]]..cc..'* CEU_OPTION_'..cc..[[_ (struct ]]..cc..[[* alias
#ifdef CEU_FEATURES_TRACE
                                              , tceu_trace trace
#endif
                                              ) {
]]
                else
                    MEMS.datas.mems = MEMS.datas.mems..[[
static ]]..cc..'* CEU_OPTION_'..cc..[[_ (]]..cc..[[* alias
#ifdef CEU_FEATURES_TRACE
                                       , tceu_trace trace
#endif
                                       ) {
]]
                end
                MEMS.datas.mems = MEMS.datas.mems..[[
    ceu_assert_ex(alias != NULL, "value is not set", trace);
    return alias;
}
]]
            else
                MEMS.datas.mems = MEMS.datas.mems..[[
typedef struct ]]..cc..[[ {
    bool      is_set;
    ]]..c..[[ value;
} ]]..cc..[[;

static ]]..cc..'* CEU_OPTION_'..cc..'_ ('..cc..[[* opt
#ifdef CEU_FEATURES_TRACE
                                              , tceu_trace trace
#endif
                                              ) {
    ceu_assert_ex(opt->is_set, "value is not set", trace);
    return opt;
}
]]
            end
        end
    end,

    Ext = function (me)
        local _,tps = unpack(me)
        for _, tp in ipairs(tps) do
            -- new `?` type
            if TYPES.check(tp,'?') then
                F.__opt(false,tp)
            end
        end
    end,

    Var = function (me)
        -- new `?` type
        local alias,tp = unpack(me)
        if (alias=='&?' or TYPES.check(tp,'?')) then
            F.__opt(alias,tp)
        end
    end,

    ---------------------------------------------------------------------------

    __dcl2c = function (dcl)
        if dcl.tag == 'Var' then
            local alias, tp = unpack(dcl)
            if alias then
                if TYPES.abs_dcl(tp) then
                    -- because of recursive definitions
                    return 'struct '..TYPES.toc(tp)..'* '..dcl.id_..';\n'
                else
                    return TYPES.toc(tp)..'* '..dcl.id_..';\n'
                end
            else
                return TYPES.toc(tp)..'  '..dcl.id_..';\n'
            end

        -- EVT
        elseif dcl.tag == 'Evt' then
            local alias = unpack(dcl)
            if alias then
                return 'tceu_evt '..dcl.id_..';\n'
            end

        -- VEC
        elseif dcl.tag == 'Vec' then
            local is_alias, tp, _, dim = unpack(dcl)
            local ptr = (is_alias and '*' or '')
            if TYPES.is_nat(TYPES.get(tp,1)) then
                return [[
]]..TYPES.toc(tp)..' ('..ptr..dcl.id_..')['..V(dim)..[[];
]]
            else
                local ret = ''
                if dim.is_const and (not is_alias) then
                    ret = ret .. [[
]]..TYPES.toc(tp)..' '..dcl.id_..'_buf['..V(dim)..[[];
]]
                end
                return ret .. [[
tceu_vector]]..ptr..' '..dcl.id_..[[;
]]
            end

        -- POOL
        elseif dcl.tag == 'Pool' then
            local is_alias, tp, _, dim = unpack(dcl)
            local ptr = (is_alias and '*' or '')
            ret = ''
            if dim.is_const and (not is_alias) then
                ret = ret .. [[
tceu_code_mem_dyn* ]]..dcl.id_..'_queue['..V(dim)..[[];
byte ]]..dcl.id_..[[_buf[
(sizeof(tceu_code_mem_dyn)+sizeof(]]..TYPES.toc(tp)..')) * '..V(dim)..[[
];
]]
            end
            return ret .. [[
tceu_pool_pak]]..ptr..' '..dcl.id_..[[;
]]
        end
    end,

    Block__PRE = function (me)
        local mem = {}

        local code = AST.par(me, 'Code')
        local toplevel = ( AST.get(me,1,'Data') or
                           code and AST.depth(me)<=AST.depth(code.__adjs_2) )

        for _, dcl in ipairs(me.dcls) do
if dcl.tag ~= 'Prim' then
            local alias, Type = unpack(dcl)

            if dcl.ln then
                if CEU.opts.ceu_line_directives then
                    mem[#mem+1] = [[
#line ]]..dcl.ln[2]..' "'..dcl.ln[1]..[["
]]
                end
            end

            if dcl.tag=='Var' or dcl.tag=='Evt' then
                dcl.id_ = dcl.id

                local ok = (not dcl.__dcls_dup)
                if ok then
                    local blk1 = AST.par(dcl, 'Block')
                    local blk2 = AST.par(blk1,'Block') or blk1
                    if toplevel or AST.get(me,8,'Code') then
                        --ok = true
                    elseif blk1.__par.tag == 'Code' then
                        --ok = true
                    elseif blk2.__par.tag == 'ROOT' then
                        --ok = true
                    elseif blk1.__par.tag == 'Ext_impl' then
                        --ok=true
                    else
                        local blk3 = AST.par(blk2,'Block') or blk2
                        if blk3.__par.tag == 'Code' then
                            --ok = true
                        else
                            ok = false
                        end
                    end
                end
                if not ok then
                    dcl.id_ = dcl.id_..'_'..dcl.n
                end
            end

            -- VAR
            if dcl.tag == 'Var' then
                --if dcl.id == '_ret' then
                    --dcl.id_ = dcl.id
                --else
                    mem[#mem+1] = F.__dcl2c(dcl)
                --end

            -- EVT
            elseif dcl.tag == 'Evt' then
                if alias then
-- TODO: per Code evts
                    MEMS.evts[#MEMS.evts+1] = dcl
                    dcl.id_ = dcl.id
                    mem[#mem+1] = F.__dcl2c(dcl)
                else
                    local data = AST.par(me,'Data')
                    if data then
                        -- same name for all class hierarchy
                        if data.hier then
                            data = DCLS.base(data)
                        end
                        dcl.id_ = string.upper('CEU_EVENT'..'_'..data.id..'_'..dcl.id)
                        if data == AST.par(me,'Data') then
                            -- avoids duplication with super
                            MEMS.evts[#MEMS.evts+1] = dcl
                        end
                    else
                        dcl.id_ = string.upper('CEU_EVENT_'..dcl.id..'_'..dcl.n)
                        MEMS.evts[#MEMS.evts+1] = dcl
                    end
                end

            -- VEC
            elseif dcl.tag == 'Vec' then
                local is_alias, tp, _, dim = unpack(dcl)
                local ptr = (is_alias and '*' or '')
                dcl.id_ = dcl.id
                if not toplevel then
                    dcl.id_ = dcl.id..'_'..dcl.n
                end
                mem[#mem+1] = F.__dcl2c(dcl)

            -- POOL
            elseif dcl.tag == 'Pool' then
                local is_alias, tp, _, dim = unpack(dcl)
                local ptr = (is_alias and '*' or '')
                dcl.id_ = dcl.id
                if not toplevel then
                    dcl.id_ = dcl.id..'_'..dcl.n
                end
                mem[#mem+1] = F.__dcl2c(dcl)

            -- EXT
            elseif dcl.tag == 'Ext' then
                local inout, _, id = unpack(dcl)
                if not dcl.__dcls_old then
                    MEMS.exts[#MEMS.exts+1] = dcl
                end
                dcl.id_ = string.upper('CEU_'..inout..'_'..id)
            end
end
        end
        if AST.par(me,'Data') then
            CUR().mem = CUR().mem..table.concat(mem)
        else
            CUR().mem = CUR().mem..'struct {\n'..table.concat(mem)
        end
    end,
    Block__POS = function (me)
        if not AST.par(me,'Data') then
            CUR().mem = CUR().mem..'};\n'
        end
    end,

    ---------------------------------------------------------------------------

    Stmts__PRE = function (me)
        if not AST.par(me,'Data') then
            CUR().mem = CUR().mem..'union {\n'
        end
    end,
    Stmts__POS = function (me)
        if not AST.par(me,'Data') then
            CUR().mem = CUR().mem..'};\n'
        end
    end,

    Await_Wclock = function (me)
        CUR().mem = CUR().mem..'s32 __wclk_'..me.n..';\n'
    end,

    Abs_Spawn = function (me)
        local _,Abs_Cons = unpack(me)
        CUR().mem = CUR().mem..'tceu_code_mem_'..Abs_Cons.id_..' __mem_'..me.n..';\n'
    end,

    ---------------------------------------------------------------------------

    Par_Or__PRE  = 'Par__PRE',
    Par_And__PRE = 'Par__PRE',
    Par__PRE = function (me)
        CUR().mem = CUR().mem..'struct {\n'
    end,
    Par_Or__POS  = 'Par__POS',
    Par_And__POS = 'Par__POS',
    Par__POS = function (me)
        CUR().mem = CUR().mem..'};\n'
    end,

    Par_And = function (me)
        for i=1, #me do
            CUR().mem = CUR().mem..'u8 __and_'..me.n..'_'..i..': 1;\n'
        end
    end,

    Catch__PRE = 'Par__PRE',
    Catch__POS = 'Par__POS',
    Catch = function (me)
        CUR().mem = CUR().mem..'tceu_catch __catch_'..me.n..';\n'
    end,

    ---------------------------------------------------------------------------

    Loop__PRE = function (me)
        CUR().mem = CUR().mem..'struct {\n'
    end,
    Loop__POS = function (me)
        CUR().mem = CUR().mem..'};\n'
    end,
    Loop = function (me)
        local max = unpack(me)
        if max then
            CUR().mem = CUR().mem..'int __max_'..me.n..';\n'
        end
    end,

    Loop_Num__PRE = 'Loop__PRE',
    Loop_Num__POS = 'Loop__POS',
    Loop_Num = function (me)
        local max, i, range, body = unpack(me)
        local fr, dir, to, step = unpack(range)
        F.Loop(me)  -- max
        CUR().mem = CUR().mem..TYPES.toc(i.info.tp)..' __fr_'..me.n..';\n'
        if to.tag ~= 'ID_any' then
            CUR().mem = CUR().mem..TYPES.toc(i.info.tp)..' __lim_'..me.n..';\n'
        end
    end,

    Loop_Pool__PRE = 'Loop__PRE',
    Loop_Pool__POS = 'Loop__POS',
    Loop_Pool = function (me)
        CUR().mem = CUR().mem..'tceu_code_mem_dyn* __cur_'..me.n..';\n'
    end,

    ---------------------------------------------------------------------------

    Ext_impl__PRE = 'Async_Isr__PRE',

    Async_Isr__PRE = function (me)
        me.mems = { mem='' }
    end,

    Async_Isr = function (me)
        local exps, vars, _, blk = unpack(me)
        MEMS.isrs = MEMS.isrs..'#define CEU_ISR__'..TYPES.noc(V(exps[1]))..'\n'
    end,

    Async_Thread__PRE = function (me)
        CUR().mem = CUR().mem..'struct {\n'
    end,
    Async_Thread = function (me)
        CUR().mem = CUR().mem..'tceu_threads_data* __thread_'..me.n..';\n'
    end,
    Async_Thread__POS = function (me)
        CUR().mem = CUR().mem..'};\n'
    end,

    ---------------------------------------------------------------------------

    Lua_Do__PRE = function (me)
        CUR().mem = CUR().mem..'struct {\n'
    end,
    Lua_Do = function (me)
        CUR().mem = CUR().mem..'lua_State* __lua_'..me.n..';\n'
    end,
    Lua_Do__POS = function (me)
        CUR().mem = CUR().mem..'};\n'
    end,
}

AST.visit(F)

for _, dcl in ipairs(MEMS.exts) do
if not dcl.__dcls_old then
    local inout, Typelist = unpack(dcl)

    -- enum
    if inout == 'input' then
        MEMS.exts.enum_input  = MEMS.exts.enum_input..dcl.id_..',\n'
    else
        MEMS.exts.enum_output = MEMS.exts.enum_output..dcl.id_..',\n'
    end
    MEMS.exts.defines_input_output = MEMS.exts.defines_input_output..
                                        '#define _'..dcl.id_..'_\n'

    -- type
    local mem = 'typedef struct tceu_'..inout..'_'..dcl.id..' {\n'
    for i,Type in ipairs(Typelist) do
        local ptr = (dcl.are_aliases and dcl.are_aliases[i] and '*') or ''
        mem = mem..'    '..TYPES.toc(Type)..ptr..' _'..i..';\n'
    end
    mem = mem..'} tceu_'..inout..'_'..dcl.id..';\n'

    -- mem
    local impl = AST.par(dcl,'Ext_impl')
    if impl then
        mem = mem..[[
typedef struct tceu_]]..inout..[[_mem_]]..dcl.id..[[ {
    ]]..AST.par(dcl,'Ext_impl').mems.mem..[[
} tceu_]]..inout..[[_mem_]]..dcl.id..[[;
]]
    end

    MEMS.exts.types = MEMS.exts.types..mem
end
end

for _, dcl in ipairs(MEMS.evts) do
    local is_alias,Typelist = unpack(dcl)

    -- enum
    if not is_alias then
        MEMS.evts.enum = MEMS.evts.enum..dcl.id_..',\n'
    end

    -- type
    local sufix = TYPES.noc(TYPES.tostring(Typelist))
    if not EVENT_SUFIX_EXISTS[sufix] then
        EVENT_SUFIX_EXISTS[sufix] = true
        local mem = [[
typedef struct tceu_event_]]..sufix..[[ {
]]
        for i,Type in ipairs(Typelist) do
            mem = mem..'    '..TYPES.toc(Type)..' _'..i..';\n'
        end
        mem = mem..[[
} tceu_event_]]..sufix..[[;
]]
        MEMS.evts.types = MEMS.evts.types..mem
    end
end

for i, code in ipairs(MEMS.codes) do
    local me = code.me
    local mods = me and unpack(me)

    if not (me and me.is_dyn_base) then
        MEMS.codes.mems = MEMS.codes.mems..code.mem
    end

    if i < #MEMS.codes then
        --MEMS.codes.args = MEMS.codes.args..code.args
        if code.wrapper then
            MEMS.codes.wrappers = MEMS.codes.wrappers..code.wrapper
        end
    end

    if me and me.dyn_base and me.dyn_base.dyn_last==me then
        local first = me.dyn_base.dyn_first
        local mem = string.gsub(first.mems.mem,
                                'typedef struct tceu_code_mem_'..first.id_,
                                'typedef struct tceu_code_mem_'..me.dyn_base.id_)
              mem = string.gsub(mem,
                                '} tceu_code_mem_'..first.id_..';',
                                '} tceu_code_mem_'..me.dyn_base.id_..';')
        MEMS.codes.mems = MEMS.codes.mems..mem
    end
end

local function ids_supers_enums (dcl)
    local _, num = unpack(dcl)
    local t = {
        ids    = '',
        supers = '',
        nums  = '',
    }

    if dcl.hier.up then
        t.ids = t.ids .. [[
    CEU_DATA_]]..dcl.id_..[[,
]]
        t.supers = t.supers .. [[
    CEU_DATA_]]..dcl.hier.up.id_..[[,
]]
    else
        t.ids = t.ids .. [[
    CEU_DATA_]]..dcl.id_..[[ = 0,
]]
        t.supers = t.supers .. [[
    0,
]]
    end

    if num ~= 'nothing' then
        local v = num and V(num) or 'CEU_DATA_'..dcl.id_
        t.nums = t.nums .. [[
    ]]..v..[[,
]]
    end

    for _, sub in ipairs(dcl.hier.down) do
        local tt = ids_supers_enums(sub)
        t.ids    = t.ids    .. tt.ids
        t.supers = t.supers .. tt.supers
        t.nums   = t.nums   .. tt.nums
    end

    return t
end

for _, base in ipairs(MEMS.datas.bases) do
    local t = ids_supers_enums(base)
    MEMS.datas.hiers = MEMS.datas.hiers .. [[
enum {
    ]]..t.ids..[[
};

tceu_ndata CEU_DATA_SUPERS_]]..base.id_..[[ [] = {
    ]]..t.supers..[[
};
]]
    if t.nums ~= '' then
        MEMS.datas.hiers = MEMS.datas.hiers .. [[
tceu_ndata CEU_DATA_NUMS_]]..base.id_..[[ [] = {
    ]]..t.nums..[[
};
]]
    end
end

end

    
do
CODES = {
    native  = { pre='', pos='' },
    threads = '',
    isrs    = '',
    exts    = {},
}

local function LINE_DIRECTIVE (me)
    if CEU.opts.ceu_line_directives then
        return [[
#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]]
    else
        return ''
    end
end

local function LINE (me, line)
    me.code = me.code..'\n'..[[
/* ]]..me.tag..' (n='..me.n..', ln='..me.ln[2]..[[) */
]]
    if CEU.opts.ceu_line_directives then
        me.code = me.code..'\n'..LINE_DIRECTIVE(me)
    end
    me.code = me.code..line
end

local function CONC (me, sub)
    me.code = me.code..sub.code
end

local function CONC_ALL (me)
    for _, sub in ipairs(me) do
        if AST.is_node(sub) then
            CONC(me, sub)
        end
    end
end

local function CASE (me, lbl)
    if AST.par(me,'Async_Thread') or AST.par(me,'Async_Isr') or AST.par(me,'Ext_impl') then
        LINE(me, lbl.id..':;\n')
    else
        LINE(me, 'case '..lbl.id..':;\n')
    end
end

local function CLEAR (me, lbl)
    LINE(me, [[
{
    /*
     * clears pending stack frames that I am killing
     * returns and makes them "longjmp" back to here
     */
    ceu_stack_clear(_ceu_stk, _ceu_mem,
                    ]]..me.trails[1]..[[, ]]..me.trails[2]..[[);
    CEU_LONGJMP_SET(_ceu_stk,]]..(lbl and lbl.id or me.lbl_clr.id)..[[)
}
{
    tceu_evt_range __ceu_range = { _ceu_mem, ]]..me.trails[1]..', '..me.trails[2]..[[ };
    tceu_evt_occ __ceu_occ = { {CEU_INPUT__CLEAR,{NULL}}, (tceu_nseq)(CEU_APP.seq+1),
                               NULL, __ceu_range };

    tceu_stk __ceu_stk  = { 1, 0, _ceu_stk, {_ceu_mem,_ceu_trlK,_ceu_trlK} };
    ceu_bcast(&__ceu_occ, &__ceu_stk, 1);
    CEU_LONGJMP_JMP((&__ceu_stk));
}
]])
end

local function HALT (me, T)
    T = T or {}
    for _, t in ipairs(T) do
        local id, val = next(t)
        LINE(me, [[
_ceu_mem->_trails[]]..(T.trail or me.trails[1])..'].'..id..' = '..val..[[;
]])
    end
    if T.exec then
        LINE(me, [[
]]..T.exec..[[
]])
    end
    LINE(me, [[
return;
]])
    if T.lbl then
        LINE(me, [[
case ]]..T.lbl..[[:;
]])
    end
end

function SET (me, to, fr, to_ok, fr_ok, to_ctx, fr_ctx)
    local fr_val = fr
    local to_val = to

    if not to_ok then
        to_val = V(to,to_ctx)
    end

    if not fr_ok then
        -- var Ee.Xx ex = ...;
        -- var&& Ee = &&ex;
        local cast = ''
        if to.info.tp[1].tag == 'ID_abs' then
            if TYPES.check(to.info.tp,'&&') then
                cast = '('..TYPES.toc(to.info.tp)..')'
            end
        end
        fr_val = cast..V(fr,fr_ctx)
    end

    local fr_is_opt = fr.info and TYPES.check(fr.info.tp,'?')
    local to_is_opt = TYPES.check(to.info.tp,'?')
    if to_is_opt then
        to_val = '('..to_val..'.value)'

        if fr_is_opt then
            LINE(me, [[
]]..V(to)..[[.is_set = ]]..fr_val..[[.is_set;
]])
        else
            LINE(me, [[
]]..V(to)..[[.is_set = 1;
]])
        end
    end
    if fr_is_opt then
        fr_val = '('..fr_val..'.value)'
    end

-- TODO: unify-01
    -- Base <- Super
    if not fr_ok then
        local to_tp = to.info.tp
        if to_is_opt then
            to_tp = TYPES.pop(to.info.tp,'?')
        end
        local to_abs = TYPES.abs_dcl(to_tp, 'Data')
        local is_alias = unpack(to.info)
        if to_abs and (not is_alias) then
            --  var Super y;
            --  var Base  x;
            --  x = y;
            -- to
            --  x = Base(y)
            local fr_tp = TYPES.toc(TYPES.pop(fr.info.tp,'?'))
            local name = 'CEU_'..fr_tp..'__TO__'..TYPES.toc(to_tp)
            fr_val = name..'('..fr_val..')'

            if not MEMS.datas.casts[name] then
                MEMS.datas.casts[name] = true
                MEMS.datas.casts[#MEMS.datas.casts+1] = [[
]]..TYPES.toc(to_tp)..' '..name..[[ (]]..fr_tp..[[ x)
{
    return (*(]]..TYPES.toc(to_tp)..[[*)&x);
}
]]
            end
        end
    end

    LINE(me, [[
]]..to_val..' = '..fr_val..[[;
]])
end

function CATCHES (me)
    assert(CEU.opts.ceu_features_exception, 'bug found')
    local code = AST.par(me, 'Code')
    local catch = AST.par(me, 'Catch')
    if catch and ((not code) or (AST.depth(catch) > AST.depth(code))) then
        return '(&'..CUR('__catch_'..catch.n)..')'
    else
        return '(_ceu_mem->catches)'
    end
end

function LUA (me)
    assert(CEU.opts.ceu_features_lua, 'bug found')
    local code = AST.par(me, 'Code')
    local lua = AST.par(me, 'Lua_Do')
    if (not code) or (AST.depth(lua) > AST.depth(code)) then
        return CUR('__lua_'..lua.n)
    else
        return '(_ceu_mem->lua)'
    end
end

CODES.F = {
    ROOT     = CONC_ALL,
    Stmts    = CONC_ALL,
    Watching = CONC_ALL,
    Every    = CONC_ALL,

    Node__PRE = function (me)
        me.code = ''
    end,

    ROOT__PRE = function (me)
        CASE(me, me.lbl_in)
        LINE(me, [[
_ceu_mem->up_mem   = NULL;
_ceu_mem->depth    = 0;
#ifdef CEU_FEATURES_TRACE
_ceu_mem->trace.up = NULL;
#endif
#ifdef CEU_FEATURES_EXCEPTION
_ceu_mem->catches  = NULL;
#endif
#ifdef CEU_FEATURES_LUA
_ceu_mem->lua      = NULL;
#endif
_ceu_mem->trails_n = ]]..AST.root.trails_n..[[;
memset(&_ceu_mem->_trails, 0, ]]..AST.root.trails_n..[[*sizeof(tceu_trl));
]])
    end,

    Nat_Block = function (me)
        local pre_pos, code = unpack(me)
        pre_pos = string.sub(pre_pos,2)

        -- unescape `##` => `#`
        code = string.gsub(code, '\n%s*##', '\n#')
        code = string.gsub(code, '^%s*##',  '#')

        CODES.native[pre_pos] = CODES.native[pre_pos]..code..'\n'
    end,
    Nat_Stmt = function (me)
        local ret = ''
        for _, str in ipairs(me) do
            local exp = AST.get(str,'')
            if exp then
                str = V(exp)
            end
            ret = ret .. str
        end

        -- unescape `##` => `#`
        ret = string.gsub(ret, '\n%s*##', '\n#')
        ret = string.gsub(ret, '^%s*##',  '#')

        LINE(me, ret)
    end,

    If = function (me)
        local c, t, f = unpack(me)
        LINE(me, [[
if (]]..V(c)..[[) {
    ]]..t.code..[[
} else {
    ]]..f.code..[[
}
]])
    end,

    Block = function (me)
        LINE(me, [[
{
]])
        CONC_ALL(me)
        if me.needs_clear then
            CLEAR(me)
        end
        LINE(me, [[
}
]])
    end,

    Var = function (me, base)
        local alias, tp = unpack(me)
        if TYPES.check(tp,'?') and (not alias) then
            LINE(me, [[
]]..V(me, {base=base})..[[.is_set = 0;
]])
        end

        if me.__dcls_code_alias == '&?' then
            LINE(me, [[
]]..V(me,{is_bind=true})..[[ = NULL;
]])
            if (not me.__adjs_is_abs_await) then
                HALT(me, {
                    { ['evt.id']  = 'CEU_INPUT__CODE_TERMINATED' },
                    { ['evt.mem'] = 'NULL' },   -- will be set on Set_Alias/Spawn
                    { seq = '(tceu_nseq)(CEU_APP.seq+1)' },
                    { lbl = me.lbl.id },
                    lbl = me.lbl.id,
                    exec = code,
                })
                LINE(me, [[
]]..V(me,{is_bind=true})..[[ = NULL;
]])
                HALT(me)
            end
        end
    end,

    Vec_Init = function (me)
        local vec = unpack(me)
        local _, tp, _, dim = unpack(vec.info.dcl)
        local is_ring = (vec.info.dcl.is_ring and '1') or '0'
        if dim.is_const then
            LINE(me, [[
ceu_vector_init(&]]..V(vec)..','..V(dim)..', '..is_ring..', 0, sizeof('..TYPES.toc(tp)..[[),
                (byte*)&]]..V(vec,{id_suf='_buf'})..[[);
]])
        else
            LINE(me, [[
ceu_vector_init(&]]..V(vec)..', 0, '..is_ring..', 1, sizeof('..TYPES.toc(tp)..[[), NULL);
]])
            if dim ~= '[]' then
                LINE(me, [[
ceu_vector_setmax(&]]..V(vec)..', '..V(dim)..[[, 1);
]])
            end
        end
    end,
    Vec_Finalize = function (me)
        local ID_int = unpack(me)
        LINE(me, [[
ceu_vector_setmax(&]]..V(ID_int,ctx)..[[, 0, 0);
]])
    end,

    Pool_Init = function (me)
        local ID_int = unpack(me)
        local _, tp, _, dim = unpack(ID_int.dcl)
        LINE(me, [[
{
    /* first.nxt = first.prv = &first; */
    tceu_code_mem_dyn* __ceu_dyn = &]]..V(ID_int)..[[.first;
    ]]..V(ID_int)..[[.first = (tceu_code_mem_dyn) { __ceu_dyn, __ceu_dyn, 1, {} };
};
]]..V(ID_int)..[[.up_mem = _ceu_mem;
]]..V(ID_int)..[[.up_trl = ]]..ID_int.dcl.trails[1]..[[;
]]..V(ID_int)..[[.n_traversing = 0;
]])
        if dim == '[]' then
            LINE(me, [[
]]..V(ID_int)..[[.pool.queue = NULL;
]])
        else
            LINE(me, [[
ceu_pool_init(&]]..V(ID_int)..'.pool, '..V(dim)..[[,
              sizeof(tceu_code_mem_dyn)+sizeof(]]..TYPES.toc(tp)..[[),
              (byte**)&]]..CUR(ID_int.dcl.id_..'_queue')..', (byte*)&'..CUR(ID_int.dcl.id_..'_buf')..[[);
]])
        end
        LINE(me, [[
_ceu_mem->_trails[]]..ID_int.dcl.trails[1]..[[].evt.id  = CEU_INPUT__PROPAGATE_POOL;
_ceu_mem->_trails[]]..ID_int.dcl.trails[1]..[[].evt.pak = &]]..V(ID_int)..[[;
]])
    end,
    Pool_Finalize = function (me)
        local ID_int = unpack(me)
        LINE(me, [[
ceu_assert(]]..V(ID_int,ctx)..[[.pool.queue == NULL, "bug found");
{
    tceu_code_mem_dyn* __ceu_cur = ]]..V(ID_int,ctx)..[[.first.nxt;
    while (__ceu_cur != &]]..V(ID_int,ctx)..[[.first) {
        tceu_code_mem_dyn* __ceu_nxt = __ceu_cur->nxt;
        ceu_callback_ptr_num(CEU_CALLBACK_REALLOC, __ceu_cur, 0, CEU_TRACE(0));
        __ceu_cur = __ceu_nxt;
    }
}
]])
    end,

    ---------------------------------------------------------------------------

    Ext_impl__POS = function (me)
        local ext, block = unpack(me)
        local stmts = AST.asr(block,'Block', 1,'Stmts')
        local body = AST.asr(stmts[#stmts], 'Do')
        local inout = unpack(ext)
        CODES.exts[#CODES.exts+1] = [[
case ]]..ext.id_..[[: {
    tceu_]]..inout..[[_mem_]]..ext.id..[[ _ceu_loc;
]]..body.code..[[
    break;
}
]]
    end,

    Code = function (me)
        local mods,_,_,body = unpack(me)
        if not me.is_impl then return end
        if me.is_dyn_base then return end

LINE(me, [[
/* do not enter from outside */
if (0)
{
]])
        CASE(me, me.lbl_in)

        -- CODE/DELAYED
        if mods.await then
            LINE(me, [[
    _ceu_mem->trails_n = ]]..me.trails_n..[[;
    memset(&_ceu_mem->_trails, 0, ]]..me.trails_n..[[*sizeof(tceu_trl));
]])
        end

        CONC(me, body)
        if mods.await then
            CLEAR(me)           -- TODO: only stack_clear?
        end

        local Type = AST.get(body,'Block', 1,'Stmts', 1,'Code_Ret', 1,'', 2,'Type')
        if not Type then
            LINE(me, [[
ceu_assert(0, "reached end of `code`");
]])
        end

        -- CODE/DELAYED
        if mods.await then
            LINE(me, [[
{
    tceu_evt_occ __ceu_occ = {
        { CEU_INPUT__CODE_TERMINATED, {_ceu_mem} },
        (tceu_nseq)(CEU_APP.seq+1),
        _ceu_mem,
        { (tceu_code_mem*)&CEU_APP.root, 0,
          (tceu_ntrl)(CEU_APP.root._mem.trails_n-1) }
    };
    tceu_stk __ceu_stk = { 1, 0, _ceu_stk, {_ceu_mem,_ceu_trlK,_ceu_trlK} };
    ceu_bcast(&__ceu_occ, &__ceu_stk, 1);
    CEU_LONGJMP_JMP((&__ceu_stk));
}

/* TODO: if return value can be stored with "ceu_bcast", we can "free" first
         and remove this extra stack level */

#ifdef CEU_FEATURES_POOL
    /* free */
    /* TODO: classes w/o pools don't need this code */
    if (_ceu_mem->pak != NULL) {
        tceu_code_mem_dyn* __ceu_dyn =
            (tceu_code_mem_dyn*)(((byte*)(_ceu_mem)) - sizeof(tceu_code_mem_dyn));
        ceu_code_mem_dyn_remove(&_ceu_mem->pak->pool, __ceu_dyn);
    }
#endif
]])
        end
        LINE(me, [[
    return; /* HALT(me) */
}
]])
    end,

    --------------------------------------------------------------------------

    __abs = function (me, mem, pak)
        local _, Abs_Cons = unpack(me)
        local obj, ID_abs, Abslist = unpack(Abs_Cons)
assert(not obj, 'not implemented')

        local ret = [[
{
    *((tceu_code_mem_]]..ID_abs.dcl.id_..'*)'..mem..') = '..V(Abs_Cons)..[[;
#ifdef CEU_FEATURES_POOL
    ]]..mem..[[->_mem.pak     = ]]..pak..[[;
#endif
    ]]..mem..[[->_mem.up_mem  = ]]..((pak=='NULL' and '_ceu_mem')   or (pak..'->up_mem'))..[[;
    ]]..mem..[[->_mem.up_trl  = ]]..((pak=='NULL' and me.trails[1]) or (pak..'->up_trl'))..[[;
    ]]..mem..[[->_mem.depth   = ]]..ID_abs.dcl.depth..[[;
]]
        if CEU.opts.ceu_features_trace then
            ret = ret .. LINE_DIRECTIVE(me) .. [[
    ]]..mem..[[->_mem.trace.up   = &_ceu_mem->trace;
    ]]..mem..[[->_mem.trace.file = __FILE__;
    ]]..mem..[[->_mem.trace.line = __LINE__-2;
]]
        end
        if CEU.opts.ceu_features_exception then
            ret = ret .. [[
    ]]..mem..[[->_mem.catches = ]]..CATCHES(me)..[[;
]]
        end
        if CEU.opts.ceu_features_lua then
            ret = ret .. [[
    ]]..mem..[[->_mem.lua    = ]]..LUA(me)..[[;
]]
        end
        ret = ret .. [[
    tceu_stk __ceu_stk  = { 1, 0, _ceu_stk, {_ceu_mem,_ceu_trlK,_ceu_trlK} };
    CEU_CODE_]]..ID_abs.dcl.id_..[[(&__ceu_stk, 0, ]]..mem..[[);
    CEU_LONGJMP_JMP((&__ceu_stk));
}
]]
        return ret
    end,

    Set_Abs_Spawn = CONC_ALL,
    Abs_Spawn = function (me)
        local _,_,pool = unpack(me)

        local set = AST.par(me,'Set_Abs_Spawn')
        if set then
            local _, to = unpack(set)
            LINE(me, [[
]]..V(to,{is_bind=true})..' = &'..CUR('__mem_'..me.n)..[[;
]])
            if not to.dcl.is_anon then
                LINE(me, [[
_ceu_mem->_trails[]]..(to.dcl.trails[1])..[[].evt.mem =  &]]..CUR('__mem_'..me.n)..[[;
]])
            end
        end

        HALT(me, {
            { ['evt.id']  = 'CEU_INPUT__PROPAGATE_CODE' },
            { ['evt.mem'] = '(tceu_code_mem*) &'..CUR('__mem_'..me.n) },
            { lbl = me.lbl_out.id },
            lbl = me.lbl_out.id,
            exec = CODES.F.__abs(me, '(&'..CUR(' __mem_'..me.n)..')', 'NULL'),
        })
    end,

-- TODO: mover p/ Abs_Await
    Abs_Spawn_Pool = function (me)
        local _, Abs_Cons, pool = unpack(me)
        local obj, ID_abs, Abslist = unpack(Abs_Cons)
assert(not obj, 'not implemented')
        local alias,_,_,dim = unpack(pool.info.dcl)

        LINE(me, [[
{
    tceu_code_mem_dyn* __ceu_new;
]])
        if alias then
            LINE(me, [[
#ifdef CEU_FEATURES_DYNAMIC
    if (]]..V(pool)..[[.pool.queue == NULL) {
        ceu_callback_ptr_num(CEU_CALLBACK_REALLOC,
                             NULL,
                             sizeof(tceu_code_mem_dyn) + sizeof(tceu_code_mem_]]..ID_abs.dcl.id_..[[),
                             CEU_TRACE(0)
                            );
        __ceu_new = (tceu_code_mem_dyn*) ceu_callback_ret.ptr;
    } else
#endif
    {
        __ceu_new = (tceu_code_mem_dyn*) ceu_pool_alloc(&]]..V(pool)..[[.pool);
    }
]])
        elseif dim == '[]' then
            LINE(me, [[
    ceu_callback_ptr_num(CEU_CALLBACK_REALLOC,
                         NULL,
                         sizeof(tceu_code_mem_dyn) + sizeof(tceu_code_mem_]]..ID_abs.dcl.id_..[[),
                         CEU_TRACE(0)
                        );
    __ceu_new = (tceu_code_mem_dyn*) ceu_callback_ret.ptr;
]])
        else
            LINE(me, [[
    __ceu_new = (tceu_code_mem_dyn*) ceu_pool_alloc(&]]..V(pool)..[[.pool);
]])
        end

        local set = AST.par(me,'Set_Abs_Spawn')
        local to = set and set[2]
        if set then
            LINE(me, [[
    if (__ceu_new != NULL) {
]])
            LINE(me, [[
        ]]..V(to,{is_bind=true})..' = ((tceu_code_mem_'..ID_abs.dcl.id_..[[*)&__ceu_new->mem[0]);
        _ceu_mem->_trails[]]..(to.dcl.trails[1])..[[].evt.mem = &__ceu_new->mem[0];
    }
]])
        end

        LINE(me, [[
    if (__ceu_new != NULL) {
        __ceu_new->is_alive = 1;
        __ceu_new->nxt = &]]..V(pool)..[[.first;
        ]]..V(pool)..[[.first.prv->nxt = __ceu_new;
        __ceu_new->prv = ]]..V(pool)..[[.first.prv;
        ]]..V(pool)..[[.first.prv = __ceu_new;

        tceu_code_mem_]]..ID_abs.dcl.id_..[[* __ceu_new_mem =
            (tceu_code_mem_]]..ID_abs.dcl.id_..[[*) &__ceu_new->mem[0];
        ]]..CODES.F.__abs(me, '__ceu_new_mem', '(&'..V(pool)..')')..[[
    } else {
]])
        if set and to.dcl[1]=='&' then
            LINE(me, [[
        ceu_assert(0, "out of memory");
]])
        end
        LINE(me, [[
    }
}
]])
    end,

    Kill = function (me)
        local loc, e = unpack(me)
        local abs = TYPES.abs_dcl(loc.info.tp, 'Code')
        assert(abs)

        LINE(me, [[
{
    tceu_code_mem* __ceu_mem = (tceu_code_mem*) ]]..V(loc)..[[;

    tceu_stk __ceu_stk1 = { 1, 0, _ceu_stk, {_ceu_mem,]]..me.trails[1]..','..me.trails[2]..[[} };

    /* clear code blocks */
    {
        tceu_evt_range __ceu_range = { __ceu_mem, ]]..abs.trails[1]..', '..abs.trails[2]..[[ };
        tceu_evt_occ __ceu_occ = { {CEU_INPUT__CLEAR,{NULL}}, (tceu_nseq)(CEU_APP.seq+1),
                                   NULL, __ceu_range };
        ceu_bcast(&__ceu_occ, _ceu_stk, 1);
    }

    /* bcast termination */
    {
        tceu_evt_occ __ceu_occ = {
            { CEU_INPUT__CODE_TERMINATED, {__ceu_mem} },
            (tceu_nseq)(CEU_APP.seq+1),
            __ceu_mem,
            { (tceu_code_mem*)&CEU_APP.root, 0,
              (tceu_ntrl)(CEU_APP.root._mem.trails_n-1) }
        };
        tceu_stk __ceu_stk2 = { 1, 0, &__ceu_stk1, {__ceu_mem,]]..abs.trails[1]..','..abs.trails[2]..[[} };
        ceu_bcast(&__ceu_occ, &__ceu_stk2, 1);
#ifdef CEU_FEATURES_POOL
        if (__ceu_stk2.is_alive) {
/* TODO: if return value can be stored with "ceu_bcast", we can "free" first
         and remove this extra stack level */
            /* free */
            /* TODO: classes w/o pools don't need this code */
            if (__ceu_mem->pak != NULL) {
                tceu_code_mem_dyn* __ceu_dyn =
                    (tceu_code_mem_dyn*)(((byte*)(__ceu_mem)) - sizeof(tceu_code_mem_dyn));
                ceu_code_mem_dyn_remove(&__ceu_mem->pak->pool, __ceu_dyn);
            }
        }
#endif

        CEU_LONGJMP_JMP((&__ceu_stk1));
    }
}
]])
        -- TODO: e
    end,

    --------------------------------------------------------------------------

    Loop_Pool = function (me)
        local _,i,pool,body = unpack(me)
        local Code = AST.asr(pool.info.dcl,'Pool', 2,'Type', 1,'ID_abs').dcl

        local cur = CUR('__cur_'..me.n)

        LINE(me, [[
ceu_assert(]]..V(pool)..[[.n_traversing < 255, "bug found");
]]..V(pool)..[[.n_traversing++;
_ceu_mem->_trails[]]..me.trails[1]..[[].evt.id    = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[]]..me.trails[1]..[[].evt.mem   = _ceu_mem;
_ceu_mem->_trails[]]..me.trails[1]..[[].lbl       = ]]..me.lbl_fin.id..[[;
_ceu_mem->_trails[]]..me.trails[1]..[[].clr_range =
    (tceu_evt_range) { _ceu_mem, ]]..me.trails[1]..','..me.trails[1]..[[ };

if (0) {
    case ]]..me.lbl_fin.id..[[:
        ]]..V(pool)..[[.n_traversing--;
        ceu_code_mem_dyn_gc(&]]..V(pool)..[[);
        return;
}
{
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
    ]]..cur..[[ = ]]..V(pool)..[[.first.nxt;
    while (]]..cur..[[ != &]]..V(pool)..[[.first)
    {
        if (]]..cur..[[->is_alive)
        {
]])
        if i.tag ~= 'ID_any' then
            local abs = TYPES.abs_dcl(i.info.tp,'Code')
            SET(me, i, '((tceu_code_mem_'..abs.id_..'*)'..cur..'->mem)', nil,true, {is_bind=true},nil)
            LINE(me, [[
            _ceu_mem->_trails[]]..(me.trails[1]+1)..[[].evt.id    = CEU_INPUT__CODE_TERMINATED;
            _ceu_mem->_trails[]]..(me.trails[1]+1)..[[].evt.mem   = ]]..cur..'->mem'..[[;
            _ceu_mem->_trails[]]..(me.trails[1]+1)..[[].lbl       = ]]..me.lbl_null.id..[[;
            if (0) {
                case ]]..me.lbl_null.id..[[:;
                    ]]..V(i,{is_bind=true})..[[ = NULL;
                    return;
            }
]])
        end
        CONC(me, body)
        CASE(me, me.lbl_cnt)
        LINE(me, [[
        }
        ]]..cur..[[ = ]]..cur..[[->nxt;
    }
}
]])
        CASE(me, me.lbl_out)
        CLEAR(me)
    end,

    ---------------------------------------------------------------------------

    __fin = function (me, evt)
        LINE(me, [[
_ceu_mem->_trails[]]..me.trails[1]..[[].evt.id    = ]]..evt..[[;
_ceu_mem->_trails[]]..me.trails[1]..[[].lbl       = ]]..me.lbl_in.id..[[;
_ceu_mem->_trails[]]..me.trails[1]..[[].clr_range =
    (tceu_evt_range) { _ceu_mem, ]]..me.trails[1]..','..me.trails[2]..[[ };
]])
    end,

    Finalize = CONC_ALL,
    Finalize_Case = function (me)
        local case, blk = unpack(me)
        CODES.F.__fin(me, case)
        LINE(me, [[
if (0) {
]])
        CASE(me, me.lbl_in)
        CONC(me, blk)
        if case ~= 'CEU_INPUT__FINALIZE' then
            CODES.F.__fin(me, case)
        end
        HALT(me)
        LINE(me, [[
}
]])
    end,

    Pause_If = function (me)
        local e, body = unpack(me)
        LINE(me, [[
_ceu_mem->_trails[]]..me.trails[1]..[[].evt.id     = CEU_INPUT__PAUSE_BLOCK;
_ceu_mem->_trails[]]..me.trails[1]..[[].pse_evt    = ]]..V(e)..[[;
_ceu_mem->_trails[]]..me.trails[1]..[[].pse_skip   = ]]..body.trails_n..[[;
_ceu_mem->_trails[]]..me.trails[1]..[[].pse_paused = 0;
]])
        CONC(me, body)
    end,

    Catch = function (me)
        local loc, body = unpack(me)
        local tp = TYPES.tostring(TYPES.pop(loc.info.tp,'?'))
        LINE(me, [[
{
    ]]..V(loc)..[[.value._enum = CEU_DATA_]]..tp..[[;
    ]]..CUR('__catch_'..me.n)..[[.up        = ]]..CATCHES(me)..[[;
    ]]..CUR('__catch_'..me.n)..[[.mem       = _ceu_mem;
    ]]..CUR('__catch_'..me.n)..[[.trl       = ]]..me.trails[1]..[[;
    ]]..CUR('__catch_'..me.n)..[[.exception = (tceu_opt_Exception*) &]]..V(loc)..[[;
]])
        CONC(me, body)
        LINE(me, [[
}
]])
    end,

    Await_Exception = function (me)
        HALT(me, {
            { ['evt.id'] = 'CEU_INPUT__THROW' },
            { lbl        = me.lbl_out.id      },
            lbl = me.lbl_out.id,
        })
    end,

    Throw = function (me)
        local e = unpack(me)
        if AST.par(me,'Async_Thread') then
            WRN(false, me, 'exception inside `async/thread`')
            LINE(me, [[
ceu_assert(0, ]]..V(e)..[[.message);
]])
        else
            LINE(me, [[
return ceu_throw(]]..CATCHES(me)..[[, (tceu_data_Exception*)&]]..V(e)..[[, sizeof(]]..TYPES.toc(e.info.tp)..[[));
]])
        end
    end,

    ---------------------------------------------------------------------------

    Do = function (me)
        CONC_ALL(me)

        local _,_,blk,set = unpack(me)
        if set and set.info.dcl[1]~='&?' and (not TYPES.check(set.info.tp,'?')) then
            LINE(me, [[
ceu_assert(0, "reached end of `do`");
]])
        end
        CASE(me, me.lbl_out)

        if me.has_escape and (me.trails_n>1 or blk.needs_clear) then
            CLEAR(me)
        end
    end,

    Escape = function (me)
        local code = AST.par(me, 'Code')
        local mods = code and code[2]
        if AST.par(me,'Async_Thread') or AST.par(me,'Async_Isr') or AST.par(me,'Ext_impl') then
            LINE(me, [[
goto ]]..me.outer.lbl_out.id..[[;
]])
        else
            LINE(me, [[
RETURN_CEU_LBL(NULL, _ceu_stk,
               _ceu_mem, ]]..me.outer.trails[1]..','..me.outer.lbl_out.id..[[);
]])
        end
    end,

    ---------------------------------------------------------------------------

    __loop_max = function (me)
        local max = unpack(me)
        if max then
            return {
                -- ensures that max is constant
                ini = [[
{ char __]]..me.n..'['..V(max)..'/'..V(max)..[[ ] = {0}; }
]]..CUR('__max_'..me.n)..[[ = 0;
]],
                chk = [[
ceu_assert(]]..CUR('__max_'..me.n)..' < '..V(max)..[[, "`loop` overflow");
]],
                inc = [[
]]..CUR('__max_'..me.n)..[[++;
]],
            }
        else
            return {
                ini = '',
                chk = '',
                inc = '',
            }
        end
    end,

    __loop_async = function (me)
        local async = AST.par(me, 'Async')
        if async then
            LINE(me, [[
CEU_APP.async_pending = 1;
ceu_callback_num_ptr(CEU_CALLBACK_ASYNC_PENDING, 0, NULL, CEU_TRACE(0));
]])
            HALT(me, {
                { ['evt.id'] = 'CEU_INPUT__ASYNC' },
                { seq        = '(tceu_nseq)(CEU_APP.seq+1)' },
                { lbl        = me.lbl_asy.id },
                lbl = me.lbl_asy.id,
            })
        end
    end,

    Loop = function (me)
        local _, body = unpack(me)
        local max = CODES.F.__loop_max(me)

        LINE(me, [[
]]..max.ini..[[
while (1) {
    ]]..max.chk..[[
    ]]..body.code..[[
]])
        CASE(me, me.lbl_cnt)

        if me.has_continue and me.trails_n>1 then
            CLEAR(me, me.lbl_cnt_clr)
        end

        assert(body.trails[1]==me.trails[1] and body.trails[2]==me.trails[2])

        CODES.F.__loop_async(me)
        LINE(me, [[
    ]]..max.inc..[[
}
]])
        CASE(me, me.lbl_out)

        if me.has_break and me.trails_n>1 then
            CLEAR(me)
        end
    end,

    Loop_Num = function (me)
        local _, i, range, body = unpack(me)
        local fr, dir, to, step = unpack(range)
        local max = CODES.F.__loop_max(me)

        -- check if step is positive (static)
        if step then
            local f = load('return '..V(step))
            if f then
                local ok, num = pcall(f)
                num = tonumber(num)
                if ok and num then
                    if dir == '<-' then
                        num = -num
                    end
                    ASR(num>0, me,
                        'invalid `loop` step : expected positive number : got "'..num..'"')
                end
            end
        end


        if to.tag ~= 'ID_any' then
            local op = (dir=='->' and '<' or '>')
            LINE(me, [[
]]..CUR('__lim_'..me.n)..' = '..V(to)..' + ('..V(step)..'*'..to.__adj_step_mul..[[*-1);
]])
            if to.__adj_step_mul ~= 0 then
                LINE(me, [[
ceu_assert(]]..CUR('__lim_'..me.n)..' '..op..' '..V(to)..[[, "`loop` limit underflow/overflow");
]])
            end
        end

        local sig = (dir=='->' and '' or '-')
        LINE(me, [[
]]..max.ini..[[
ceu_assert(]]..sig..V(step)..[[> 0, "invalid `loop` step : expected positive number");
]])
        local op = (dir=='->' and '>' or '<')
        LINE(me, [[
]]..CUR('__fr_'..me.n)..' = '..V(fr)..[[;
]]..V(i)..' = '..V(fr)..' + '..V(step)..' * '..fr.__adj_step_mul..[[;
ceu_assert_ex(]]..V(i)..(op..'=')..'('..TYPES.toc(i.info.tp)..')'..CUR('__fr_'..me.n)..[[,
    "control variable overflow", CEU_TRACE(-3));
while (1) {
]])
        if to.tag ~= 'ID_any' then
            local op = (dir=='->' and '>' or '<')
            LINE(me, [[
    if (]]..V(i)..' '..op..' '..CUR('__lim_'..me.n)..[[) {
        break;
    }
]])
        end
        LINE(me, [[
    ]]..max.chk..[[
    ]]..body.code..[[
]])
        CASE(me, me.lbl_cnt)
            assert(body.trails[1]==me.trails[1] and body.trails[2]==me.trails[2])
        CODES.F.__loop_async(me)
        LINE(me, [[
    ]]..V(i)..' = '..V(i)..' + '..V(step)..[[;
    ceu_assert_ex(]]..V(i)..op..'('..TYPES.toc(i.info.tp)..')'..CUR('__fr_'..me.n)..[[,
        "control variable overflow", CEU_TRACE(-2));
    ]]..max.inc..[[
}
]])
        CASE(me, me.lbl_out)

        if me.has_break and me.trails_n>1 then
            CLEAR(me)
        end
    end,

    Break = function (me)
        if AST.par(me,'Async_Thread') or AST.par(me,'Async_Isr') then
            LINE(me, [[
goto ]]..me.outer.lbl_out.id..[[;
]])
        else
            LINE(me, [[
RETURN_CEU_LBL(NULL, _ceu_stk,
               _ceu_mem, ]]..me.outer.trails[1]..','..me.outer.lbl_out.id..[[);
]])
        end
    end,
    Continue = function (me)
        if AST.par(me,'Async_Thread') or AST.par(me,'Async_Isr') then
            LINE(me, [[
goto ]]..me.outer.lbl_out.id..[[;
]])
        else
            LINE(me, [[
RETURN_CEU_LBL(NULL, _ceu_stk,
               _ceu_mem, ]]..me.outer.trails[1]..','..me.outer.lbl_cnt.id..[[);
]])
        end
    end,

    Stmt_Call = function (me)
        local call = unpack(me)
        LINE(me, [[
]]..V(call)..[[;
]])
    end,

    ---------------------------------------------------------------------------

    __par_and = function (me, i)
        return CUR('__and_'..me.n..'_'..i)
    end,
    Par_Or  = 'Par',
    Par_And = 'Par',
    Par = function (me)
        -- Par_And: close gates
        if me.tag == 'Par_And' then
            for i, sub in ipairs(me) do
                LINE(me, [[
]]..CUR('__and_'..me.n..'_'..i)..[[ = 0;
]])
            end
        end

        -- call each branch
        for i, sub in ipairs(me) do
            if i < #me then
                local abt = me[i+1].trails[1]
                LINE(me, [[
{
    tceu_stk __ceu_stk = { 1, 0, _ceu_stk, {_ceu_mem,]]..abt..','..abt..[[} };
    ceu_lbl(_ceu_occ, &__ceu_stk,
            _ceu_mem, ]]..sub.trails[1]..[[, ]]..me.lbls_in[i].id..[[);
    CEU_LONGJMP_JMP((&__ceu_stk));
}
]])
            else
                -- no need to abort since there's a "return" below
                LINE(me, [[
RETURN_CEU_LBL(_ceu_occ, _ceu_stk,
              _ceu_mem, ]]..sub.trails[1]..','..me.lbls_in[i].id..[[);
]])
            end
        end

        -- code for each branch
        for i, sub in ipairs(me) do
            CASE(me, me.lbls_in[i])
            CONC(me, sub)

            if me.tag == 'Par' then
                HALT(me)
            else
                -- Par_And: open gates
                if me.tag == 'Par_And' then
                    LINE(me, [[
]]..CUR('__and_'..me.n..'_'..i)..[[ = 1;
]])
                end
                LINE(me, [[
RETURN_CEU_LBL(_ceu_occ, _ceu_stk,
               _ceu_mem, ]]..me.trails[1]..','..me.lbl_out.id..[[);
]])
            end
        end

        -- rejoin
        if me.lbl_out then
            CASE(me, me.lbl_out)
        end

        -- Par_And: test gates
        if me.tag == 'Par_And' then
            for i, sub in ipairs(me) do
                LINE(me, [[
if (! ]]..CUR('__and_'..me.n..'_'..i)..[[) {
]])
                HALT(me)
                LINE(me, [[
}
]])
            end

        -- Par_Or: clear trails
        elseif me.tag == 'Par_Or' then
            CLEAR(me)
        end
    end,

    ---------------------------------------------------------------------------

    Set_Exp = function (me)
        local fr, to = unpack(me)

        if AST.get(to,'Loc',1,'Exp_$') then
            -- $vec = ...
            local _,vec = unpack(to[1])
            LINE(me, [[
ceu_vector_setlen(&]]..V(vec)..','..V(fr)..[[, 0);
]])

        else
            SET(me, to, fr)

            if to.info.dcl.id=='_ret' and (not AST.par(me,'Code')) then
                LINE(me, [[
{   CEU_APP.end_ok=1; CEU_APP.end_val=]]..V(fr)..[[;
    ceu_callback_void_void(CEU_CALLBACK_TERMINATING, CEU_TRACE(0));
}
]])
            end
        end
    end,

    Set_Any = function (me)
        local _, to = unpack(me)
        if TYPES.check(to.info.tp,'?') then
            LINE(me, [[
]]..V(to)..[[.is_set = 0;
]])
        end
    end,

    Set_Alias = function (me)
        local fr, to = unpack(me)

        if (to.info.dcl.__dcls_code_alias == '&?') and (not to.info.dcl.__adjs_is_abs_await) then
            LINE(me, [[
]]..V(to,{is_bind=true})..' = '..V(fr)..[[;
_ceu_mem->_trails[]]..(to.dcl.trails[1])..[[].evt.mem = ]]..V(fr)..[[;
]])
        else
            -- var Ee.Xx ex = ...;
            -- var& Ee = &ex;
            local cast = ''
            if to.info.dcl.tag=='Var' and to.info.tp.tag=='Type'
                and to.info.tp[1].tag == 'ID_abs'
            then
                cast = '('..TYPES.toc(to.info.tp)..'*)'
            end
            LINE(me, [[
]]..V(to, {is_bind=true})..' = '..cast..V(fr)..[[;
]])

            if fr.tag == 'Exp_1&' then
                local _, call = unpack(fr)
                if (call.tag=='Exp_call' or call.tag=='Abs_Call') then
                    if to.info.dcl[1] == '&' then
                        LINE(me, [[
ceu_assert(]]..V(to,{is_bind=true})..[[!=NULL, "call failed");
]])
                    end
                end
            end
        end
    end,

    Set_Await_one = function (me)
        local fr, to = unpack(me)
        CONC_ALL(me)
        assert(fr.tag == 'Await_Wclock')
        SET(me, to, 'CEU_APP.wclk_late', nil,true)
    end,
    Set_Await_many = function (me)
        local Await, List = unpack(me)
        CONC(me, Await)

        local loc = AST.get(Await,'Await_Int',1,'Loc')
        local abs = loc and TYPES.abs_dcl(loc.info.tp,'Code')
        if abs then
            assert(not (loc.info.dcl.tag=='Var' and TYPES.is_nat(loc.info.tp)), 'bug found')
            assert(#List == 1)
            local to = unpack(List)
            local code = TYPES.abs_dcl(loc.info.tp, 'Code')

            local spawn = AST.get(me,2,'Par_Or', 1,'Stmts', 1,'Set_Abs_Spawn', 1,'Abs_Spawn')
            if spawn then
                -- x = await Ff();
                --  to
                -- _spw = spawn Ff();
                -- x = await _spw;
                SET(me, to, CUR('__mem_'..spawn.n)..'._ret', nil,true)
            else
                LINE(me, [[
if (_ceu_occ!=NULL && _ceu_occ->evt.id==CEU_INPUT__CODE_TERMINATED) {
    ]]..V(to)..[[.is_set = 1;
    ]]..V(to)..[[.value  = ((tceu_code_mem_]]..abs.id_..[[*)_ceu_occ->evt.mem)->_ret;
} else {
    ]]..V(to)..[[.is_set = 0;
}
]])
            end
        else
            local id do
                local ID_ext = AST.get(Await,'Await_Ext', 1,'ID_ext')
                if ID_ext then
                    id = 'tceu_input_'..ID_ext.dcl.id
                else
                    local sufix = TYPES.noc(TYPES.tostring(loc.info.dcl[2]))
                    id = 'tceu_event_'..sufix
                end
            end
            for i, loc in ipairs(List) do
                if loc.tag ~= 'ID_any' then
                    local ps = '(('..id..'*)(_ceu_occ->params))'
                    SET(me, loc, ps..'->_'..i, nil,true)
                end
            end
        end
    end,

    Set_Emit_Ext_emit = CONC_ALL,   -- see Emit_Ext_emit
    Set_Abs_Await     = CONC_ALL,   -- see Abs_Await

    Set_Abs_Val = function (me)
        local fr, to = unpack(me)
        local _,Abs_Cons = unpack(fr)
        SET(me, to, Abs_Cons, nil,nil, nil,{to_val=V(to)})
    end,

    Set_Vec = function (me)
        local Vec_Cons, to = unpack(me)

        LINE(me, [[
{
    usize __ceu_nxt;
]])

        for i, fr in ipairs(Vec_Cons) do
            -- concat or set?
            if i == 1 then
                if fr.tag == 'Loc' then
                    -- vec = vec..
                    LINE(me, [[
    __ceu_nxt = ]]..V(to)..[[.len;
]])
                else
                    -- vec = []..
                    LINE(me, [[
    ceu_vector_setlen(&]]..V(to)..[[, 0, 0);
    __ceu_nxt = 0;
]])
                end
            end

            -- vec1 = .."string"
            if fr.info and TYPES.check(fr.info.tp, '_char', '&&') then
                LINE(me, [[
    {
        const char* __ceu_str = ]]..V(fr)..[[;
        usize __ceu_len = strlen(__ceu_str) + 1;  /* +1 = '\0' */
]])
        LINE(me, [[
        ceu_vector_setlen(&]]..V(to)..', ('..V(to)..[[.len + __ceu_len), 1);
        ceu_vector_buf_set(&]]..V(to)..[[,
                           __ceu_nxt,
                           (byte*)__ceu_str,
                           __ceu_len);
        __ceu_nxt += __ceu_len;
    }
]])

            -- vec1 = ..[a,b,c]
            elseif fr.tag == 'Vec_Tup' then
                local List_Exp = unpack(fr)
                if List_Exp then
                    LINE(me, [[
    ceu_vector_setlen(&]]..V(to)..', ('..V(to)..'.len + '..#List_Exp..[[), 1);
]])
                    for _, e in ipairs(List_Exp) do
                        LINE(me, [[
    *((]]..TYPES.toc(to.info.tp)..[[*)
        ceu_vector_buf_get(&]]..V(to)..[[, __ceu_nxt++)) = ]]..V(e)..[[;
]])
                    end
                    LINE(me, [[
]])
                end

            -- vec1 = ..[[lua]]
            elseif fr.tag == 'Lua' then
                CONC(me, fr)
                LINE(me, [[
    if (lua_isstring(]]..LUA(me)..[[,-1)) {
        const char* __ceu_str = lua_tostring(]]..LUA(me)..[[, -1);
        usize __ceu_len = lua_rawlen(]]..LUA(me)..[[, -1);
        ceu_vector_setlen_ex(&]]..V(to)..', ('..V(to)..[[.len + __ceu_len), 1,
                             CEU_TRACE(-4));
        ceu_vector_buf_set(&]]..V(to)..[[,
                           __ceu_nxt,
                           (byte*)__ceu_str,
                           __ceu_len);
        __ceu_nxt += __ceu_len;
    } else {
        lua_pop(]]..LUA(me)..[[,1);
        lua_pushstring(]]..LUA(me)..[[, "not implemented [2]");
        goto _CEU_LUA_ERR_]]..fr.n..[[;
    }
]])
                LINE(me, fr.code_after)

            -- vec1 = ..vec2
            else--if fr.tag == 'Loc' then
                if i > 1 then
                    -- NO:
                    -- vector&[] v2 = &v1;
                    -- v1 = []..v2;
                    LINE(me, [[
    ceu_assert(&]]..V(fr)..' != &'..V(to)..[[, "source is the same as destination");
]])
                    LINE_DIRECTIVE(me)
                    LINE(me, [[
    ceu_vector_copy(&]]..V(to)..', __ceu_nxt, &'..V(fr)..[[, 0, ]]..V(fr)..[[.len);
]])
                else
                    -- v1 = v1....
                    -- nothing to to
                end
                LINE(me, [[
    __ceu_nxt = ]]..V(to)..[[.len;
]])

            --else
                --error'bug found'
            end
        end

        LINE(me, [[
}
]])
    end,

    ---------------------------------------------------------------------------

    Await_Forever = function (me)
        HALT(me)
    end,

    Await_Until = function (me)
        local awt, cnd = unpack(me)
        if cnd then
            LINE(me, [[
do {
]])
            CONC(me, awt)
            LINE(me, [[
} while (!]]..V(cnd)..[[);
]])
        else
            CONC(me, awt)
        end
    end,

    ---------------------------------------------------------------------------

    Await_Pause = function (me)
        HALT(me, {
            { evt = '((tceu_evt){CEU_INPUT__PAUSE,{NULL}})' },
            { lbl = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
    end,
    Await_Resume = function (me)
        HALT(me, {
            { evt =  '((tceu_evt){CEU_INPUT__RESUME,{NULL}})' },
            { lbl = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
    end,

    Await_Ext = function (me)
        local ID_ext = unpack(me)
        HALT(me, {
            { evt = V(ID_ext) },
            { seq = '(tceu_nseq)(CEU_APP.seq+1)' },
            { lbl = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
    end,

    Emit_Ext_emit = function (me)
        local ID_ext, List_Exp = unpack(me)
        local inout, Typelist = unpack(ID_ext.dcl)
        LINE(me, [[
{
]])
        local ps = 'NULL'
        if #List_Exp > 0 then
            if AST.par(me,'Async_Isr') then
                LINE(me, 'static ')
            end
            LINE(me, [[
tceu_]]..inout..'_'..ID_ext.dcl.id..[[ __ceu_ps;
]])
            for i, exp in ipairs(List_Exp) do
                if TYPES.check(Typelist[i],'?') then
                    if exp.tag == 'ID_any' then
                        LINE(me, [[
__ceu_ps._]]..i..[[.is_set = 0;
]])
                    else
                        if TYPES.check(exp.info.tp,'?') then
                            LINE(me, [[
__ceu_ps._]]..i..' = '..V(exp)..[[;
]])
                        else
                            LINE(me, [[
__ceu_ps._]]..i..[[.is_set = 1;
__ceu_ps._]]..i..'.value = '..V(exp)..[[;
]])
                        end
                    end
                else
                    LINE(me, [[
__ceu_ps._]]..i..' = '..V(exp)..[[;
]])
                end
            end
            ps = '&__ceu_ps'
        end

        if inout == 'output' then
            local set = AST.par(me,'Set_Emit_Ext_emit')
            local cb = [[
(ceu_callback_num_ptr(CEU_CALLBACK_OUTPUT, ]]..V(ID_ext)..'.id, '..ps..[[, CEU_TRACE(0)), ceu_callback_ret.num);
]]
            if set then
                local _, to = unpack(set)
                SET(me, to, cb, nil,true)
            else
                LINE(me, cb)
            end
        else
            if AST.par(me, 'Async') then
                LINE(me, [[
CEU_APP.async_pending = 1;
ceu_callback_num_ptr(CEU_CALLBACK_ASYNC_PENDING, 0, NULL, CEU_TRACE(0));
_ceu_mem->_trails[]]..me.trails[1]..[[].evt.id = CEU_INPUT__ASYNC;
_ceu_mem->_trails[]]..me.trails[1]..[[].seq    = (tceu_nseq)(CEU_APP.seq+1);
_ceu_mem->_trails[]]..me.trails[1]..[[].lbl    = ]]..me.lbl_out.id..[[;
{
    tceu_stk __ceu_stk = { 1, 0, _ceu_stk, {_ceu_mem,]]..me.trails[1]..','..me.trails[1]..[[} };
    ceu_input_one(]]..V(ID_ext)..'.id, '..ps..[[, &__ceu_stk);
    CEU_LONGJMP_JMP((&__ceu_stk));
}
]])
            else
                local isr = assert(AST.par(me,'Async_Isr'))
                local exps = unpack(isr)
                LINE(me, [[
{
    tceu_evt_id_params __ceu_evt = { ]]..V(ID_ext)..'.id, '..ps..[[ };
    ceu_callback_num_ptr(CEU_CALLBACK_ISR_EMIT, ]]..V(exps[1])..[[, (void*)&__ceu_evt, CEU_TRACE(0));
}
]])
            end
            if AST.par(me, 'Async') then
                HALT(me, {
                    lbl = me.lbl_out.id,
                })
            end
        end
        LINE(me, [[
}
]])
    end,

    ---------------------------------------------------------------------------

    Await_Int = function (me)
        local Loc = unpack(me)
        local alias, tp = unpack(Loc.info.dcl)
        if Loc.info.tag == 'Var' then
            assert(alias == '&?')
            if not me.__adjs_is_abs_await then
                LINE(me, [[
if (]]..V(Loc)..[[ != NULL)
]])
            end
            LINE(me, '{')
            HALT(me, {
                { ['evt.id']  = 'CEU_INPUT__CODE_TERMINATED' },
                { ['evt.mem'] = '(tceu_code_mem*)'..V(Loc) },
                { seq = '(tceu_nseq)(CEU_APP.seq+1)' },
                { lbl = me.lbl_out.id },
                lbl = me.lbl_out.id,
            })
            LINE(me, '}')
        else
            HALT(me, {
                { evt = V(Loc) },
                { seq = '(tceu_nseq)(CEU_APP.seq+1)' },
                { lbl = me.lbl_out.id },
                lbl = me.lbl_out.id,
            })
        end
    end,

    Emit_Evt = function (me)
        local Loc, List_Exp = unpack(me)
        local Typelist = unpack(Loc.info.dcl)
        LINE(me, [[
{
]])
        local ps = 'NULL'
        if List_Exp then
            local sufix = TYPES.noc(TYPES.tostring(Loc.info.dcl[2]))
            LINE(me, [[
    tceu_event_]]..sufix..[[
        __ceu_ps = { ]]..table.concat(V(List_Exp),',')..[[ };
]])
            ps = '&__ceu_ps'
        end
        LINE(me, [[
    tceu_evt_occ __ceu_occ = { ]]..V(Loc)..[[, (tceu_nseq)(CEU_APP.seq+1), &__ceu_ps,
                               {(tceu_code_mem*)&CEU_APP.root,
                                0, (tceu_ntrl)(CEU_APP.root._mem.trails_n-1)}
                             };
    tceu_stk __ceu_stk  = { 1, 0, _ceu_stk, {_ceu_mem,_ceu_trlK,_ceu_trlK} };
    ceu_bcast(&__ceu_occ, &__ceu_stk, 1);
    CEU_LONGJMP_JMP((&__ceu_stk));
}
]])
    end,

    ---------------------------------------------------------------------------

    Await_Wclock = function (me)
        local e = unpack(me)

        local wclk = CUR('__wclk_'..me.n)

        LINE(me, [[
ceu_wclock(]]..V(e)..', &'..wclk..[[, NULL, CEU_TRACE(0));

_CEU_HALT_]]..me.n..[[_:
]])
        HALT(me, {
            { ['evt.id'] = 'CEU_INPUT__WCLOCK' },
            { seq        = '(tceu_nseq)(CEU_APP.seq+1)' },
            { lbl        = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
        LINE(me, [[
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_occ->params;
    if (!ceu_wclock(*dt, NULL, &]]..wclk..[[, CEU_TRACE(0)) ) {
        goto _CEU_HALT_]]..me.n..[[_;
    }
}
]])
    end,

    Emit_Wclock = function (me)
        local e = unpack(me)
        if AST.par(me,'Async') then
            LINE(me, [[
CEU_APP.async_pending = 1;
ceu_callback_num_ptr(CEU_CALLBACK_ASYNC_PENDING, 0, NULL, CEU_TRACE(0));
{
    s32 __ceu_dt = ]]..V(e)..[[;
    do {
        tceu_stk __ceu_stk = { 1, 0, _ceu_stk, {_ceu_mem,]]..me.trails[1]..','..me.trails[1]..[[} };
        ceu_input_one(CEU_INPUT__WCLOCK, &__ceu_dt, _ceu_stk);
        CEU_LONGJMP_JMP((&__ceu_stk));
        __ceu_dt = 0;
    } while (CEU_APP.wclk_min_set <= 0);
}
]])
            HALT(me, {
                { ['evt.id'] = 'CEU_INPUT__ASYNC' },
                { seq        = '(tceu_nseq)(CEU_APP.seq+1)' },
                { lbl        = me.lbl_out.id },
                lbl = me.lbl_out.id,
            })
        else
            local isr = assert(AST.par(me,'Async_Isr'))
            local exps = unpack(isr)
            LINE(me, [[
{
    static s32 __ceu_dt;
    __ceu_dt = ]]..V(e)..[[;
    tceu_evt_id_params __ceu_evt = { CEU_INPUT__WCLOCK, &__ceu_dt };
    ceu_callback_num_ptr(CEU_CALLBACK_ISR_EMIT, ]]..V(exps[1])..[[, (void*)&__ceu_evt, CEU_TRACE(0));
}
]])
        end
    end,

    ---------------------------------------------------------------------------

    Async = function (me)
        local _,_,blk = unpack(me)
        LINE(me, [[
CEU_APP.async_pending = 1;
ceu_callback_num_ptr(CEU_CALLBACK_ASYNC_PENDING, 0, NULL, CEU_TRACE(0));
]])
        HALT(me, {
            { ['evt.id'] = 'CEU_INPUT__ASYNC' },
            { seq        = '(tceu_nseq)(CEU_APP.seq+1)' },
            { lbl        = me.lbl_in.id },
            lbl = me.lbl_in.id,
        })
        CONC(me, blk)
    end,

    ---------------------------------------------------------------------------

    Set_Async_Thread = function (me)
        local thread, to = unpack(me)

        local v   = CUR('__thread_'..thread.n)
        local chk = '(('..v..' != NULL) && ('..v..'->has_started))'

        CONC_ALL(me)
        SET(me, to, chk, nil,true)
    end,

    Async_Thread = function (me)
        local _,_, blk = unpack(me)

        local v = CUR('__thread_'..me.n)

-- TODO: pause, resume
        -- finalize
        LINE(me, [[
_ceu_mem->_trails[]]..me.trails[1]..[[].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[]]..me.trails[1]..[[].lbl    = ]]..me.lbl_fin.id..[[;
_ceu_mem->_trails[]]..me.trails[1]..[[].clr_range =
    (tceu_evt_range) { _ceu_mem, ]]..me.trails[1]..','..me.trails[2]..[[ };

if (0) {
]])
        CASE(me, me.lbl_fin)
        LINE(me, [[
    if (]]..v..[[ != NULL) {
        ]]..v..[[->has_aborted = 1;
        CEU_THREADS_CANCEL(]]..v..[[->id);
    }
]])
        HALT(me)
        LINE(me, [[
}
]])

        -- spawn
        LINE(me, [[
ceu_callback_ptr_num(CEU_CALLBACK_REALLOC,
                     NULL,
                     sizeof(tceu_threads_data),
                     CEU_TRACE(0)
                    );
]]..v..[[ = (tceu_threads_data*) ceu_callback_ret.ptr;
if (]]..v..[[ != NULL)
{
    ]]..v..[[->nxt = CEU_APP.threads_head;
    CEU_APP.threads_head = ]]..v..[[;
    if (CEU_APP.cur_ == &CEU_APP.threads_head) {
        CEU_APP.cur_ = &]]..v..[[->nxt;           /* TODO: HACK_6 "gc" mutable iterator */
    }

    ]]..v..[[->has_started    = 0;
    ]]..v..[[->has_terminated = 0;
    ]]..v..[[->has_aborted    = 0;
    ]]..v..[[->has_notified   = 0;

    tceu_threads_param p = { _ceu_mem, ]]..v..[[ };
    int ret =
        CEU_THREADS_CREATE(&]]..v..[[->id, _ceu_thread_]]..me.n..[[, &p);
    if (ret == 0) {
        while (! ]]..v..[[->has_started);   /* wait copy of "p" */
        while (1) {
]])
        HALT(me, {
            trail = me.trails[1]+1,
            { ['evt.id'] = 'CEU_INPUT__THREAD' },
            { lbl        = me.lbl_out.id },
            lbl = me.lbl_out.id,
        })
        LINE(me, [[
            {
                CEU_THREADS_T** __ceu_casted = (CEU_THREADS_T**)_ceu_occ->params;
                if (*(*(__ceu_casted)) == ]]..v..[[->id) {
                    break; /* this thread is terminating */
                }
            }
        }
    }
    /* proceed with sync execution (already locked) */
}
]])

        -- function definition
        CODES.threads = CODES.threads .. [[
static CEU_THREADS_PROTOTYPE(_ceu_thread_]]..me.n..[[,void* __ceu_p)
{
#define CEU_TRACE(n) ((tceu_trace){&_ceu_mem->trace,__FILE__,__LINE__+(n)})
    /* start thread */

    /* copy param */
    tceu_threads_param _ceu_p = *((tceu_threads_param*) __ceu_p);
    tceu_code_mem* _ceu_mem = _ceu_p.mem;
    _ceu_p.thread->has_started = 1;

    /* body */
    ]]..blk.code..[[
#if 0
    goto ]]..me.lbl_abt.id..[[; /* avoids "not used" warning */
#endif

    /* goto from "atomic" and already terminated */
]]..me.lbl_abt.id..[[:

    /* terminate thread */
    CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
    _ceu_p.thread->has_terminated = 1;
    _ceu_mem->_trails[]]..me.trails[1]..[[].evt.id = CEU_INPUT__NONE;
    ceu_callback_void_void(CEU_CALLBACK_THREAD_TERMINATING, CEU_TRACE_null);
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
    CEU_THREADS_RETURN(NULL);
#undef CEU_TRACE
}
]]
    end,

    Async_Isr = function (me)
        local exps, vars, _, blk = unpack(me)
        me.args = {}
        for _, arg in ipairs(exps) do
            me.args[#me.args+1] = V(arg)
        end
        me.args = table.concat(me.args,',')

        LINE(me, [[
{
    tceu_isr __ceu_isr = { CEU_ISR_]]..me.n..','..[[ _ceu_mem };
    int __ceu_args[] = { ]]..me.args..[[ };
    ceu_callback_ptr_ptr(CEU_CALLBACK_ISR_ATTACH, (void*)&__ceu_isr, &__ceu_args, CEU_TRACE(0));
}
]])

        CODES.isrs = CODES.isrs .. [[
typedef struct tceu_isr_mem_]]..me.n..[[ {
    ]]..me.mems.mem..[[
} tceu_isr_mem_]]..me.n..[[;

void CEU_ISR_]]..me.n..[[ (tceu_code_mem* _ceu_mem) {
    tceu_isr_mem_]]..me.n..[[ _ceu_loc;
    ]]..blk.code..[[
}
]]
    end,

    Finalize_Async_Isr = function (me)
        -- TODO: pause, resume
        local paror = AST.asr(me,6,'Par_Or')
        local isr = AST.asr(paror,1,'Stmts', paror.__i-1, 'Async_Isr')
        LINE(me, [[{
    tceu_isr __ceu_isr = { CEU_ISR_]]..isr.n..','..[[ _ceu_mem };
    int __ceu_args[] = { ]]..isr.args..[[ };
    ceu_callback_ptr_ptr(CEU_CALLBACK_ISR_DETACH, &__ceu_isr, &__ceu_args, CEU_TRACE(0));
}]])
    end,

    Atomic = function (me)
        local thread = AST.par(me, 'Async_Thread')
        if thread then
            LINE(me, [[
CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
if (_ceu_p.thread->has_aborted) {
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
    goto ]]..thread.lbl_abt.id..[[;   /* exit if ended from "sync" */
} else {                              /* othrewise, execute block */
]])
            CONC_ALL(me)
            LINE(me, [[
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
}
]])
        else
            LINE(me, 'ceu_callback_num_void(CEU_CALLBACK_ISR_ENABLE, 0, CEU_TRACE(0));')
            CONC_ALL(me)
            LINE(me, 'ceu_callback_num_void(CEU_CALLBACK_ISR_ENABLE, 1, CEU_TRACE(0));')
        end
    end,

    ---------------------------------------------------------------------------

    Set_Lua = function (me)
        local lua, to = unpack(me)
        local tp = to.info.tp

        CONC(me, lua)

        -- bool
        if TYPES.check(tp,'bool') then
            LINE(me, [[
]]..V(to)..[[ = lua_toboolean(]]..LUA(me)..[[,-1);
]])

        -- num
        elseif TYPES.is_num(tp) then
            LINE(me, [[
if (lua_isnumber(]]..LUA(me)..[[,-1)) {
    if (lua_isinteger(]]..LUA(me)..[[,-1)) {
        ]]..V(to)..[[ = lua_tointeger(]]..LUA(me)..[[,-1);
    } else {
        ]]..V(to)..[[ = lua_tonumber(]]..LUA(me)..[[,-1);
    }
} else {
    lua_pop(]]..LUA(me)..[[,1);
    lua_pushstring(]]..LUA(me)..[[, "number expected");
    goto _CEU_LUA_ERR_]]..lua.n..[[;
}
]])
        elseif TYPES.check(tp,'&&') then
            LINE(me, [[
{
    if (lua_islightuserdata(]]..LUA(me)..[[,-1)) {
        ]]..V(to)..[[ = lua_touserdata(]]..LUA(me)..[[,-1);
    } else {
        lua_pushstring(]]..LUA(me)..[[, "not implemented [3]");
        lua_pop(]]..LUA(me)..[[,1);
        goto _CEU_LUA_ERR_]]..lua.n..[[;
    }
}
]])
        else
            error 'not implemented'
        end

        LINE(me, lua.code_after)
    end,

    Lua_Do = CONC_ALL,
    Lua_Do_Open = function (me)
        local n = unpack(me)
        LINE(me, [[
]]..CUR('__lua_'..n)..[[ = luaL_newstate();
ceu_assert(]]..CUR('__lua_'..n)..[[ != NULL, "bug found");
luaL_openlibs(]]..CUR('__lua_'..n)..[[);
ceu_lua_createargtable(]]..CUR('__lua_'..n)..[[, CEU_APP.argv, CEU_APP.argc, CEU_APP.argc);
]])
    end,
    Lua_Do_Close = function (me)
        local n = unpack(me)
        LINE(me, [[
lua_close(]]..CUR('__lua_'..n)..[[);
]])
    end,

    Lua = function (me)
        local nargs = #me.params
        local is_set = AST.par(me,'Set_Lua') or AST.par(me,'Set_Vec')
        local nrets = (is_set and 1) or 0

        local lua = me.lua
        lua = string.format('%q', lua)
        lua = string.gsub(lua, '\n', 'n') -- undo format for \n

        me.code_after = [[
    if (0) {
/* ERROR */
_CEU_LUA_ERR_]]..me.n..[[:;
]]

        local in_thread = AST.par(me,'Async_Thread')
        if in_thread then
            WRN(false, me, 'exception inside `async/thread`')
        end

        if CEU.opts.ceu_features_exception and (not in_thread) then
            me.code_after = me.code_after .. [[
        tceu_data_Exception__dot__Lua __ceu_e = { CEU_DATA_Exception__dot__Lua, (char*)lua_tostring(]]..LUA(me)..[[,-1) };
]]..LINE_DIRECTIVE(me)..[[
        return ceu_throw(]]..CATCHES(me)..[[, (tceu_data_Exception*)&__ceu_e, sizeof(tceu_data_Exception__dot__Lua));
]]
        else
            me.code_after = me.code_after .. [[
]]..LINE_DIRECTIVE(me)..[[
        ceu_assert(0, lua_tostring(]]..LUA(me)..[[,-1));
]]
        end
        me.code_after = me.code_after .. [[
    }
/* OK */
    lua_pop(]]..LUA(me)..[[, ]]..(is_set and 1 or 0)..[[);
}
]]

        LINE(me, [[
{
    int err = luaL_loadstring(]]..LUA(me)..[[, ]]..lua..[[);
    if (err) {
        goto _CEU_LUA_ERR_]]..me.n..[[;
    }
]])

        for _, p in ipairs(me.params) do
            local tp = p.info.tp
            ASR(not TYPES.is_nat(tp), me, 'unknown type')
            if p.info.tag=='Vec' and p.info.dcl and p.info.dcl.tag=='Vec' then
                if TYPES.check(tp,'byte') then
                    LINE(me, [[
    {
        /* TODO: merge/hide inside ceu_vector.c */
        tceu_vector* vec = &]]..V(p)..[[;
        usize k  = (vec->max - ceu_vector_idx(vec,0));
        usize ku = k * vec->unit;

        if (vec->is_ring && ku<vec->len) {
            lua_pushlstring(]]..LUA(me)..[[, (char*)ceu_vector_buf_get(vec,0), ku);
            lua_pushlstring(]]..LUA(me)..[[, (char*)ceu_vector_buf_get(vec,k), vec->len-ku);
            lua_concat(]]..LUA(me)..[[, 2);
        } else {
            lua_pushlstring(]]..LUA(me)..[[, (char*)ceu_vector_buf_get(vec,0), vec->len);
            //lua_pushlstring(]]..LUA(me)..[[,(char*)]]..V(p)..[[.buf,]]..V(p)..[[.len);
        }
    }
]])
                else
                    error 'not implemented'
                end
            elseif TYPES.check(tp,'bool') then
                LINE(me, [[
    lua_pushboolean(]]..LUA(me)..[[,]]..V(p)..[[);
]])
            elseif TYPES.is_num(tp) then
                local tp_id = unpack(TYPES.ID_plain(tp))
                if tp_id=='real' or tp_id=='r32' or tp_id=='r64' then
                    LINE(me, [[
    lua_pushnumber(]]..LUA(me)..[[,]]..V(p)..[[);
]])
                else
                    LINE(me, [[
    lua_pushinteger(]]..LUA(me)..[[,]]..V(p)..[[);
]])
                end
            elseif TYPES.check(tp,'_char','&&') then
                LINE(me, [[
    lua_pushstring(]]..LUA(me)..[[,]]..V(p)..[[);
]])
            elseif TYPES.check(tp,'&&') then
                LINE(me, [[
    lua_pushlightuserdata(]]..LUA(me)..[[,]]..V(p)..[[);
]])
            else
                error 'not implemented'
            end
        end

        LINE(me, [[
    err = lua_pcall(]]..LUA(me)..[[, ]]..nargs..','..nrets..[[, 0);
    if (err) {
        goto _CEU_LUA_ERR_]]..me.n..[[;
    }
]])

        if not is_set then
            LINE(me, me.code_after)
        end
    end,
}

-------------------------------------------------------------------------------

local function SUB (str, from, to)
    assert(to, from)
    local i,e = string.find(str, from, 1, true)
    if i then
        return SUB(string.sub(str,1,i-1) .. to .. string.sub(str,e+1),
                   from, to)
    else
        return str
    end
end

AST.visit(CODES.F)

local labels do
    labels = ''
    for _, lbl in ipairs(LABELS.list) do
        labels = labels..lbl.id..',\n'
    end
end

local features do
    features = ''
    for k,v in pairs(CEU.opts) do
        if string.sub(k,1,13) == 'ceu_features_' then
            if v then
                features = features .. '#define '..string.upper(k)..'\n'
            end
        end
    end
end

-- CEU.C
local c = PAK.files.ceu_c
local c = SUB(c, '=== CEU_FEATURES ===',         features)
local c = SUB(c, '=== CEU_NATIVE_PRE ===',       CODES.native.pre)
local c = SUB(c, '=== CEU_EXTS_ENUM_INPUT ===',  MEMS.exts.enum_input)
local c = SUB(c, '=== CEU_ISRS_DEFINES ===',     MEMS.isrs)
local c = SUB(c, '=== CEU_EXTS_DEFINES_INPUT_OUTPUT ===', MEMS.exts.defines_input_output)
local c = SUB(c, '=== CEU_EVTS_ENUM ===',        MEMS.evts.enum)
local c = SUB(c, '=== CEU_DATAS_HIERS ===',      MEMS.datas.hiers)
local c = SUB(c, '=== CEU_DATAS_MEMS ===',       MEMS.datas.mems)
local c = SUB(c, '=== CEU_DATAS_MEMS_CASTS ===', table.concat(MEMS.datas.casts,'\n'))
local c = SUB(c, '=== CEU_EXTS_ENUM_OUTPUT ===', MEMS.exts.enum_output)
local c = SUB(c, '=== CEU_CALLBACKS_OUTPUTS ===', table.concat(CODES.exts,'\n'))
local c = SUB(c, '=== CEU_TCEU_NTRL ===',        TYPES.n2uint(AST.root.trails_n))
local c = SUB(c, '=== CEU_TCEU_NLBL ===',        TYPES.n2uint(#LABELS.list))
local c = SUB(c, '=== CEU_CODES_MEMS ===',       MEMS.codes.mems)
--local c = SUB(c, '=== CODES_ARGS ===',       MEMS.codes.args)
local c = SUB(c, '=== CEU_EXTS_TYPES ===',       MEMS.exts.types)
local c = SUB(c, '=== CEU_EVTS_TYPES ===',       MEMS.evts.types)
local c = SUB(c, '=== CEU_LABELS ===',           labels)
local c = SUB(c, '=== CEU_NATIVE_POS ===',       CODES.native.pos)
local c = SUB(c, '=== CEU_ISRS ===',             CODES.isrs)
local c = SUB(c, '=== CEU_THREADS ===',          CODES.threads)
local c = SUB(c, '=== CEU_CODES_WRAPPERS ===',   MEMS.codes.wrappers)
local c = SUB(c, '=== CEU_CODES ===',            AST.root.code)

if CEU.opts.ceu_output == '-' then
    print('\n\n/* CEU_C */\n\n'..c)
else
    local C = ASR(io.open(CEU.opts.ceu_output,'w'))
    C:write('\n\n/* CEU_C */\n\n'..c)
    C:close()
end

end

end
DBG,ASR = DBG1,ASR1
if CEU.opts.env then
    
do
local c = ''

--env-types
do
    local f = ASR(io.open(CEU.opts.env_types))
    c = c..'\n\n/* ENV_HEADER */\n\n'..f:read'*a'
    f:close()
end

--env-threads
do
    if CEU.opts.env_threads then
        local f = ASR(io.open(CEU.opts.env_threads))
        c = c..'\n\n/* ENV_THREADS */\n\n'..f:read'*a'
        f:close()
    end
end

if TESTS then
    c = c .. [[
u32 _ceu_tests_bcasts_ = 0;
u32 _ceu_tests_trails_visited_ = 0;
]]
end

--env-ceu
do
    local f = ASR(io.open(CEU.opts.env_ceu))
    c = c..'\n\n/* ENV_CEU */\n\n'..f:read'*a'
    f:close()
end

--env-main
do
    if CEU.opts.env_main then
        local f = ASR(io.open(CEU.opts.env_main))
        c = c..'\n\n/* ENV_MAIN */\n\n'..f:read'*a'
        f:close()
    end
end

--env-output
do
    local out = [[
/*
* This file is automatically generated.
* http://www.ceu-lang.org/
* http://github.com/fsantanna/ceu/
*
* CÃ©u is distributed under the MIT License:
*

Copyright (C) 2012-2016 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

]] .. c

    if CEU.opts.env_output == '-' then
        print(out)
    else
        local f = ASR(io.open(CEU.opts.env_output,'w'))
        f:write(out)
        f:close()
    end
end

end

end
if CEU.opts.cc then
    
do
--DBG(CEU.opts.cc_exe..' -xc '..CEU.opts.cc_input..' '..  '-o '..CEU.opts.cc_output..' '..  CEU.opts.cc_args..' 2>&1')
local cc = CEU.opts.cc_exe..' -xc "'..CEU.opts.cc_input..'" '..
            '-o "'..CEU.opts.cc_output..'" '..
            CEU.opts.cc_args..' 2>&1'
local f = assert(io.popen(cc))
local err = f:read'*a'
local ok = f:close()
ASR(ok, err)
DBG(err)

end

end
--AST.dump(AST.root)
